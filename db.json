{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.png","path":"img/alipay.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.png","path":"img/weixin.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1677636163905},{"_id":"themes/3-hexo/.gitignore","hash":"46eca80fe689a00cbe4d015c094702af54119021","modified":1677636163906},{"_id":"themes/3-hexo/README.md","hash":"b73da9407ce98ff15116f49d37d91771331e84e0","modified":1677637288859},{"_id":"themes/3-hexo/_config.yml","hash":"2b94fc1651a6885663a51c097c89e310922c56c5","modified":1677661987910},{"_id":"themes/3-hexo/LICENSE","hash":"f880ba89cc5b11356e69bccfae71c64d2b604294","modified":1677637288859},{"_id":"themes/3-hexo/languages/en.yml","hash":"616e02c035c86033ab4a97c5ae9e0a9e5f0b8ea3","modified":1677636163909},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1677636163929},{"_id":"themes/3-hexo/layout/index.ejs","hash":"1c185288c2925a652d577965626718e12df07f65","modified":1677660202894},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"83633d45420c96dfac41333aeac3f3616dca5286","modified":1677636163910},{"_id":"themes/3-hexo/layout/indexs.md","hash":"3901999478603d24244f6d985a9a3d5ee826c77f","modified":1677660651380},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"75285f7c6123db0121b04d74525a4f58bffeac36","modified":1677660743741},{"_id":"themes/3-hexo/layout/post.ejs","hash":"6f14d78f877bca280d8a294cdd2f6d7ff77c49dd","modified":1677660217232},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1677636163913},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"9e1cdec49d5b9b44399348d96ecd7331f3ee7d85","modified":1677636163913},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"48e849e1ab02edc0e19780de7f3a47057addbdd2","modified":1677649161435},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"d4a852f8878ec9205883edeef0c96a7e24d85bac","modified":1677638427475},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"9087af9647a87c3fa9ef87632de5427ba4abe9c4","modified":1677636163920},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"e6dd90be668195016d6e1c51a6baefb50676e6ab","modified":1677636163921},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"1e04b617fe38acca8b3d3774c5dbfcb74a02db6b","modified":1677636163922},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"60a085fab3165ea1fc6370abac0bd6ab1b2f2510","modified":1677636163921},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1677636163923},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ab6329ddd908b0567c18f39ac6a8553c6fec67c5","modified":1677636163923},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"ef64b18062d7faf7c2b36cac7c9181b46112593b","modified":1677637288863},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"0c693379995b09007727c2889c1a64e3bf98749e","modified":1677636163925},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"8704e6bd833d270cc6a494d4e7cf1dfeddedba40","modified":1677636163925},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1677636163926},{"_id":"themes/3-hexo/source/css/style.styl","hash":"2de4f2c4ed58e113469b9d5d4e18da76a89acdde","modified":1677661503820},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1677636163948},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"1c2f8b7d7cf46f219adb3a628bdf380f29ff4a6b","modified":1677636163961},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1677636163976},{"_id":"themes/3-hexo/source/js/script.js","hash":"8b817de2ca4d085cef0e938b21960666a86af903","modified":1677660273837},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1677636163975},{"_id":"themes/3-hexo/source/js/search.js","hash":"af872a4d423f747eaaddd6fb2a6953f04139901f","modified":1677637288860},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1677636163964},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"7299ac046ddd6e6a4267d435f7b4c8198baaaccc","modified":1677636163978},{"_id":"themes/3-hexo/source/img/alipay.png","hash":"5b94c900cd77c941f8c99c36a094a6f29d890408","modified":1677638370244},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1677636163965},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1677636163966},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"9e88426164e4f75cfadc3a366d50cbc374822a01","modified":1676785552176},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1677636163967},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1677636163914},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1677636163915},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1677636163916},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1677636163916},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"d5fa333970a2eac66937d42eeb16fdb362e121ed","modified":1677636163931},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"2d115e79cadedc2d5d8f4b5618559640d986e01f","modified":1677636163917},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"8f2d4f42fbad351677c82e72420224587a5bd666","modified":1677636163918},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1677636163932},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1677636163932},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"3db01e603985e6dbcacb6b0f13dbd804f5849e3c","modified":1677636163933},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1677636163936},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"b9330fdda13ca52c2c6def72d58ad4bd606abf80","modified":1677661503827},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"ec5f8e3916b7e4fced94142e81d5d17347a4dc52","modified":1677661503827},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"2371c77fe590dc0b5d4df6a287260dfb0e459dfa","modified":1677661503827},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1677636163938},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"6ffbda829c7a3866f3644113eb6017c1e0eb061f","modified":1677660801507},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"f1251e2a3b5334af3a22b51fc0293c2456568b50","modified":1677636163937},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1677636163939},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1677636163940},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1677636163941},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1677636163942},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1677636163945},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1677636163944},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1677636163943},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1677636163947},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1677636163946},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1677636163949},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1677636163951},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1677636163952},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1677636163953},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1677636163953},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1677636163955},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1677636163952},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1677636163954},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1677636163955},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1677636163957},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1677636163956},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1677636163957},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1677636163958},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1677636163959},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1677636163959},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1677636163960},{"_id":"themes/3-hexo/source/img/weixin.png","hash":"9e00b08337763ae91841d66d3a3cc0d974ca5f95","modified":1677638332403},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1677636163974},{"_id":"source/about/index.md","hash":"579ff97b4c8cd1e3f4e0f931fca501447a66cf9b","modified":1677639677737},{"_id":"source/_posts/后端/demo.md","hash":"be6529950652cac9bcfce17bbc632ea6b7dd239e","modified":1677658136498},{"_id":"source/_posts/git/02-git远程仓库操作.md","hash":"4b34ef5736bd5ee681ee36ec484cba9b6f27b521","modified":1677654546088},{"_id":"source/_posts/git/01-git本地仓库操作.md","hash":"4326a4d618c14a40f76a5d3fb676079c6248de02","modified":1677654217720},{"_id":"source/_posts/前端/前端性能优化.md","hash":"881b76c5dd7f5053d5907e2cb60e6e443c08a58c","modified":1677664183656},{"_id":"source/_posts/前端/vue/vue3杂烩.md","hash":"b62dbf202c35e3a6530c4b9ee0f3fb296e6a1eb9","modified":1677658140945},{"_id":"source/_posts/运维/demo.md","hash":"179ea476db7653a995fd444e57942ab8eacac96e","modified":1677658129922},{"_id":"source/_posts/前端/原生js/js线程,事件级别,宿主对象.md","hash":"6803ae9cc02a282b5ab56239039c624bd7321b16","modified":1677664164254},{"_id":"source/_posts/前端/vue/vue轮播图帧率播放.md","hash":"edc863f30d173284bfa350632bfd67faa0b2ae48","modified":1677661135085},{"_id":"source/_posts/前端/vue/学习vue3-admin-elementPlus.md","hash":"b803ed865f58cb37004d2e18559a5d18cb4406c7","modified":1677662546941},{"_id":"source/_posts/前端/原生js/js不常见方法及属性.md","hash":"b7c5b4ff509ef25f41ae6f2b28ed4b05626fdc93","modified":1677664248161},{"_id":"source/_posts/前端/原生js/清除所有页面定时器.md","hash":"1262c3f462cc958c696ff2bc1a7c44d753f96242","modified":1677662488309},{"_id":"source/_posts/前端/原生js/es6 Api总结.md","hash":"16aa84ba11de132b19b6cbc04fb4b37ac99fce6c","modified":1677663918161},{"_id":"source/_posts/笔记/ocean/00-常用正则/00-note.md","hash":"ae5f506309c3dd2ea690ca1aea7ca96d1823c6c0","modified":1677654395032},{"_id":"source/_posts/笔记/ocean/00-new知识/doubt.md","hash":"d00cddbd3a7e3b4be530d739eba69731469db4fe","modified":1677654404846},{"_id":"source/_posts/笔记/ocean/00-常用正则/常用正则.md","hash":"124465a38d4d52e61b997953c90124dfe7633d0b","modified":1677654397825},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/JS数组,字符串,对象.md","hash":"b1666b8b82e3af4690e4ba87c9d7d13e531777a0","modified":1677654446186},{"_id":"source/_posts/笔记/ocean/12-Vue总结/问提.md","hash":"f94a80394f28fdabfa5b1e7d11a486b48e36fb0f","modified":1677655738031},{"_id":"source/_posts/笔记/ocean/10-node.js总结/解决node端口占用.txt","hash":"efdb0c250f21cfeebb361f5d2aa19aed7620d1b0","modified":1677651211364},{"_id":"source/_posts/笔记/ocean/14-vue原理/01-note.md","hash":"a9f346f4f7a9c9ef5391994cd5d3df4569bc6526","modified":1677655757687},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/05-对象和复杂类型数据/05-笔记.md","hash":"9842738669b9ddb217b8ed46c1557be2beaa1923","modified":1677654435157},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/01-js是什么/01-笔记.md","hash":"36d1d178a0603109e7ea8e10ddb1c863fa9b52e0","modified":1677654421648},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/03-数组和冒泡排序/03-笔记.md","hash":"8f82c01adf02bbaacbe97c3428fb945f6aad4606","modified":1677654428151},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/02-操作符和流程控制/02-笔记.md","hash":"b2029b7f820e2d096c3ebaabbee5168286dd41b6","modified":1677654423999},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/04-函数和作用域/04-笔记.md","hash":"0a4bed6075416eaa5de929595b36254123f9a407","modified":1677654430295},{"_id":"source/_posts/笔记/ocean/01-html总结/01-什么是html/01-笔记.md","hash":"25a3393d176b6493acb814ad70d60ba0d2f0066d","modified":1677654413031},{"_id":"source/_posts/笔记/ocean/03-javascript基础总结/06-数组和字符串方法/06-笔记.md","hash":"72d63cf41c17d820ae8a50c1fbd5f96a29dd40ce","modified":1677654444374},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/03-localStorage/03-笔记.md","hash":"8286c27fb0144cc97e5e67a88f63b8a213bf1f21","modified":1677653676112},{"_id":"source/_posts/笔记/ocean/01-html总结/02-表格和表单/02-笔记.md","hash":"51be8433a0bf595b6148d3b641d8aba473de282a","modified":1677654415262},{"_id":"source/_posts/笔记/ocean/01-html总结/canvas画布/canvas.md","hash":"ad06d8192247b8d253890a9b8e0f7e7ba6927bc7","modified":1677654418758},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/04-BOM定时器/04-笔记.md","hash":"83bab52e3157a131013e05cae8bd6e181210e98d","modified":1677653713318},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/01-获取DOM节点/01-note.md","hash":"b231feaf5ae9368ad6c169b952af12f6a2c87942","modified":1677653634335},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/02-事件委托和冒泡/02-笔记.md","hash":"81627049e70a3477ea1c83a6af7e82054503607d","modified":1677653658605},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/05-鼠标事件和event/05-note.md","hash":"5396f14148673c02bba7091343e605759d90eeb3","modified":1677653749954},{"_id":"source/_posts/笔记/ocean/05-javascript高级总结/01-原型/01-note.md","hash":"0e24af5e12291d4d9e562f3548f7e03dde75e8eb","modified":1677653796367},{"_id":"source/_posts/笔记/ocean/04-javascript_webapi/06-插件/06-笔记.md","hash":"d21e5a3590285e38e159b8d17be47df48f1af26f","modified":1677653775743},{"_id":"source/_posts/笔记/ocean/05-javascript高级总结/04-递归和正则/04-笔记.md","hash":"65f68b80fcc559ba0b6240a8848b713bdadadf4c","modified":1677653956371},{"_id":"source/_posts/笔记/ocean/05-javascript高级总结/03-函数和闭包/03-笔记.md","hash":"9e416248c004c41c45916dd06361861375617463","modified":1677653936872},{"_id":"source/_posts/笔记/ocean/06-jquery总结/03-对象尺寸与位置/03-笔记.md","hash":"f0b3e14fc7a3bd3d13d1de947d68d8a29f07493a","modified":1677654036814},{"_id":"source/_posts/笔记/ocean/07-Ajax总结/01-jq中的ajax/01-ajax笔记.md","hash":"ad70ae2bd9c997aa7fe991fef93a1f76e807fdf5","modified":1677654062865},{"_id":"source/_posts/笔记/ocean/06-jquery总结/01-方法和事件和类/01-笔记.md","hash":"e1f1291166adb94c79a5ae1b7b51f8f1d4901ca6","modified":1677654002552},{"_id":"source/_posts/笔记/ocean/05-javascript高级总结/02-类和继承/02-note.md","hash":"71e31b0abd1af815f6b54a58c3060b011a0b2f87","modified":1677653812190},{"_id":"source/_posts/笔记/ocean/06-jquery总结/02-方法和循环/02-笔记.md","hash":"ed6703bf0ecd7913b8efe9ad69f1b8ac1eb2fbd3","modified":1677654025320},{"_id":"source/_posts/笔记/ocean/07-Ajax总结/04-axios和跨域/04-笔记.md","hash":"dffa71c94b010bce6f41e66ac0375d18a6ddfc9d","modified":1677654124606},{"_id":"source/_posts/笔记/ocean/10-node.js总结/02-模块化开发和包/02-笔记.md","hash":"523e2acafc2643335f0623fc7d16364981cd2eb2","modified":1677654683144},{"_id":"source/_posts/笔记/ocean/10-node.js总结/01-什么是node.js/01-笔记.md","hash":"b6ee5e5ae185f021c40edcd6f4526f8218a7bf65","modified":1677654665321},{"_id":"source/_posts/笔记/ocean/10-node.js总结/04-promise/mysql返回的数据.png","hash":"096af06e39b0ce62ca979c1738d5f0df92c78c7a","modified":1677651211363},{"_id":"source/_posts/笔记/ocean/10-node.js总结/03-express/03-笔记.md","hash":"d998c3c27817d3c229dc23b9bdab7cd632cb1fc4","modified":1677654710623},{"_id":"source/_posts/笔记/ocean/10-node.js总结/04-promise/04-笔记.md","hash":"69013f379a129060cfdd053d2272d2b30057b63c","modified":1677654729595},{"_id":"source/_posts/笔记/ocean/12-Vue总结/03-component-生命周期-computed/03-笔记.md","hash":"3f56ac7166f5efbd1665daffb14b217295a9cf59","modified":1677655684816},{"_id":"source/_posts/笔记/ocean/12-Vue总结/01-什么是vue/01-笔记.md","hash":"d47d3818feeea720d717678b3881b12df8c18031","modified":1677655658065},{"_id":"source/_posts/笔记/ocean/12-Vue总结/06-vuex/01-note.md","hash":"61c47d1bbd8d04cb0b8301c05aa07fe2b8aebc93","modified":1677655722575},{"_id":"source/_posts/笔记/ocean/12-Vue总结/02-进阶directive-双向绑定/02-笔记.md","hash":"5bccb1a39baaf89f25782b3af77c620ee71bc212","modified":1677655672459},{"_id":"source/_posts/笔记/ocean/12-Vue总结/04-component通信/04-note.md","hash":"5758d3e5ca9cc2fadf58061175f313c1ca741c47","modified":1677655701066},{"_id":"source/_posts/笔记/ocean/15-react/02/00-note.md","hash":"75b005bc1a176e0baf57bb7ea5a79dd8dcb9239a","modified":1677655823095},{"_id":"source/_posts/笔记/ocean/15-react/04/00-note.md","hash":"ec1207c61c99d957a0db57087fc92668ea76e769","modified":1677655915559},{"_id":"source/_posts/笔记/ocean/15-react/01/00-note.md","hash":"0e59139ac1be52afb03252b6d70f4507b3852b14","modified":1677655813111},{"_id":"source/_posts/笔记/ocean/15-react/03/00-note.md","hash":"6aceaad143aeadb948d3859f0c170872cff8dd2b","modified":1677655841609},{"_id":"source/_posts/git/assets/Snipaste_2020-09-27_20-44-43.png","hash":"08b8747725c1f9e04129ac0ea1abd1107fa27219","modified":1677651211062},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"3e2e0cf9caa6b8d07b9c5e0733a1ccb3e244259f","modified":1677636163972},{"_id":"public/about/index.html","hash":"f03baf40f092c3a7a9bb1b0d871ca9bee31d96b2","modified":1677664319585},{"_id":"public/2023/03/01/后端/demo/index.html","hash":"9aa4ca63033465abe8baf1666fb15c7c56ff1ccc","modified":1677664319585},{"_id":"public/2023/03/01/运维/demo/index.html","hash":"e0151f34f321d17ebd3f13647c2f9154d38daeb9","modified":1677664319585},{"_id":"public/2023/03/01/前端/vue/学习vue3-admin-elementPlus/index.html","hash":"053b897e68f93faf206e2f17a1436628559dae73","modified":1677664319585},{"_id":"public/2023/03/01/前端/vue/vue3杂烩/index.html","hash":"0839db1ee92414aaa30b2487c2f02b181b99e4df","modified":1677664319585},{"_id":"public/2020/09/25/前端/vue/vue轮播图帧率播放/index.html","hash":"611d2518fee8e44a9fc6ccd42918d64b7d40fae7","modified":1677664319585},{"_id":"public/2020/09/06/git/01-git本地仓库操作/index.html","hash":"3f2e322b30b13b3ba123a19de3ab0cadc34c2fbc","modified":1677664319585},{"_id":"public/2020/09/06/git/02-git远程仓库操作/index.html","hash":"c3d6f93a370e30f071ce4932d4a63d9d677d8b38","modified":1677664319585},{"_id":"public/2020/08/22/前端/原生js/js线程,事件级别,宿主对象/index.html","hash":"23db56d3948d7f656a3754067061a4b19ebf81de","modified":1677664319585},{"_id":"public/2020/08/22/前端/原生js/js不常见方法及属性/index.html","hash":"a87be2c5b835265a60d9e2ea28565970beb39b49","modified":1677664319585},{"_id":"public/2020/08/22/前端/原生js/清除所有页面定时器/index.html","hash":"9176b3d76cb674bd7b75b96094d5f5a5f4d2a7de","modified":1677664319585},{"_id":"public/2020/08/20/前端/原生js/es6 Api总结/index.html","hash":"f8ecfcb6233ab8e1c410c1808be3eac25eb70e5a","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/问提/index.html","hash":"c9d6acd102584deda969f546e6fab8045808682b","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/14-vue原理/01-note/index.html","hash":"021525afe960f0782a65ac153635a9784bc4fc6e","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/01-什么是vue/01-笔记/index.html","hash":"5e25acc7a9a3b7fa28c0c3f28d0263152ee4b3bc","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/03-component-生命周期-computed/03-笔记/index.html","hash":"92389ee2b80c877b17eb4f480c97054bf6d5a29b","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/02-进阶directive-双向绑定/02-笔记/index.html","hash":"27827da71070ae166ea171e17009a4119166c950","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/06-vuex/01-note/index.html","hash":"e97ff1c5c2c6d30f29469b406b2f332389bdff2a","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/12-Vue总结/04-component通信/04-note/index.html","hash":"106bc0c5a5b0175a30107b7451760c70a2574913","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/15-react/02/00-note/index.html","hash":"15c16517e34bd231aebaee0caba1e027c3a0aa47","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/15-react/01/00-note/index.html","hash":"950ae83014ac427a131de67a135cf7e2b01e32a4","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/15-react/03/00-note/index.html","hash":"c0db4fe7fa6c9d091d5e49db8663e445a9c95ebf","modified":1677664319585},{"_id":"public/2020/08/20/笔记/ocean/15-react/04/00-note/index.html","hash":"a175d2853951cc2ec4cdbfccb2b7564cd72d9f5a","modified":1677664319585},{"_id":"public/2019/05/06/前端/前端性能优化/index.html","hash":"067ba4458a573633f0de98f25e667aad17715f93","modified":1677664319585},{"_id":"public/2019/05/06/笔记/ocean/00-new知识/doubt/index.html","hash":"379eb097e001ede00a5a8ad9d72fb922727c6ec0","modified":1677664319585},{"_id":"public/2019/04/12/笔记/ocean/00-常用正则/常用正则/index.html","hash":"f83e5efa4e0233b9f4168cfefd65bf60ff8ab4c9","modified":1677664319585},{"_id":"public/2019/04/12/笔记/ocean/10-node.js总结/01-什么是node.js/01-笔记/index.html","hash":"90bc574d354052e0f46bb9c4bf09ed7742ff7bde","modified":1677664319585},{"_id":"public/2019/04/12/笔记/ocean/10-node.js总结/03-express/03-笔记/index.html","hash":"0fc7aba346de20a437663159215bb200da8fb814","modified":1677664319585},{"_id":"public/2019/04/12/笔记/ocean/10-node.js总结/02-模块化开发和包/02-笔记/index.html","hash":"ee46b9338b9c47f32471680a8b9ae8ddf24fb9bf","modified":1677664319585},{"_id":"public/2019/04/12/笔记/ocean/10-node.js总结/04-promise/04-笔记/index.html","hash":"9cf94c52013516df0db49667925cf138bc302baa","modified":1677664319585},{"_id":"public/2019/04/02/笔记/ocean/00-常用正则/00-note/index.html","hash":"ffd45fbddb4b7d92d955e34182c670b08930247e","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/JS数组,字符串,对象/index.html","hash":"863c570e5d85636b2f2c542330bd0147434dc557","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/01-js是什么/01-笔记/index.html","hash":"7d30e4e11109ed1b33f51bca73a220cdcedc1067","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/03-数组和冒泡排序/03-笔记/index.html","hash":"78a6a3c21e5da88e4c623f46eca078d1e77de027","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/05-对象和复杂类型数据/05-笔记/index.html","hash":"ddc85582f1bb595d1c12354ee0d0fd90988d6424","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/02-操作符和流程控制/02-笔记/index.html","hash":"ca45e719586ee5ce7c377c2327ff893df7a03881","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/04-函数和作用域/04-笔记/index.html","hash":"127746a945ca9d47cf486536446d718e25f0fa8d","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/03-javascript基础总结/06-数组和字符串方法/06-笔记/index.html","hash":"0b90443b86ddd96947b1f09329db286407f7d2e0","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/03-localStorage/03-笔记/index.html","hash":"dab08d2519c59f7b5ac0886426e02798c2a6b2d8","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/02-事件委托和冒泡/02-笔记/index.html","hash":"87cf663192c3462d60b71926fc2048b7f68ed7de","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/04-BOM定时器/04-笔记/index.html","hash":"c06935622d3b8e23614b49792d445206d5018a0e","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/01-获取DOM节点/01-note/index.html","hash":"64a8d8d80941301fd7346730552464965d29f97c","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/05-javascript高级总结/01-原型/01-note/index.html","hash":"86f0515d8d49c00ea89aa761091402df4e2eefbe","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/06-插件/06-笔记/index.html","hash":"1957e2505b219016f67e7238e7d66a236b0edc85","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/05-javascript高级总结/03-函数和闭包/03-笔记/index.html","hash":"1d6aea0bc842397c9ce5a9c6828492271f41cf48","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/04-javascript_webapi/05-鼠标事件和event/05-note/index.html","hash":"acaf5a51f09800f9bcdcab7bdaf7222c3747bfea","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/05-javascript高级总结/04-递归和正则/04-笔记/index.html","hash":"c33b9f7031ba6567b3b25a1b71a3e6ef0f4a6816","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/05-javascript高级总结/02-类和继承/02-note/index.html","hash":"f68a92fdb9803d5a6395c6c9fb8f6849a3fecd3a","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/06-jquery总结/03-对象尺寸与位置/03-笔记/index.html","hash":"eced8478f6a2e5d7fbeebed8230ba3fd83aaf2bd","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/07-Ajax总结/01-jq中的ajax/01-ajax笔记/index.html","hash":"7633e7757a2840a8a202b7433626c2dfed6b68d7","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/06-jquery总结/01-方法和事件和类/01-笔记/index.html","hash":"e5640d8bcdf7a55ed064f6470128e8575c9d95f2","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/07-Ajax总结/04-axios和跨域/04-笔记/index.html","hash":"1930231ad105cfce2c3fcb64f948ab28c32c1001","modified":1677664319585},{"_id":"public/2017/02/06/笔记/ocean/06-jquery总结/02-方法和循环/02-笔记/index.html","hash":"011ac5789d3daccd48f0630261d11aca317d17cb","modified":1677664319585},{"_id":"public/2016/08/06/笔记/ocean/01-html总结/01-什么是html/01-笔记/index.html","hash":"e565a7bb9d74e29cbecd3397275f275a28407564","modified":1677664319585},{"_id":"public/2016/08/06/笔记/ocean/01-html总结/02-表格和表单/02-笔记/index.html","hash":"e5dfa32a540001fa4f8eb4066dfd19cffc9f0aa8","modified":1677664319585},{"_id":"public/archives/index.html","hash":"ca94dd51cadc4f70ada83d0604094b801c98ec90","modified":1677664319585},{"_id":"public/archives/page/3/index.html","hash":"e4a32e46d4a94ed96175d445d918085f7e984e03","modified":1677664319585},{"_id":"public/2016/08/06/笔记/ocean/01-html总结/canvas画布/canvas/index.html","hash":"e4702660302ce1be70ee2b101ada3a158a8760f6","modified":1677664319585},{"_id":"public/archives/page/2/index.html","hash":"44f5225964fad0ff28cce99cb39744b45bb26a7d","modified":1677664319585},{"_id":"public/archives/page/4/index.html","hash":"01905958b7d17623d73871b17943744709317291","modified":1677664319585},{"_id":"public/archives/page/5/index.html","hash":"7b510e1d496bd3562c17cb75d84a31c23d4c2b9c","modified":1677664319585},{"_id":"public/archives/page/6/index.html","hash":"6aa82512588c16339a627cd7719a7dd1293d1a5b","modified":1677664319585},{"_id":"public/archives/2016/index.html","hash":"532daf3ecad983fbcd0155eef0e3fdb239235cb3","modified":1677664319585},{"_id":"public/archives/2017/page/2/index.html","hash":"154f9edb306d2477016eb3632248f1e7dfe42966","modified":1677664319585},{"_id":"public/archives/2016/08/index.html","hash":"777588ee5d40d3563f0427db5d29d718190239c3","modified":1677664319585},{"_id":"public/archives/2017/page/3/index.html","hash":"7e38104fe5b8da2aea76b5171b226827756810ae","modified":1677664319585},{"_id":"public/archives/2017/index.html","hash":"5c43f92126f904d8fb6a43b4bc43792a8e571ea6","modified":1677664319585},{"_id":"public/archives/2019/index.html","hash":"d2c4a03b0d26c1a92b47d9dbafdc28639b9c7462","modified":1677664319585},{"_id":"public/archives/2017/02/page/3/index.html","hash":"b8af005a148da28204d6b28614a9ec21e47d14cf","modified":1677664319585},{"_id":"public/archives/2017/02/page/2/index.html","hash":"0cd1fead41d873743482974d5e63a58a5ae25f0f","modified":1677664319585},{"_id":"public/archives/2017/02/index.html","hash":"5f289733397d01e48e7e42075bf7ec2b9bc8ae18","modified":1677664319585},{"_id":"public/archives/2019/05/index.html","hash":"a35ac4bc19faf4007c346f164ed0f2a73026b0e8","modified":1677664319585},{"_id":"public/archives/2020/index.html","hash":"66b3ee74ae9d21a7487051d9cae1998c219169bb","modified":1677664319585},{"_id":"public/archives/2019/04/index.html","hash":"fe1b0eb53668f201105160f5631f460935ed72e3","modified":1677664319585},{"_id":"public/archives/2020/page/2/index.html","hash":"a0803b4a2fb288fd0990c55650bcd028c075ed10","modified":1677664319585},{"_id":"public/archives/2020/09/index.html","hash":"bdc74f9fadd8182a0f7b7384e57f9272e58ce138","modified":1677664319585},{"_id":"public/archives/2020/08/page/2/index.html","hash":"fe3f121d2c9a5457a3284282286009ee066b9c6b","modified":1677664319585},{"_id":"public/archives/2020/08/index.html","hash":"d1316c574d08a72c3b50380aa9171c611faffa05","modified":1677664319585},{"_id":"public/archives/2023/index.html","hash":"36cb9018ec4807a71b70fdc897b51af6abe506ac","modified":1677664319585},{"_id":"public/archives/2023/03/index.html","hash":"763225fdd92dcedb24d5109c3ce36344430f9adf","modified":1677664319585},{"_id":"public/page/2/index.html","hash":"02325de53c3cbc35b7f12fddbe57a9b72b76ea61","modified":1677664319585},{"_id":"public/page/3/index.html","hash":"30cdb020e49ef7274093943d2a3fff65a22134f8","modified":1677664319585},{"_id":"public/page/4/index.html","hash":"3ccb08e3e40643f95c941c235904d7f9bffcf5c8","modified":1677664319585},{"_id":"public/index.html","hash":"a91f8ae9201aaa0f5abb51a19c5c9dd999116bae","modified":1677664319585},{"_id":"public/page/6/index.html","hash":"394f22f1f713ef482538eac22a3f2e92ca70cab5","modified":1677664319585},{"_id":"public/tags/后端/index.html","hash":"7c0cbb295a8bc925f9f1449df4c3f9e9b37a150c","modified":1677664319585},{"_id":"public/page/5/index.html","hash":"b49c02fa99aece22960345f13d875c9b505c81ab","modified":1677664319585},{"_id":"public/tags/git/index.html","hash":"13fd88ceb51ddd4708b8c7e0a500248b949bb999","modified":1677664319585},{"_id":"public/tags/前端/index.html","hash":"2718e76a6c38aa4e3c2ca7c706667144e6adb66b","modified":1677664319585},{"_id":"public/tags/前端/page/2/index.html","hash":"430489368424761715d454d3d82c74a0dfde8a12","modified":1677664319585},{"_id":"public/tags/前端/page/3/index.html","hash":"df67caa6a177732b699419eb6206a60518b60f38","modified":1677664319585},{"_id":"public/tags/前端/page/4/index.html","hash":"cc3a6d120321088a15fe1a957e6584ceb34c77f5","modified":1677664319585},{"_id":"public/tags/前端/page/5/index.html","hash":"aa3ef748deb92f3b8d4126672fafee17c64405c1","modified":1677664319585},{"_id":"public/tags/前端/page/6/index.html","hash":"f4deeb2f6949ddf5fee85e0ad88c207c0bd6b069","modified":1677664319585},{"_id":"public/tags/运维/index.html","hash":"75022ac070eedc943ce8ffa2556ac5786778154c","modified":1677664319585},{"_id":"public/tags/优化/index.html","hash":"2bf00196e29fe71d539bab9500eef1ca5ed45daa","modified":1677664319585},{"_id":"public/tags/vue-admin-element-plus/index.html","hash":"694f855c2a288bbfc8a7446bdab78dc1a6017ccb","modified":1677664319585},{"_id":"public/tags/vue/index.html","hash":"f3e6e496c0a666417b038b962452e154734bd1ae","modified":1677664319585},{"_id":"public/tags/原生js/index.html","hash":"7e2124f21f0b410fe13a362bb6cb0a85d125c136","modified":1677664319585},{"_id":"public/tags/正则/index.html","hash":"fcb56a6b6d39ba6ac88de764d292fe0cdcc0fce9","modified":1677664319585},{"_id":"public/tags/笔记/index.html","hash":"322e38e2833561fd217d7c31d82eaecad17fad5e","modified":1677664319585},{"_id":"public/tags/笔记/page/2/index.html","hash":"90d362f10546a42cc8edff3fb8d93649895db599","modified":1677664319585},{"_id":"public/tags/笔记/page/3/index.html","hash":"7c8f961368a6edf5d78092cdba9c3512347116f6","modified":1677664319585},{"_id":"public/tags/js/index.html","hash":"fbe99fecf98733c53f94641ecdae977399f8b15e","modified":1677664319585},{"_id":"public/tags/js/page/3/index.html","hash":"8bd00f0bc13c3a3408ea5004ae0db1a9320576a4","modified":1677664319585},{"_id":"public/tags/js/page/2/index.html","hash":"83421c1fb1ba3c1a133527566c964680cac96b44","modified":1677664319585},{"_id":"public/tags/javascript/index.html","hash":"d5250ed3b5f09a98d68b792941c0e5c58e5a005a","modified":1677664319585},{"_id":"public/tags/javascript/page/2/index.html","hash":"45c9332c52b2bd7d238f5f26175c62101dae20d7","modified":1677664319585},{"_id":"public/tags/javascript/page/3/index.html","hash":"90bebde47d10d0e7f8726ad7eaed65de10da9e23","modified":1677664319585},{"_id":"public/tags/jquery/index.html","hash":"80e423bc00600a5298091002e1bb9f45f4a39727","modified":1677664319585},{"_id":"public/tags/ajax/index.html","hash":"873cacbadd6bd6c1a8c13264a14f83443c5e87fd","modified":1677664319585},{"_id":"public/tags/node/index.html","hash":"2192df51bc50ce26f8e49789383633aa12679045","modified":1677664319585},{"_id":"public/tags/react/index.html","hash":"87ec27be35ca265b0fbdf1b805632ced83e664e2","modified":1677664319585},{"_id":"public/categories/后端/index.html","hash":"836099ad14aff6d65a3c84803c9ffb60d555e1a6","modified":1677664319585},{"_id":"public/categories/git/index.html","hash":"fb23669565d351a1ce1f871730745b3b2e1f83c0","modified":1677664319585},{"_id":"public/categories/前端/index.html","hash":"faed4e4f2824f1e12a1ef74f89803c6a13580a78","modified":1677664319585},{"_id":"public/categories/运维/index.html","hash":"65f81202f4e497a714b2707f135ffa1521603ffb","modified":1677664319585},{"_id":"public/categories/前端/原生js/index.html","hash":"67257b6b3210fba7fdd4ed6166adcd131ecbf4a0","modified":1677664319585},{"_id":"public/categories/笔记/page/3/index.html","hash":"e50bc99eb0294741db13ff84794f14d60b5987c4","modified":1677664319585},{"_id":"public/categories/笔记/page/2/index.html","hash":"21f65f754515b7913589233dff8a06a430ea94de","modified":1677664319585},{"_id":"public/categories/笔记/index.html","hash":"9e4a66e956d027ecb52264c87640b070fa1bc48b","modified":1677664319585},{"_id":"public/categories/笔记/page/4/index.html","hash":"251e4b8655c6b55f1e809e784086c596b269da7f","modified":1677664319585},{"_id":"public/categories/笔记/page/5/index.html","hash":"2b66ca02244c782518ab431f3932a18c0e4a2447","modified":1677664319585},{"_id":"public/categories/前端/vue/index.html","hash":"1b61fdf6adb9f3d8ebab2068febae6075158b80f","modified":1677664319585},{"_id":"public/categories/笔记/零碎/index.html","hash":"bd1e9c80c8bda1963c1f79ba7f3220cfe0423484","modified":1677664319585},{"_id":"public/categories/笔记/零碎/page/2/index.html","hash":"2e226187e30b1b5681852ae9a931002175f98b41","modified":1677664319585},{"_id":"public/categories/笔记/零碎/page/3/index.html","hash":"191c08fbb4202b67be8aed3cdeb1b23b20020649","modified":1677664319585},{"_id":"public/categories/笔记/零碎/page/4/index.html","hash":"5bc594cee1a517713de6c5223dfd4947ede0dff1","modified":1677664319585},{"_id":"public/categories/笔记/正则/index.html","hash":"4882663ded32bbfc41374b326e5297dff3769ff6","modified":1677664319585},{"_id":"public/categories/笔记/node/index.html","hash":"67f2abf5f1227891b60cfee93b9d279fb5c8786d","modified":1677664319585},{"_id":"public/img/avatar.jpg","hash":"9e88426164e4f75cfadc3a366d50cbc374822a01","modified":1677664319585},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1677664319585},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1677664319585},{"_id":"public/img/alipay.png","hash":"5b94c900cd77c941f8c99c36a094a6f29d890408","modified":1677664319585},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1677664319585},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1677664319585},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1677664319585},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1677664319585},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1677664319585},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1677664319585},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1677664319585},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1677664319585},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1677664319585},{"_id":"public/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1677664319585},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1677664319585},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1677664319585},{"_id":"public/js/search.js","hash":"ffc0f18363e0648b1e0a10e0db03c4c96121cfce","modified":1677664319585},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1677664319585},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1677664319585},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1677664319585},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1677664319585},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1677664319585},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1677664319585},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1677664319585},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1677664319585},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1677664319585},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1677664319585},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1677664319585},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1677664319585},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1677664319585},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1677664319585},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1677664319585},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1677664319585},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1677664319585},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1677664319585},{"_id":"public/css/style.css","hash":"12b53ffede4c7805869f7651357f97b0ab6b4f20","modified":1677664319585},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1677664319585},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1677664319585},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1677664319585},{"_id":"public/js/script.js","hash":"60a40ff5a16652a8ae49b878aa380400cb84f2c6","modified":1677664319585},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1677664319585},{"_id":"public/img/weixin.png","hash":"9e00b08337763ae91841d66d3a3cc0d974ca5f95","modified":1677664319585},{"_id":"public/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1677664319585}],"Category":[{"name":"后端","_id":"clepi0qbr0003awaf3itef8cv"},{"name":"git","_id":"clepi0qbx0008awaf3olf189k"},{"name":"前端","_id":"clepi0qc3000jawafdpcl1w3u"},{"name":"运维","_id":"clepi0qc5000qawaf4m7qdl3x"},{"name":"原生js","parent":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qcf001hawafdv655ehs"},{"name":"笔记","_id":"clepi0qcm0020awaf5nb15d3p"},{"name":"vue","parent":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qcr002jawaf9kida4hy"},{"name":"零碎","parent":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qd6004hawaf41tlerki"},{"name":"正则","parent":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qd7004mawafccvued35"},{"name":"node","parent":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qe600aeawafdxwh4ljd"}],"Data":[],"Page":[{"title":"about","date":"2023-03-01T03:01:17.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-03-01 11:01:17\n---\n","updated":"2023-03-01T03:01:17.737Z","path":"about/index.html","comments":1,"layout":"page","_id":"clepi0qbj0000awaf5b903zqb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"demo","date":"2023-03-01T08:01:35.819Z","_content":"","source":"_posts/后端/demo.md","raw":"---\ntitle: demo\ndate: {{date}}\ncategories:\n- 后端\ntags:\n- 后端\n---","slug":"后端/demo","published":1,"updated":"2023-03-01T08:08:56.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbl0001awaf7r39568q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"git本地操作命令","date":"2020-09-06T08:21:43.000Z","_content":"\n# git\n\n## 介绍\n\n+ git是最先进的分布式版本工具。\n\n## 版本工具的演进\n\n+ 本地模式\n+ 集中模式 svn\n  + 使用单一的文件服务器，可从中提取，提交，更新，集中模式\n+ 分布式 git\n\n### 版本控制\n\n功能：可以追踪文件的变更，谁在那个时间段更改了它，改了什么内容，文件的版本号，都会记录下来，从而可以回滚到历史版本和之前的状态。\n\n集中化版本控制：有一个单一的服务器用来保存文件，可多人协作进行修改，提取。\n\n分布式版本控制：客户端不单单只是提取最新版本了，而是将仓库的代码完整的镜像下来，这样一来，即使任何一个协同工作的服务器或客户端发生故障，都可以用任何一个客户端的镜像仓库恢复。\n\n## git使用前配置\n\n使用git之前配置用户信息，为了更好的管理，提交代码是会用到这些信息\n\n```js\ngit config --global user.name \"Zhang\" 设置用户名\ngit config --global user.email \"email\" 设置邮箱\n\ngit config --list //显示用户配置等\nclear //清屏\n```\n\n## 初次使用\n\n```js\ngit init \t创建git仓库，用来存储\ngit add xxx.html  //将指定文件添加到暂存区中\ngit add . \t//将所有文件添加到暂存区\ngit ls-flies //查看暂存区文件\n\ngit commit -m '描述这次做了什么功能'\t//提交代码的备注\ngit commit --no-verify -m \"提交备注\"   就可以跳过代码检查\n\ngit status   //查看所有文件的状态。\ngit log \t//查看历史版本\ngit log --oneline //只看备注\n```\n\n```js\n创建一个.gitignore文件，将文件名写在里面以后，将不再受git管理\n```\n\n\n\n\n\n## 核心概念\n\n### 原理概念\n\n+ 工作目录\n\n  + 就是写代码的地方，新创建的文件都会在这里\n\n+ 暂存区\n\n  + 当git add . 时，就会添加到暂存区\n\n+ 本地仓库\n\n  + 当git commit -m '' 提交后，就会真正的存入本地仓库\n\n  \n\n+ 为什么不直接放入本地仓库\n\n  + 当代码量完成一半时，通过add添加到暂存区，当误删代码时，可以从暂存区恢复代码。\n\n### 文件状态\n\n1. 暂存区中的文件状态\n\n   ```js\n   new file:index.js  //表示新文件\n   \n   delect:index.js\t//已删除的文件\n   \n   modified：index.js //已修改的文件\n   \n   Unmerged paths: index.js//因包含冲突未被合并的文件\n   \n   \n   \n   \n   Changes tobe committed：  //已经存入暂存区，提交到本地仓库时这些代码将会存入本地仓库\n   \n   Changesnot staged for commit // 以下文件未存入暂存区，如果提交未使用 -a参数的话，则不会提交到本地仓库\n   \n   Untracked files // 未跟踪文件，未存入暂存区，不可使用-a参数使用\n   ```\n\n+ 未跟踪（Untracked），新文件 \n+ 已暂存，在暂存区的文件\n+ 已修改，暂存区的代码被修改（代码在工作目录）\n+ 已提交，本地仓库中的文件\n\n\n\n## 操作流程化\n\n+ 添加到暂存区\n\n```js\ngit add 文件1 文件2  //多个文件提交\ngit add * //添加所有文件到暂存区，但是排除以.开头的文件\ngit add *.js  //将后辍为.js的文件添加到暂存区\n```\n\n+ 提交\n\n```js\ngit commit //不添加-m，会弹出编辑框强制添加备注\n\ngit commit --no-verify -m \"commit\" //跳过代码检查\n```\n\n+ 除了新建的文件，原本就存在的文件修改后再次提交可直接使用commit存入本地\n\n```js\ngit commit -a -m \"备注\"\n//a是all的缩写，m是 message 的缩写\n```\n\n### 逆向操作\n\n```js\ngit commit --amend //修改最后一次提交的备注\n\nrestore 命令，默认是带着 --worktree 参数的\n\ngit restore --worktree  文件名\n// 简写-w,将已修改没有暂存的指定文件返回修改之前。\n\ngit restore --staged 文件名  \n//作用是将 暂存区的文件从暂存区撤出，但不会更改文件。\n\n$ git restore -s id  文件名\n//作用是将指定的文件，回退到指定的版本快照中\n\n\n\n\ngit rm -rf *\n//删除所有文件\n\ngit rm --cached 文件名 \n//将暂存区的文件删除后，当回滚版本时，它不会存在。\n\ngit rm -f 文件名 //将文件从暂存区移到工作目录并删除文件，对未跟踪的文件不能使用\n```\n\n+ 撤销代码修改\n\n原理是相当于把工作目录删除后，将缓存区的文件移入工作目录\n\n```js\ngit checkout //在未使用add添加到暂存中时，撤销所有的修改，且永久无法找回，慎重操作\n```\n\n+ 版本回滚\n\n```js\ngit reset --hard 历史编号 //回滚到指定历史编号的版本\n\ngit reset --hard HEAD  //将本地仓库的代码覆盖掉工作目录和暂存区，最后提交的版本叫HEAD\n```\n\n\n\n\n\n## git的贮藏与清理\n\n- `适用场景：当a开发者在工作一段时间后，现在所有的东西都进入混乱状态,此时想要切换到另一个分支做其他事情，但又不想因为已经做了一半的工作创建一次提交。\n\n- 解决:\n\n  ```js\n  git stash 或 git stash push //将新的贮藏推送到栈上，推送后工作树为空\n  \n  git stash list //查看被贮藏的文件\n  \n  git stash apply //将最新的贮藏工作重新应用\n  \n  git stash apply stash@{2} //将指定的贮藏重新应用\n  \n  git stash apply --index //加上--index后，可将之前暂存的文件重新应用暂存。\n  \n  git stash drop stash2{0} //移除指定的贮藏\n  \n  git stash pop //应用贮藏后立即从栈上移除\n  \n   git stash --all //来移除每一样东西并存放在栈中，包括未跟踪文件\n  ```\n\n  ```js\n  `扩展`\n  git stash --keep-index //不仅将已暂存的文件贮藏在栈，还要保留已暂存的内容和索引中\n  \n  `默认情况下git stash只会贮藏已暂存和已跟踪文件。`\n  git status --include-untracked  //会贮藏任何未跟踪文件，但不包括明确忽略文件，简写-u。包含所有文件使用-a\n  \n  `不贮藏所有修改过的文件`\n  git stash --patch \n  \n  `当贮藏了文件a,然后还在贮藏的分支上修改a,在将a重新应用工作时可能会出现合并冲突`\n  git stash branch 分支名称 //将贮藏工作，重新应用在分支工作\n  ```\n\n  \n\n## 单词\n\n```js\n//git命令---------------\nglobal //全局\ninit //初始化\ncommit\t//提交\noneline //一行\namend  //修改\nrestore //恢复\nstaged \t//已暂存\ncached\t//缓存\nmessage //信息\ncheckout //检出\n```\n\n\n\n## \n\n## 问题\n\n1. git restore --staged 和 git rm --cached的区别？\n\n+ git restore --staged 是将文件撤销到工作目录中，暂存区中还有保留，工作目录也会保留，但是当commit提交到本地仓库中时不会将此文件提交，当版本回滚时此文件会受到回滚的控制\n\n+ git rm --cached 是将文件彻底从暂存区删除，本地工作目录也还会保留，当commit提交到本地仓库时，不会将此文件提交，但是当回滚版本时，此文件不会回滚回来\n\n+ 总结：git restore 是撤销操作。\n\n  ​\t    git rm --cached是删除操作。\n\n  \n\n2. 暂存区已经将文件__add存入__，此时在工作目录中__修改文件__，___再次add___，是否会__覆盖__掉暂存区的文件？\n   \n+ 会覆盖\n  \n3. 当文件commit提交到本地仓库中后，是否还可执行git restore 和git rm --cached操作\n   + 不可\n\n   \n\n   \n","source":"_posts/git/01-git本地仓库操作.md","raw":"---\ntitle: git本地操作命令\ndate: 2020-09-06 16:21:43\ncategories:\n- git\ntags:\n- git\n---\n\n# git\n\n## 介绍\n\n+ git是最先进的分布式版本工具。\n\n## 版本工具的演进\n\n+ 本地模式\n+ 集中模式 svn\n  + 使用单一的文件服务器，可从中提取，提交，更新，集中模式\n+ 分布式 git\n\n### 版本控制\n\n功能：可以追踪文件的变更，谁在那个时间段更改了它，改了什么内容，文件的版本号，都会记录下来，从而可以回滚到历史版本和之前的状态。\n\n集中化版本控制：有一个单一的服务器用来保存文件，可多人协作进行修改，提取。\n\n分布式版本控制：客户端不单单只是提取最新版本了，而是将仓库的代码完整的镜像下来，这样一来，即使任何一个协同工作的服务器或客户端发生故障，都可以用任何一个客户端的镜像仓库恢复。\n\n## git使用前配置\n\n使用git之前配置用户信息，为了更好的管理，提交代码是会用到这些信息\n\n```js\ngit config --global user.name \"Zhang\" 设置用户名\ngit config --global user.email \"email\" 设置邮箱\n\ngit config --list //显示用户配置等\nclear //清屏\n```\n\n## 初次使用\n\n```js\ngit init \t创建git仓库，用来存储\ngit add xxx.html  //将指定文件添加到暂存区中\ngit add . \t//将所有文件添加到暂存区\ngit ls-flies //查看暂存区文件\n\ngit commit -m '描述这次做了什么功能'\t//提交代码的备注\ngit commit --no-verify -m \"提交备注\"   就可以跳过代码检查\n\ngit status   //查看所有文件的状态。\ngit log \t//查看历史版本\ngit log --oneline //只看备注\n```\n\n```js\n创建一个.gitignore文件，将文件名写在里面以后，将不再受git管理\n```\n\n\n\n\n\n## 核心概念\n\n### 原理概念\n\n+ 工作目录\n\n  + 就是写代码的地方，新创建的文件都会在这里\n\n+ 暂存区\n\n  + 当git add . 时，就会添加到暂存区\n\n+ 本地仓库\n\n  + 当git commit -m '' 提交后，就会真正的存入本地仓库\n\n  \n\n+ 为什么不直接放入本地仓库\n\n  + 当代码量完成一半时，通过add添加到暂存区，当误删代码时，可以从暂存区恢复代码。\n\n### 文件状态\n\n1. 暂存区中的文件状态\n\n   ```js\n   new file:index.js  //表示新文件\n   \n   delect:index.js\t//已删除的文件\n   \n   modified：index.js //已修改的文件\n   \n   Unmerged paths: index.js//因包含冲突未被合并的文件\n   \n   \n   \n   \n   Changes tobe committed：  //已经存入暂存区，提交到本地仓库时这些代码将会存入本地仓库\n   \n   Changesnot staged for commit // 以下文件未存入暂存区，如果提交未使用 -a参数的话，则不会提交到本地仓库\n   \n   Untracked files // 未跟踪文件，未存入暂存区，不可使用-a参数使用\n   ```\n\n+ 未跟踪（Untracked），新文件 \n+ 已暂存，在暂存区的文件\n+ 已修改，暂存区的代码被修改（代码在工作目录）\n+ 已提交，本地仓库中的文件\n\n\n\n## 操作流程化\n\n+ 添加到暂存区\n\n```js\ngit add 文件1 文件2  //多个文件提交\ngit add * //添加所有文件到暂存区，但是排除以.开头的文件\ngit add *.js  //将后辍为.js的文件添加到暂存区\n```\n\n+ 提交\n\n```js\ngit commit //不添加-m，会弹出编辑框强制添加备注\n\ngit commit --no-verify -m \"commit\" //跳过代码检查\n```\n\n+ 除了新建的文件，原本就存在的文件修改后再次提交可直接使用commit存入本地\n\n```js\ngit commit -a -m \"备注\"\n//a是all的缩写，m是 message 的缩写\n```\n\n### 逆向操作\n\n```js\ngit commit --amend //修改最后一次提交的备注\n\nrestore 命令，默认是带着 --worktree 参数的\n\ngit restore --worktree  文件名\n// 简写-w,将已修改没有暂存的指定文件返回修改之前。\n\ngit restore --staged 文件名  \n//作用是将 暂存区的文件从暂存区撤出，但不会更改文件。\n\n$ git restore -s id  文件名\n//作用是将指定的文件，回退到指定的版本快照中\n\n\n\n\ngit rm -rf *\n//删除所有文件\n\ngit rm --cached 文件名 \n//将暂存区的文件删除后，当回滚版本时，它不会存在。\n\ngit rm -f 文件名 //将文件从暂存区移到工作目录并删除文件，对未跟踪的文件不能使用\n```\n\n+ 撤销代码修改\n\n原理是相当于把工作目录删除后，将缓存区的文件移入工作目录\n\n```js\ngit checkout //在未使用add添加到暂存中时，撤销所有的修改，且永久无法找回，慎重操作\n```\n\n+ 版本回滚\n\n```js\ngit reset --hard 历史编号 //回滚到指定历史编号的版本\n\ngit reset --hard HEAD  //将本地仓库的代码覆盖掉工作目录和暂存区，最后提交的版本叫HEAD\n```\n\n\n\n\n\n## git的贮藏与清理\n\n- `适用场景：当a开发者在工作一段时间后，现在所有的东西都进入混乱状态,此时想要切换到另一个分支做其他事情，但又不想因为已经做了一半的工作创建一次提交。\n\n- 解决:\n\n  ```js\n  git stash 或 git stash push //将新的贮藏推送到栈上，推送后工作树为空\n  \n  git stash list //查看被贮藏的文件\n  \n  git stash apply //将最新的贮藏工作重新应用\n  \n  git stash apply stash@{2} //将指定的贮藏重新应用\n  \n  git stash apply --index //加上--index后，可将之前暂存的文件重新应用暂存。\n  \n  git stash drop stash2{0} //移除指定的贮藏\n  \n  git stash pop //应用贮藏后立即从栈上移除\n  \n   git stash --all //来移除每一样东西并存放在栈中，包括未跟踪文件\n  ```\n\n  ```js\n  `扩展`\n  git stash --keep-index //不仅将已暂存的文件贮藏在栈，还要保留已暂存的内容和索引中\n  \n  `默认情况下git stash只会贮藏已暂存和已跟踪文件。`\n  git status --include-untracked  //会贮藏任何未跟踪文件，但不包括明确忽略文件，简写-u。包含所有文件使用-a\n  \n  `不贮藏所有修改过的文件`\n  git stash --patch \n  \n  `当贮藏了文件a,然后还在贮藏的分支上修改a,在将a重新应用工作时可能会出现合并冲突`\n  git stash branch 分支名称 //将贮藏工作，重新应用在分支工作\n  ```\n\n  \n\n## 单词\n\n```js\n//git命令---------------\nglobal //全局\ninit //初始化\ncommit\t//提交\noneline //一行\namend  //修改\nrestore //恢复\nstaged \t//已暂存\ncached\t//缓存\nmessage //信息\ncheckout //检出\n```\n\n\n\n## \n\n## 问题\n\n1. git restore --staged 和 git rm --cached的区别？\n\n+ git restore --staged 是将文件撤销到工作目录中，暂存区中还有保留，工作目录也会保留，但是当commit提交到本地仓库中时不会将此文件提交，当版本回滚时此文件会受到回滚的控制\n\n+ git rm --cached 是将文件彻底从暂存区删除，本地工作目录也还会保留，当commit提交到本地仓库时，不会将此文件提交，但是当回滚版本时，此文件不会回滚回来\n\n+ 总结：git restore 是撤销操作。\n\n  ​\t    git rm --cached是删除操作。\n\n  \n\n2. 暂存区已经将文件__add存入__，此时在工作目录中__修改文件__，___再次add___，是否会__覆盖__掉暂存区的文件？\n   \n+ 会覆盖\n  \n3. 当文件commit提交到本地仓库中后，是否还可执行git restore 和git rm --cached操作\n   + 不可\n\n   \n\n   \n","slug":"git/01-git本地仓库操作","published":1,"updated":"2023-03-01T07:03:37.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbo0002awaf04uf21qu","content":"<h1 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>git是最先进的分布式版本工具。</li>\n</ul>\n<h2 id=\"版本工具的演进\"><a href=\"#版本工具的演进\" class=\"headerlink\" title=\"版本工具的演进\"></a>版本工具的演进</h2><ul>\n<li>本地模式</li>\n<li>集中模式 svn<ul>\n<li>使用单一的文件服务器，可从中提取，提交，更新，集中模式</li>\n</ul>\n</li>\n<li>分布式 git</li>\n</ul>\n<h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><p>功能：可以追踪文件的变更，谁在那个时间段更改了它，改了什么内容，文件的版本号，都会记录下来，从而可以回滚到历史版本和之前的状态。</p>\n<p>集中化版本控制：有一个单一的服务器用来保存文件，可多人协作进行修改，提取。</p>\n<p>分布式版本控制：客户端不单单只是提取最新版本了，而是将仓库的代码完整的镜像下来，这样一来，即使任何一个协同工作的服务器或客户端发生故障，都可以用任何一个客户端的镜像仓库恢复。</p>\n<h2 id=\"git使用前配置\"><a href=\"#git使用前配置\" class=\"headerlink\" title=\"git使用前配置\"></a>git使用前配置</h2><p>使用git之前配置用户信息，为了更好的管理，提交代码是会用到这些信息</p>\n<pre><code class=\"js\">git config --global user.name &quot;Zhang&quot; 设置用户名\ngit config --global user.email &quot;email&quot; 设置邮箱\n\ngit config --list //显示用户配置等\nclear //清屏\n</code></pre>\n<h2 id=\"初次使用\"><a href=\"#初次使用\" class=\"headerlink\" title=\"初次使用\"></a>初次使用</h2><pre><code class=\"js\">git init     创建git仓库，用来存储\ngit add xxx.html  //将指定文件添加到暂存区中\ngit add .     //将所有文件添加到暂存区\ngit ls-flies //查看暂存区文件\n\ngit commit -m &#39;描述这次做了什么功能&#39;    //提交代码的备注\ngit commit --no-verify -m &quot;提交备注&quot;   就可以跳过代码检查\n\ngit status   //查看所有文件的状态。\ngit log     //查看历史版本\ngit log --oneline //只看备注\n</code></pre>\n<pre><code class=\"js\">创建一个.gitignore文件，将文件名写在里面以后，将不再受git管理\n</code></pre>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"原理概念\"><a href=\"#原理概念\" class=\"headerlink\" title=\"原理概念\"></a>原理概念</h3><ul>\n<li><p>工作目录</p>\n<ul>\n<li>就是写代码的地方，新创建的文件都会在这里</li>\n</ul>\n</li>\n<li><p>暂存区</p>\n<ul>\n<li>当git add . 时，就会添加到暂存区</li>\n</ul>\n</li>\n<li><p>本地仓库</p>\n<ul>\n<li>当git commit -m ‘’ 提交后，就会真正的存入本地仓库</li>\n</ul>\n</li>\n<li><p>为什么不直接放入本地仓库</p>\n<ul>\n<li>当代码量完成一半时，通过add添加到暂存区，当误删代码时，可以从暂存区恢复代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件状态\"><a href=\"#文件状态\" class=\"headerlink\" title=\"文件状态\"></a>文件状态</h3><ol>\n<li><p>暂存区中的文件状态</p>\n<pre><code class=\"js\">new file:index.js  //表示新文件\n\ndelect:index.js    //已删除的文件\n\nmodified：index.js //已修改的文件\n\nUnmerged paths: index.js//因包含冲突未被合并的文件\n\n\n\n\nChanges tobe committed：  //已经存入暂存区，提交到本地仓库时这些代码将会存入本地仓库\n\nChangesnot staged for commit // 以下文件未存入暂存区，如果提交未使用 -a参数的话，则不会提交到本地仓库\n\nUntracked files // 未跟踪文件，未存入暂存区，不可使用-a参数使用\n</code></pre>\n</li>\n</ol>\n<ul>\n<li>未跟踪（Untracked），新文件 </li>\n<li>已暂存，在暂存区的文件</li>\n<li>已修改，暂存区的代码被修改（代码在工作目录）</li>\n<li>已提交，本地仓库中的文件</li>\n</ul>\n<h2 id=\"操作流程化\"><a href=\"#操作流程化\" class=\"headerlink\" title=\"操作流程化\"></a>操作流程化</h2><ul>\n<li>添加到暂存区</li>\n</ul>\n<pre><code class=\"js\">git add 文件1 文件2  //多个文件提交\ngit add * //添加所有文件到暂存区，但是排除以.开头的文件\ngit add *.js  //将后辍为.js的文件添加到暂存区\n</code></pre>\n<ul>\n<li>提交</li>\n</ul>\n<pre><code class=\"js\">git commit //不添加-m，会弹出编辑框强制添加备注\n\ngit commit --no-verify -m &quot;commit&quot; //跳过代码检查\n</code></pre>\n<ul>\n<li>除了新建的文件，原本就存在的文件修改后再次提交可直接使用commit存入本地</li>\n</ul>\n<pre><code class=\"js\">git commit -a -m &quot;备注&quot;\n//a是all的缩写，m是 message 的缩写\n</code></pre>\n<h3 id=\"逆向操作\"><a href=\"#逆向操作\" class=\"headerlink\" title=\"逆向操作\"></a>逆向操作</h3><pre><code class=\"js\">git commit --amend //修改最后一次提交的备注\n\nrestore 命令，默认是带着 --worktree 参数的\n\ngit restore --worktree  文件名\n// 简写-w,将已修改没有暂存的指定文件返回修改之前。\n\ngit restore --staged 文件名  \n//作用是将 暂存区的文件从暂存区撤出，但不会更改文件。\n\n$ git restore -s id  文件名\n//作用是将指定的文件，回退到指定的版本快照中\n\n\n\n\ngit rm -rf *\n//删除所有文件\n\ngit rm --cached 文件名 \n//将暂存区的文件删除后，当回滚版本时，它不会存在。\n\ngit rm -f 文件名 //将文件从暂存区移到工作目录并删除文件，对未跟踪的文件不能使用\n</code></pre>\n<ul>\n<li>撤销代码修改</li>\n</ul>\n<p>原理是相当于把工作目录删除后，将缓存区的文件移入工作目录</p>\n<pre><code class=\"js\">git checkout //在未使用add添加到暂存中时，撤销所有的修改，且永久无法找回，慎重操作\n</code></pre>\n<ul>\n<li>版本回滚</li>\n</ul>\n<pre><code class=\"js\">git reset --hard 历史编号 //回滚到指定历史编号的版本\n\ngit reset --hard HEAD  //将本地仓库的代码覆盖掉工作目录和暂存区，最后提交的版本叫HEAD\n</code></pre>\n<h2 id=\"git的贮藏与清理\"><a href=\"#git的贮藏与清理\" class=\"headerlink\" title=\"git的贮藏与清理\"></a>git的贮藏与清理</h2><ul>\n<li><p>`适用场景：当a开发者在工作一段时间后，现在所有的东西都进入混乱状态,此时想要切换到另一个分支做其他事情，但又不想因为已经做了一半的工作创建一次提交。</p>\n</li>\n<li><p>解决:</p>\n<pre><code class=\"js\">git stash 或 git stash push //将新的贮藏推送到栈上，推送后工作树为空\n\ngit stash list //查看被贮藏的文件\n\ngit stash apply //将最新的贮藏工作重新应用\n\ngit stash apply stash@&#123;2&#125; //将指定的贮藏重新应用\n\ngit stash apply --index //加上--index后，可将之前暂存的文件重新应用暂存。\n\ngit stash drop stash2&#123;0&#125; //移除指定的贮藏\n\ngit stash pop //应用贮藏后立即从栈上移除\n\n git stash --all //来移除每一样东西并存放在栈中，包括未跟踪文件\n</code></pre>\n<pre><code class=\"js\">`扩展`\ngit stash --keep-index //不仅将已暂存的文件贮藏在栈，还要保留已暂存的内容和索引中\n\n`默认情况下git stash只会贮藏已暂存和已跟踪文件。`\ngit status --include-untracked  //会贮藏任何未跟踪文件，但不包括明确忽略文件，简写-u。包含所有文件使用-a\n\n`不贮藏所有修改过的文件`\ngit stash --patch \n\n`当贮藏了文件a,然后还在贮藏的分支上修改a,在将a重新应用工作时可能会出现合并冲突`\ngit stash branch 分支名称 //将贮藏工作，重新应用在分支工作\n</code></pre>\n</li>\n</ul>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">//git命令---------------\nglobal //全局\ninit //初始化\ncommit    //提交\noneline //一行\namend  //修改\nrestore //恢复\nstaged     //已暂存\ncached    //缓存\nmessage //信息\ncheckout //检出\n</code></pre>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>git restore –staged 和 git rm –cached的区别？</li>\n</ol>\n<ul>\n<li><p>git restore –staged 是将文件撤销到工作目录中，暂存区中还有保留，工作目录也会保留，但是当commit提交到本地仓库中时不会将此文件提交，当版本回滚时此文件会受到回滚的控制</p>\n</li>\n<li><p>git rm –cached 是将文件彻底从暂存区删除，本地工作目录也还会保留，当commit提交到本地仓库时，不会将此文件提交，但是当回滚版本时，此文件不会回滚回来</p>\n</li>\n<li><p>总结：git restore 是撤销操作。</p>\n<p>​        git rm –cached是删除操作。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>暂存区已经将文件__add存入__，此时在工作目录中__修改文件__，___再次add___，是否会__覆盖__掉暂存区的文件？</li>\n</ol>\n<ul>\n<li>会覆盖</li>\n</ul>\n<ol start=\"3\">\n<li>当文件commit提交到本地仓库中后，是否还可执行git restore 和git rm –cached操作<ul>\n<li>不可</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>git是最先进的分布式版本工具。</li>\n</ul>\n<h2 id=\"版本工具的演进\"><a href=\"#版本工具的演进\" class=\"headerlink\" title=\"版本工具的演进\"></a>版本工具的演进</h2><ul>\n<li>本地模式</li>\n<li>集中模式 svn<ul>\n<li>使用单一的文件服务器，可从中提取，提交，更新，集中模式</li>\n</ul>\n</li>\n<li>分布式 git</li>\n</ul>\n<h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><p>功能：可以追踪文件的变更，谁在那个时间段更改了它，改了什么内容，文件的版本号，都会记录下来，从而可以回滚到历史版本和之前的状态。</p>\n<p>集中化版本控制：有一个单一的服务器用来保存文件，可多人协作进行修改，提取。</p>\n<p>分布式版本控制：客户端不单单只是提取最新版本了，而是将仓库的代码完整的镜像下来，这样一来，即使任何一个协同工作的服务器或客户端发生故障，都可以用任何一个客户端的镜像仓库恢复。</p>\n<h2 id=\"git使用前配置\"><a href=\"#git使用前配置\" class=\"headerlink\" title=\"git使用前配置\"></a>git使用前配置</h2><p>使用git之前配置用户信息，为了更好的管理，提交代码是会用到这些信息</p>\n<pre><code class=\"js\">git config --global user.name &quot;Zhang&quot; 设置用户名\ngit config --global user.email &quot;email&quot; 设置邮箱\n\ngit config --list //显示用户配置等\nclear //清屏\n</code></pre>\n<h2 id=\"初次使用\"><a href=\"#初次使用\" class=\"headerlink\" title=\"初次使用\"></a>初次使用</h2><pre><code class=\"js\">git init     创建git仓库，用来存储\ngit add xxx.html  //将指定文件添加到暂存区中\ngit add .     //将所有文件添加到暂存区\ngit ls-flies //查看暂存区文件\n\ngit commit -m &#39;描述这次做了什么功能&#39;    //提交代码的备注\ngit commit --no-verify -m &quot;提交备注&quot;   就可以跳过代码检查\n\ngit status   //查看所有文件的状态。\ngit log     //查看历史版本\ngit log --oneline //只看备注\n</code></pre>\n<pre><code class=\"js\">创建一个.gitignore文件，将文件名写在里面以后，将不再受git管理\n</code></pre>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"原理概念\"><a href=\"#原理概念\" class=\"headerlink\" title=\"原理概念\"></a>原理概念</h3><ul>\n<li><p>工作目录</p>\n<ul>\n<li>就是写代码的地方，新创建的文件都会在这里</li>\n</ul>\n</li>\n<li><p>暂存区</p>\n<ul>\n<li>当git add . 时，就会添加到暂存区</li>\n</ul>\n</li>\n<li><p>本地仓库</p>\n<ul>\n<li>当git commit -m ‘’ 提交后，就会真正的存入本地仓库</li>\n</ul>\n</li>\n<li><p>为什么不直接放入本地仓库</p>\n<ul>\n<li>当代码量完成一半时，通过add添加到暂存区，当误删代码时，可以从暂存区恢复代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件状态\"><a href=\"#文件状态\" class=\"headerlink\" title=\"文件状态\"></a>文件状态</h3><ol>\n<li><p>暂存区中的文件状态</p>\n<pre><code class=\"js\">new file:index.js  //表示新文件\n\ndelect:index.js    //已删除的文件\n\nmodified：index.js //已修改的文件\n\nUnmerged paths: index.js//因包含冲突未被合并的文件\n\n\n\n\nChanges tobe committed：  //已经存入暂存区，提交到本地仓库时这些代码将会存入本地仓库\n\nChangesnot staged for commit // 以下文件未存入暂存区，如果提交未使用 -a参数的话，则不会提交到本地仓库\n\nUntracked files // 未跟踪文件，未存入暂存区，不可使用-a参数使用\n</code></pre>\n</li>\n</ol>\n<ul>\n<li>未跟踪（Untracked），新文件 </li>\n<li>已暂存，在暂存区的文件</li>\n<li>已修改，暂存区的代码被修改（代码在工作目录）</li>\n<li>已提交，本地仓库中的文件</li>\n</ul>\n<h2 id=\"操作流程化\"><a href=\"#操作流程化\" class=\"headerlink\" title=\"操作流程化\"></a>操作流程化</h2><ul>\n<li>添加到暂存区</li>\n</ul>\n<pre><code class=\"js\">git add 文件1 文件2  //多个文件提交\ngit add * //添加所有文件到暂存区，但是排除以.开头的文件\ngit add *.js  //将后辍为.js的文件添加到暂存区\n</code></pre>\n<ul>\n<li>提交</li>\n</ul>\n<pre><code class=\"js\">git commit //不添加-m，会弹出编辑框强制添加备注\n\ngit commit --no-verify -m &quot;commit&quot; //跳过代码检查\n</code></pre>\n<ul>\n<li>除了新建的文件，原本就存在的文件修改后再次提交可直接使用commit存入本地</li>\n</ul>\n<pre><code class=\"js\">git commit -a -m &quot;备注&quot;\n//a是all的缩写，m是 message 的缩写\n</code></pre>\n<h3 id=\"逆向操作\"><a href=\"#逆向操作\" class=\"headerlink\" title=\"逆向操作\"></a>逆向操作</h3><pre><code class=\"js\">git commit --amend //修改最后一次提交的备注\n\nrestore 命令，默认是带着 --worktree 参数的\n\ngit restore --worktree  文件名\n// 简写-w,将已修改没有暂存的指定文件返回修改之前。\n\ngit restore --staged 文件名  \n//作用是将 暂存区的文件从暂存区撤出，但不会更改文件。\n\n$ git restore -s id  文件名\n//作用是将指定的文件，回退到指定的版本快照中\n\n\n\n\ngit rm -rf *\n//删除所有文件\n\ngit rm --cached 文件名 \n//将暂存区的文件删除后，当回滚版本时，它不会存在。\n\ngit rm -f 文件名 //将文件从暂存区移到工作目录并删除文件，对未跟踪的文件不能使用\n</code></pre>\n<ul>\n<li>撤销代码修改</li>\n</ul>\n<p>原理是相当于把工作目录删除后，将缓存区的文件移入工作目录</p>\n<pre><code class=\"js\">git checkout //在未使用add添加到暂存中时，撤销所有的修改，且永久无法找回，慎重操作\n</code></pre>\n<ul>\n<li>版本回滚</li>\n</ul>\n<pre><code class=\"js\">git reset --hard 历史编号 //回滚到指定历史编号的版本\n\ngit reset --hard HEAD  //将本地仓库的代码覆盖掉工作目录和暂存区，最后提交的版本叫HEAD\n</code></pre>\n<h2 id=\"git的贮藏与清理\"><a href=\"#git的贮藏与清理\" class=\"headerlink\" title=\"git的贮藏与清理\"></a>git的贮藏与清理</h2><ul>\n<li><p>`适用场景：当a开发者在工作一段时间后，现在所有的东西都进入混乱状态,此时想要切换到另一个分支做其他事情，但又不想因为已经做了一半的工作创建一次提交。</p>\n</li>\n<li><p>解决:</p>\n<pre><code class=\"js\">git stash 或 git stash push //将新的贮藏推送到栈上，推送后工作树为空\n\ngit stash list //查看被贮藏的文件\n\ngit stash apply //将最新的贮藏工作重新应用\n\ngit stash apply stash@&#123;2&#125; //将指定的贮藏重新应用\n\ngit stash apply --index //加上--index后，可将之前暂存的文件重新应用暂存。\n\ngit stash drop stash2&#123;0&#125; //移除指定的贮藏\n\ngit stash pop //应用贮藏后立即从栈上移除\n\n git stash --all //来移除每一样东西并存放在栈中，包括未跟踪文件\n</code></pre>\n<pre><code class=\"js\">`扩展`\ngit stash --keep-index //不仅将已暂存的文件贮藏在栈，还要保留已暂存的内容和索引中\n\n`默认情况下git stash只会贮藏已暂存和已跟踪文件。`\ngit status --include-untracked  //会贮藏任何未跟踪文件，但不包括明确忽略文件，简写-u。包含所有文件使用-a\n\n`不贮藏所有修改过的文件`\ngit stash --patch \n\n`当贮藏了文件a,然后还在贮藏的分支上修改a,在将a重新应用工作时可能会出现合并冲突`\ngit stash branch 分支名称 //将贮藏工作，重新应用在分支工作\n</code></pre>\n</li>\n</ul>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">//git命令---------------\nglobal //全局\ninit //初始化\ncommit    //提交\noneline //一行\namend  //修改\nrestore //恢复\nstaged     //已暂存\ncached    //缓存\nmessage //信息\ncheckout //检出\n</code></pre>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>git restore –staged 和 git rm –cached的区别？</li>\n</ol>\n<ul>\n<li><p>git restore –staged 是将文件撤销到工作目录中，暂存区中还有保留，工作目录也会保留，但是当commit提交到本地仓库中时不会将此文件提交，当版本回滚时此文件会受到回滚的控制</p>\n</li>\n<li><p>git rm –cached 是将文件彻底从暂存区删除，本地工作目录也还会保留，当commit提交到本地仓库时，不会将此文件提交，但是当回滚版本时，此文件不会回滚回来</p>\n</li>\n<li><p>总结：git restore 是撤销操作。</p>\n<p>​        git rm –cached是删除操作。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>暂存区已经将文件__add存入__，此时在工作目录中__修改文件__，___再次add___，是否会__覆盖__掉暂存区的文件？</li>\n</ol>\n<ul>\n<li>会覆盖</li>\n</ul>\n<ol start=\"3\">\n<li>当文件commit提交到本地仓库中后，是否还可执行git restore 和git rm –cached操作<ul>\n<li>不可</li>\n</ul>\n</li>\n</ol>\n"},{"title":"git远程仓库命令","date":"2020-09-06T08:21:43.000Z","_content":"\n# git02\n\n## 远程仓库\n\n+ 将本地代码上传到远程仓库，方便共享管理\n+ 公司内部有自己的远程仓库，公司一般使用gitLab，类似于github的界面，当是公司自己服务器\n\n### 网络远程仓库\n\n+ github\n+ 码云\n\n## 创建github远程仓库,推送代码\n\n```js\ngit remote add origin 远程仓库地址// 给仓库起别名，orign是别名\ngit remote -v  //查看别名\ngit remote remove 别名//删除别名\ngit remote rename 别名  要修改的别名//修改别名\n\ngit push -u origin master //将代码添加到远程仓库分支上,第一次加-u后，会将本地仓库和远程仓库关联，以后直接git push 会自动找到分支\ngit push -f //强制推送\n```\n\n```js\ngit clone 远程仓库地址  //将远程库镜像下来 \n\n'当clone时，会默认把远程仓库地址 起名为origin,且本地和远程仓库绑定了master分支'\n```\n\n+ 克隆下的代码不需要重新关联pust -u,可直接push\n\n```js\ngit pull //将远程仓库的代码更新到本地\n```\n\n\n\n## 配置用户权限\n\n+ ssh流程\n  1. 客户端会生成两个密钥，公钥和私钥\n  2. 把公钥给远程仓库\n  3. 本地上传代码，是基于私钥进行加密的\n  4. 远程仓库收到请求后，基于对公钥进行验证\n  5. 远程仓库验证通过后运行上传代码\n\n```js\nssh-keygen -t rsa -C \"远程仓库邮箱地址\"   //生成两个密钥\n```\n\n+ 这两个密钥在本地都会生成文件，git会提示它们的地址\n+ 如果是个人远程仓库，可直接将公钥添加到个人github中\n+ 如果远程仓库是其它人的，需要将公钥发给他人。\n\n\n\n## 分支\n\n### 概念\n\n1. 一个分支一个业务\n2. 测试项目时一般以某一个分支为基准进行测试\n3. 有时代码出现bug，此时可创建一个分支，专门用来处理bug\n\n### 操作本地分支\n\n```js\ngit branch //查看分支，默认1个 master是主分支\n\ngit branch 分支名称 //创建分支，以最新的版本为基准，是一份独立代码\n\ngit checkout 分支名称 //切换分支，切换之前需要先提交代码commit\n\ngit merge 分支名称 //合并分支，将当前分支和 分支名称 的代码 合并\n\ngit branch -d 分支名称 //-d,合并后才可删除\n\ngit branch -D 分支名称 //-D,没有合并也会强制删除\n\ngit checkout -b 分支名称 //创建分支并切换到分支\n\n//修改分支名，如果对于分支不是当前分支，可以使用下面代码：\ngit branch -m 原分支名 新分支名\n//如果是当前，那么可以使用加上新名字\ngit branch -m 新分支名称\n```\n\n### 操作远程分支\n\n```js\ngit branch -r //查看所有远程分支\ngit branch -a //查看所有远程，本地分支\ngit branch -vv //查看远程仓库和本地仓库的关联\n\ngit oush origin -delete 分支名 //删除远程分支\n\n\ngit branch -u origin/master //建立当前分支与远程分支的映射关系\n\ngit checkout dev origin/dev  //创建分支dev并和远程origin/dev分支惯量，本地dev分支的初始代码和远程的dev分支代码一样\n\ngit branch --unset-upstream //撤销本地分支与远程分支的映射关系\n\ngit push -u origin 本地分支名 //将本地分支推送到远程分支\n```\n\n\n\n## 协作模式\n\n+ 远程仓库是共享的，所有项目研究者共享相同的远程仓库，这种协作模式下造成冲突的情况较大\n\n+ 第二种协作模式\n\n  + 每个研发者都有自己独有的分支\n\n  + 专门有人负责合并研发这分支的代码到主分支\n\n  + 每个研发者可以拉去主分支代码，但是没有推送权限\n\n    如果没有推送权限，那么研发者的分支是如何推送到负责推送到主分支人的手中？是在创建一个每个人的分支远程仓库吗？\n\n\n## 注意\n\n1. 如果a推送到远程仓库之后，b需要先pull更新，在去推送push\n2. 场景：a先修改了文件index文件第2行，并推送到了远程仓库，b也修改了index文件的第2行，此时b也推送到远程仓库，b客户端的git会提示（master|MERGING），代码冲突。\n   - 此冲突需要手动协商解决，保证功能的合理性\n3. 分支合并时也会产生冲突，只要合并就会产生冲突\n4. 不要勾选  __不公开邮箱__ ,否则可能会造成没有权限\n\n## 单词\n\n```js\nremote //远程\nrename //别名\norigin //起点\nclone\t//克隆\npull \t//拉\nkeygen //注册机\nrsa //对密钥的算法\nbranch  //分支\nmerge  //合并\n```\n\n\n## ？\n\n1. 问题1：\n\n   ![](./assets/Snipaste_2020-09-27_20-44-43.png)\n\n   + 为什么会出现？\n     + 有a和b两个开发者，当a push推送到远程仓库并且代码版本更新，此时开发者b也要push 推送到远程仓库，就会出现此错误\n   + 原因\n     + 因为开发者b的本地仓库版本落后于远程仓库的版本号了\n   + 解决\n     + 需要重新pull拉取一下远仓，当时此时就会出现问题2\n\n\n\n\n\n\n\n\n\n1. 问题2：当从远程仓库pull到本地仓库时出现\n\n   + ```js\n     Merge branch 'master' of gitee.com:xing-wenhang/xingwenhang\n     # Please enter a commit message to explain why this merge is necessary,\n     # especially if it merges an updated upstream into a topic branch.\n     #\n     # Lines starting with '#' will be ignored, and an empty message aborts\n     # the commit.\n     ~\n         \n     即：请输入提交消息来解释为什么这种合并是必要的\n     ```\n\n   + 原因：\n\n     + 因为本地仓库版本落后于远程仓库的版本号了\n\n   + 解决\n\n     1. 方案1：\n\n        + 如果要写解释，如果不写解释就直接3，4\n\n          ```\n          1.按键盘字母 i 进入insert模式\n          \n          2.修改最上面那行黄色合并信息,可以不修改\n          \n          3.按键盘左上角\"Esc\"\n          \n          4.输入\" :wq\",冒号+wq,按回车键即可\n          \n          ```\n\n     2. 方案2:\n\n        + 在每次推送代码之前，直接使用  拉取合并新的变动到本地。git pull --rebase\n\n          \n\n     \n\n2. 分支的详解\n\n   官方文档：\n\n   \n\n   \n\n3. git主分支可以删除吗，如果可以那么删除git主分支,重新设置主分支。\n\n     可以删除，远程仓库的主分支默认为master，无法删除，需要进入远程仓库修改主分支才可删除。\n\n   \n\n4. 场景：当a开发者工作一段时间后，老板说要改一个bug，a开发者创建并切换了分支去改bug，此时突然发现你刚才修改的文件还没有add，那么修改的文件还会处于切换分支前的状态吗？\n\n   - 修改的文件只要没有add到暂存区就不会变\n\n   \n\n5. Fast Forward 和 no fast foward ，fetch+merge是什么？ \n\n   + fast forward:通常合并分支时，如果没有分歧解决，就会直接移动文件指针。\n   + no fast foward ：使用--no-ff之后，在合并时会生成 一个新的commit,这样可查看出分支信息。\n\n   \n","source":"_posts/git/02-git远程仓库操作.md","raw":"---\ntitle: git远程仓库命令\ndate: 2020-09-06 16:21:43\ncategories:\n- git\ntags:\n- git\n---\n\n# git02\n\n## 远程仓库\n\n+ 将本地代码上传到远程仓库，方便共享管理\n+ 公司内部有自己的远程仓库，公司一般使用gitLab，类似于github的界面，当是公司自己服务器\n\n### 网络远程仓库\n\n+ github\n+ 码云\n\n## 创建github远程仓库,推送代码\n\n```js\ngit remote add origin 远程仓库地址// 给仓库起别名，orign是别名\ngit remote -v  //查看别名\ngit remote remove 别名//删除别名\ngit remote rename 别名  要修改的别名//修改别名\n\ngit push -u origin master //将代码添加到远程仓库分支上,第一次加-u后，会将本地仓库和远程仓库关联，以后直接git push 会自动找到分支\ngit push -f //强制推送\n```\n\n```js\ngit clone 远程仓库地址  //将远程库镜像下来 \n\n'当clone时，会默认把远程仓库地址 起名为origin,且本地和远程仓库绑定了master分支'\n```\n\n+ 克隆下的代码不需要重新关联pust -u,可直接push\n\n```js\ngit pull //将远程仓库的代码更新到本地\n```\n\n\n\n## 配置用户权限\n\n+ ssh流程\n  1. 客户端会生成两个密钥，公钥和私钥\n  2. 把公钥给远程仓库\n  3. 本地上传代码，是基于私钥进行加密的\n  4. 远程仓库收到请求后，基于对公钥进行验证\n  5. 远程仓库验证通过后运行上传代码\n\n```js\nssh-keygen -t rsa -C \"远程仓库邮箱地址\"   //生成两个密钥\n```\n\n+ 这两个密钥在本地都会生成文件，git会提示它们的地址\n+ 如果是个人远程仓库，可直接将公钥添加到个人github中\n+ 如果远程仓库是其它人的，需要将公钥发给他人。\n\n\n\n## 分支\n\n### 概念\n\n1. 一个分支一个业务\n2. 测试项目时一般以某一个分支为基准进行测试\n3. 有时代码出现bug，此时可创建一个分支，专门用来处理bug\n\n### 操作本地分支\n\n```js\ngit branch //查看分支，默认1个 master是主分支\n\ngit branch 分支名称 //创建分支，以最新的版本为基准，是一份独立代码\n\ngit checkout 分支名称 //切换分支，切换之前需要先提交代码commit\n\ngit merge 分支名称 //合并分支，将当前分支和 分支名称 的代码 合并\n\ngit branch -d 分支名称 //-d,合并后才可删除\n\ngit branch -D 分支名称 //-D,没有合并也会强制删除\n\ngit checkout -b 分支名称 //创建分支并切换到分支\n\n//修改分支名，如果对于分支不是当前分支，可以使用下面代码：\ngit branch -m 原分支名 新分支名\n//如果是当前，那么可以使用加上新名字\ngit branch -m 新分支名称\n```\n\n### 操作远程分支\n\n```js\ngit branch -r //查看所有远程分支\ngit branch -a //查看所有远程，本地分支\ngit branch -vv //查看远程仓库和本地仓库的关联\n\ngit oush origin -delete 分支名 //删除远程分支\n\n\ngit branch -u origin/master //建立当前分支与远程分支的映射关系\n\ngit checkout dev origin/dev  //创建分支dev并和远程origin/dev分支惯量，本地dev分支的初始代码和远程的dev分支代码一样\n\ngit branch --unset-upstream //撤销本地分支与远程分支的映射关系\n\ngit push -u origin 本地分支名 //将本地分支推送到远程分支\n```\n\n\n\n## 协作模式\n\n+ 远程仓库是共享的，所有项目研究者共享相同的远程仓库，这种协作模式下造成冲突的情况较大\n\n+ 第二种协作模式\n\n  + 每个研发者都有自己独有的分支\n\n  + 专门有人负责合并研发这分支的代码到主分支\n\n  + 每个研发者可以拉去主分支代码，但是没有推送权限\n\n    如果没有推送权限，那么研发者的分支是如何推送到负责推送到主分支人的手中？是在创建一个每个人的分支远程仓库吗？\n\n\n## 注意\n\n1. 如果a推送到远程仓库之后，b需要先pull更新，在去推送push\n2. 场景：a先修改了文件index文件第2行，并推送到了远程仓库，b也修改了index文件的第2行，此时b也推送到远程仓库，b客户端的git会提示（master|MERGING），代码冲突。\n   - 此冲突需要手动协商解决，保证功能的合理性\n3. 分支合并时也会产生冲突，只要合并就会产生冲突\n4. 不要勾选  __不公开邮箱__ ,否则可能会造成没有权限\n\n## 单词\n\n```js\nremote //远程\nrename //别名\norigin //起点\nclone\t//克隆\npull \t//拉\nkeygen //注册机\nrsa //对密钥的算法\nbranch  //分支\nmerge  //合并\n```\n\n\n## ？\n\n1. 问题1：\n\n   ![](./assets/Snipaste_2020-09-27_20-44-43.png)\n\n   + 为什么会出现？\n     + 有a和b两个开发者，当a push推送到远程仓库并且代码版本更新，此时开发者b也要push 推送到远程仓库，就会出现此错误\n   + 原因\n     + 因为开发者b的本地仓库版本落后于远程仓库的版本号了\n   + 解决\n     + 需要重新pull拉取一下远仓，当时此时就会出现问题2\n\n\n\n\n\n\n\n\n\n1. 问题2：当从远程仓库pull到本地仓库时出现\n\n   + ```js\n     Merge branch 'master' of gitee.com:xing-wenhang/xingwenhang\n     # Please enter a commit message to explain why this merge is necessary,\n     # especially if it merges an updated upstream into a topic branch.\n     #\n     # Lines starting with '#' will be ignored, and an empty message aborts\n     # the commit.\n     ~\n         \n     即：请输入提交消息来解释为什么这种合并是必要的\n     ```\n\n   + 原因：\n\n     + 因为本地仓库版本落后于远程仓库的版本号了\n\n   + 解决\n\n     1. 方案1：\n\n        + 如果要写解释，如果不写解释就直接3，4\n\n          ```\n          1.按键盘字母 i 进入insert模式\n          \n          2.修改最上面那行黄色合并信息,可以不修改\n          \n          3.按键盘左上角\"Esc\"\n          \n          4.输入\" :wq\",冒号+wq,按回车键即可\n          \n          ```\n\n     2. 方案2:\n\n        + 在每次推送代码之前，直接使用  拉取合并新的变动到本地。git pull --rebase\n\n          \n\n     \n\n2. 分支的详解\n\n   官方文档：\n\n   \n\n   \n\n3. git主分支可以删除吗，如果可以那么删除git主分支,重新设置主分支。\n\n     可以删除，远程仓库的主分支默认为master，无法删除，需要进入远程仓库修改主分支才可删除。\n\n   \n\n4. 场景：当a开发者工作一段时间后，老板说要改一个bug，a开发者创建并切换了分支去改bug，此时突然发现你刚才修改的文件还没有add，那么修改的文件还会处于切换分支前的状态吗？\n\n   - 修改的文件只要没有add到暂存区就不会变\n\n   \n\n5. Fast Forward 和 no fast foward ，fetch+merge是什么？ \n\n   + fast forward:通常合并分支时，如果没有分歧解决，就会直接移动文件指针。\n   + no fast foward ：使用--no-ff之后，在合并时会生成 一个新的commit,这样可查看出分支信息。\n\n   \n","slug":"git/02-git远程仓库操作","published":1,"updated":"2023-03-01T07:09:06.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbt0005awaf5had7jry","content":"<h1 id=\"git02\"><a href=\"#git02\" class=\"headerlink\" title=\"git02\"></a>git02</h1><h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><ul>\n<li>将本地代码上传到远程仓库，方便共享管理</li>\n<li>公司内部有自己的远程仓库，公司一般使用gitLab，类似于github的界面，当是公司自己服务器</li>\n</ul>\n<h3 id=\"网络远程仓库\"><a href=\"#网络远程仓库\" class=\"headerlink\" title=\"网络远程仓库\"></a>网络远程仓库</h3><ul>\n<li>github</li>\n<li>码云</li>\n</ul>\n<h2 id=\"创建github远程仓库-推送代码\"><a href=\"#创建github远程仓库-推送代码\" class=\"headerlink\" title=\"创建github远程仓库,推送代码\"></a>创建github远程仓库,推送代码</h2><pre><code class=\"js\">git remote add origin 远程仓库地址// 给仓库起别名，orign是别名\ngit remote -v  //查看别名\ngit remote remove 别名//删除别名\ngit remote rename 别名  要修改的别名//修改别名\n\ngit push -u origin master //将代码添加到远程仓库分支上,第一次加-u后，会将本地仓库和远程仓库关联，以后直接git push 会自动找到分支\ngit push -f //强制推送\n</code></pre>\n<pre><code class=\"js\">git clone 远程仓库地址  //将远程库镜像下来 \n\n&#39;当clone时，会默认把远程仓库地址 起名为origin,且本地和远程仓库绑定了master分支&#39;\n</code></pre>\n<ul>\n<li>克隆下的代码不需要重新关联pust -u,可直接push</li>\n</ul>\n<pre><code class=\"js\">git pull //将远程仓库的代码更新到本地\n</code></pre>\n<h2 id=\"配置用户权限\"><a href=\"#配置用户权限\" class=\"headerlink\" title=\"配置用户权限\"></a>配置用户权限</h2><ul>\n<li>ssh流程<ol>\n<li>客户端会生成两个密钥，公钥和私钥</li>\n<li>把公钥给远程仓库</li>\n<li>本地上传代码，是基于私钥进行加密的</li>\n<li>远程仓库收到请求后，基于对公钥进行验证</li>\n<li>远程仓库验证通过后运行上传代码</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">ssh-keygen -t rsa -C &quot;远程仓库邮箱地址&quot;   //生成两个密钥\n</code></pre>\n<ul>\n<li>这两个密钥在本地都会生成文件，git会提示它们的地址</li>\n<li>如果是个人远程仓库，可直接将公钥添加到个人github中</li>\n<li>如果远程仓库是其它人的，需要将公钥发给他人。</li>\n</ul>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ol>\n<li>一个分支一个业务</li>\n<li>测试项目时一般以某一个分支为基准进行测试</li>\n<li>有时代码出现bug，此时可创建一个分支，专门用来处理bug</li>\n</ol>\n<h3 id=\"操作本地分支\"><a href=\"#操作本地分支\" class=\"headerlink\" title=\"操作本地分支\"></a>操作本地分支</h3><pre><code class=\"js\">git branch //查看分支，默认1个 master是主分支\n\ngit branch 分支名称 //创建分支，以最新的版本为基准，是一份独立代码\n\ngit checkout 分支名称 //切换分支，切换之前需要先提交代码commit\n\ngit merge 分支名称 //合并分支，将当前分支和 分支名称 的代码 合并\n\ngit branch -d 分支名称 //-d,合并后才可删除\n\ngit branch -D 分支名称 //-D,没有合并也会强制删除\n\ngit checkout -b 分支名称 //创建分支并切换到分支\n\n//修改分支名，如果对于分支不是当前分支，可以使用下面代码：\ngit branch -m 原分支名 新分支名\n//如果是当前，那么可以使用加上新名字\ngit branch -m 新分支名称\n</code></pre>\n<h3 id=\"操作远程分支\"><a href=\"#操作远程分支\" class=\"headerlink\" title=\"操作远程分支\"></a>操作远程分支</h3><pre><code class=\"js\">git branch -r //查看所有远程分支\ngit branch -a //查看所有远程，本地分支\ngit branch -vv //查看远程仓库和本地仓库的关联\n\ngit oush origin -delete 分支名 //删除远程分支\n\n\ngit branch -u origin/master //建立当前分支与远程分支的映射关系\n\ngit checkout dev origin/dev  //创建分支dev并和远程origin/dev分支惯量，本地dev分支的初始代码和远程的dev分支代码一样\n\ngit branch --unset-upstream //撤销本地分支与远程分支的映射关系\n\ngit push -u origin 本地分支名 //将本地分支推送到远程分支\n</code></pre>\n<h2 id=\"协作模式\"><a href=\"#协作模式\" class=\"headerlink\" title=\"协作模式\"></a>协作模式</h2><ul>\n<li><p>远程仓库是共享的，所有项目研究者共享相同的远程仓库，这种协作模式下造成冲突的情况较大</p>\n</li>\n<li><p>第二种协作模式</p>\n<ul>\n<li><p>每个研发者都有自己独有的分支</p>\n</li>\n<li><p>专门有人负责合并研发这分支的代码到主分支</p>\n</li>\n<li><p>每个研发者可以拉去主分支代码，但是没有推送权限</p>\n<p>如果没有推送权限，那么研发者的分支是如何推送到负责推送到主分支人的手中？是在创建一个每个人的分支远程仓库吗？</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>如果a推送到远程仓库之后，b需要先pull更新，在去推送push</li>\n<li>场景：a先修改了文件index文件第2行，并推送到了远程仓库，b也修改了index文件的第2行，此时b也推送到远程仓库，b客户端的git会提示（master|MERGING），代码冲突。<ul>\n<li>此冲突需要手动协商解决，保证功能的合理性</li>\n</ul>\n</li>\n<li>分支合并时也会产生冲突，只要合并就会产生冲突</li>\n<li>不要勾选  <strong>不公开邮箱</strong> ,否则可能会造成没有权限</li>\n</ol>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">remote //远程\nrename //别名\norigin //起点\nclone    //克隆\npull     //拉\nkeygen //注册机\nrsa //对密钥的算法\nbranch  //分支\nmerge  //合并\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>问题1：</p>\n<p><img src=\"./assets/Snipaste_2020-09-27_20-44-43.png\"></p>\n<ul>\n<li>为什么会出现？<ul>\n<li>有a和b两个开发者，当a push推送到远程仓库并且代码版本更新，此时开发者b也要push 推送到远程仓库，就会出现此错误</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>因为开发者b的本地仓库版本落后于远程仓库的版本号了</li>\n</ul>\n</li>\n<li>解决<ul>\n<li>需要重新pull拉取一下远仓，当时此时就会出现问题2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>问题2：当从远程仓库pull到本地仓库时出现</p>\n<ul>\n<li><pre><code class=\"js\">Merge branch &#39;master&#39; of gitee.com:xing-wenhang/xingwenhang\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with &#39;#&#39; will be ignored, and an empty message aborts\n# the commit.\n~\n    \n即：请输入提交消息来解释为什么这种合并是必要的\n</code></pre>\n</li>\n<li><p>原因：</p>\n<ul>\n<li>因为本地仓库版本落后于远程仓库的版本号了</li>\n</ul>\n</li>\n<li><p>解决</p>\n<ol>\n<li><p>方案1：</p>\n<ul>\n<li><p>如果要写解释，如果不写解释就直接3，4</p>\n<pre><code>1.按键盘字母 i 进入insert模式\n\n2.修改最上面那行黄色合并信息,可以不修改\n\n3.按键盘左上角&quot;Esc&quot;\n\n4.输入&quot; :wq&quot;,冒号+wq,按回车键即可\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>方案2:</p>\n<ul>\n<li>在每次推送代码之前，直接使用  拉取合并新的变动到本地。git pull –rebase</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>分支的详解</p>\n<p>官方文档：</p>\n</li>\n<li><p>git主分支可以删除吗，如果可以那么删除git主分支,重新设置主分支。</p>\n<p>  可以删除，远程仓库的主分支默认为master，无法删除，需要进入远程仓库修改主分支才可删除。</p>\n</li>\n<li><p>场景：当a开发者工作一段时间后，老板说要改一个bug，a开发者创建并切换了分支去改bug，此时突然发现你刚才修改的文件还没有add，那么修改的文件还会处于切换分支前的状态吗？</p>\n<ul>\n<li>修改的文件只要没有add到暂存区就不会变</li>\n</ul>\n</li>\n<li><p>Fast Forward 和 no fast foward ，fetch+merge是什么？ </p>\n<ul>\n<li>fast forward:通常合并分支时，如果没有分歧解决，就会直接移动文件指针。</li>\n<li>no fast foward ：使用–no-ff之后，在合并时会生成 一个新的commit,这样可查看出分支信息。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"git02\"><a href=\"#git02\" class=\"headerlink\" title=\"git02\"></a>git02</h1><h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><ul>\n<li>将本地代码上传到远程仓库，方便共享管理</li>\n<li>公司内部有自己的远程仓库，公司一般使用gitLab，类似于github的界面，当是公司自己服务器</li>\n</ul>\n<h3 id=\"网络远程仓库\"><a href=\"#网络远程仓库\" class=\"headerlink\" title=\"网络远程仓库\"></a>网络远程仓库</h3><ul>\n<li>github</li>\n<li>码云</li>\n</ul>\n<h2 id=\"创建github远程仓库-推送代码\"><a href=\"#创建github远程仓库-推送代码\" class=\"headerlink\" title=\"创建github远程仓库,推送代码\"></a>创建github远程仓库,推送代码</h2><pre><code class=\"js\">git remote add origin 远程仓库地址// 给仓库起别名，orign是别名\ngit remote -v  //查看别名\ngit remote remove 别名//删除别名\ngit remote rename 别名  要修改的别名//修改别名\n\ngit push -u origin master //将代码添加到远程仓库分支上,第一次加-u后，会将本地仓库和远程仓库关联，以后直接git push 会自动找到分支\ngit push -f //强制推送\n</code></pre>\n<pre><code class=\"js\">git clone 远程仓库地址  //将远程库镜像下来 \n\n&#39;当clone时，会默认把远程仓库地址 起名为origin,且本地和远程仓库绑定了master分支&#39;\n</code></pre>\n<ul>\n<li>克隆下的代码不需要重新关联pust -u,可直接push</li>\n</ul>\n<pre><code class=\"js\">git pull //将远程仓库的代码更新到本地\n</code></pre>\n<h2 id=\"配置用户权限\"><a href=\"#配置用户权限\" class=\"headerlink\" title=\"配置用户权限\"></a>配置用户权限</h2><ul>\n<li>ssh流程<ol>\n<li>客户端会生成两个密钥，公钥和私钥</li>\n<li>把公钥给远程仓库</li>\n<li>本地上传代码，是基于私钥进行加密的</li>\n<li>远程仓库收到请求后，基于对公钥进行验证</li>\n<li>远程仓库验证通过后运行上传代码</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">ssh-keygen -t rsa -C &quot;远程仓库邮箱地址&quot;   //生成两个密钥\n</code></pre>\n<ul>\n<li>这两个密钥在本地都会生成文件，git会提示它们的地址</li>\n<li>如果是个人远程仓库，可直接将公钥添加到个人github中</li>\n<li>如果远程仓库是其它人的，需要将公钥发给他人。</li>\n</ul>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ol>\n<li>一个分支一个业务</li>\n<li>测试项目时一般以某一个分支为基准进行测试</li>\n<li>有时代码出现bug，此时可创建一个分支，专门用来处理bug</li>\n</ol>\n<h3 id=\"操作本地分支\"><a href=\"#操作本地分支\" class=\"headerlink\" title=\"操作本地分支\"></a>操作本地分支</h3><pre><code class=\"js\">git branch //查看分支，默认1个 master是主分支\n\ngit branch 分支名称 //创建分支，以最新的版本为基准，是一份独立代码\n\ngit checkout 分支名称 //切换分支，切换之前需要先提交代码commit\n\ngit merge 分支名称 //合并分支，将当前分支和 分支名称 的代码 合并\n\ngit branch -d 分支名称 //-d,合并后才可删除\n\ngit branch -D 分支名称 //-D,没有合并也会强制删除\n\ngit checkout -b 分支名称 //创建分支并切换到分支\n\n//修改分支名，如果对于分支不是当前分支，可以使用下面代码：\ngit branch -m 原分支名 新分支名\n//如果是当前，那么可以使用加上新名字\ngit branch -m 新分支名称\n</code></pre>\n<h3 id=\"操作远程分支\"><a href=\"#操作远程分支\" class=\"headerlink\" title=\"操作远程分支\"></a>操作远程分支</h3><pre><code class=\"js\">git branch -r //查看所有远程分支\ngit branch -a //查看所有远程，本地分支\ngit branch -vv //查看远程仓库和本地仓库的关联\n\ngit oush origin -delete 分支名 //删除远程分支\n\n\ngit branch -u origin/master //建立当前分支与远程分支的映射关系\n\ngit checkout dev origin/dev  //创建分支dev并和远程origin/dev分支惯量，本地dev分支的初始代码和远程的dev分支代码一样\n\ngit branch --unset-upstream //撤销本地分支与远程分支的映射关系\n\ngit push -u origin 本地分支名 //将本地分支推送到远程分支\n</code></pre>\n<h2 id=\"协作模式\"><a href=\"#协作模式\" class=\"headerlink\" title=\"协作模式\"></a>协作模式</h2><ul>\n<li><p>远程仓库是共享的，所有项目研究者共享相同的远程仓库，这种协作模式下造成冲突的情况较大</p>\n</li>\n<li><p>第二种协作模式</p>\n<ul>\n<li><p>每个研发者都有自己独有的分支</p>\n</li>\n<li><p>专门有人负责合并研发这分支的代码到主分支</p>\n</li>\n<li><p>每个研发者可以拉去主分支代码，但是没有推送权限</p>\n<p>如果没有推送权限，那么研发者的分支是如何推送到负责推送到主分支人的手中？是在创建一个每个人的分支远程仓库吗？</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>如果a推送到远程仓库之后，b需要先pull更新，在去推送push</li>\n<li>场景：a先修改了文件index文件第2行，并推送到了远程仓库，b也修改了index文件的第2行，此时b也推送到远程仓库，b客户端的git会提示（master|MERGING），代码冲突。<ul>\n<li>此冲突需要手动协商解决，保证功能的合理性</li>\n</ul>\n</li>\n<li>分支合并时也会产生冲突，只要合并就会产生冲突</li>\n<li>不要勾选  <strong>不公开邮箱</strong> ,否则可能会造成没有权限</li>\n</ol>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">remote //远程\nrename //别名\norigin //起点\nclone    //克隆\npull     //拉\nkeygen //注册机\nrsa //对密钥的算法\nbranch  //分支\nmerge  //合并\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>问题1：</p>\n<p><img src=\"./assets/Snipaste_2020-09-27_20-44-43.png\"></p>\n<ul>\n<li>为什么会出现？<ul>\n<li>有a和b两个开发者，当a push推送到远程仓库并且代码版本更新，此时开发者b也要push 推送到远程仓库，就会出现此错误</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>因为开发者b的本地仓库版本落后于远程仓库的版本号了</li>\n</ul>\n</li>\n<li>解决<ul>\n<li>需要重新pull拉取一下远仓，当时此时就会出现问题2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>问题2：当从远程仓库pull到本地仓库时出现</p>\n<ul>\n<li><pre><code class=\"js\">Merge branch &#39;master&#39; of gitee.com:xing-wenhang/xingwenhang\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with &#39;#&#39; will be ignored, and an empty message aborts\n# the commit.\n~\n    \n即：请输入提交消息来解释为什么这种合并是必要的\n</code></pre>\n</li>\n<li><p>原因：</p>\n<ul>\n<li>因为本地仓库版本落后于远程仓库的版本号了</li>\n</ul>\n</li>\n<li><p>解决</p>\n<ol>\n<li><p>方案1：</p>\n<ul>\n<li><p>如果要写解释，如果不写解释就直接3，4</p>\n<pre><code>1.按键盘字母 i 进入insert模式\n\n2.修改最上面那行黄色合并信息,可以不修改\n\n3.按键盘左上角&quot;Esc&quot;\n\n4.输入&quot; :wq&quot;,冒号+wq,按回车键即可\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>方案2:</p>\n<ul>\n<li>在每次推送代码之前，直接使用  拉取合并新的变动到本地。git pull –rebase</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>分支的详解</p>\n<p>官方文档：</p>\n</li>\n<li><p>git主分支可以删除吗，如果可以那么删除git主分支,重新设置主分支。</p>\n<p>  可以删除，远程仓库的主分支默认为master，无法删除，需要进入远程仓库修改主分支才可删除。</p>\n</li>\n<li><p>场景：当a开发者工作一段时间后，老板说要改一个bug，a开发者创建并切换了分支去改bug，此时突然发现你刚才修改的文件还没有add，那么修改的文件还会处于切换分支前的状态吗？</p>\n<ul>\n<li>修改的文件只要没有add到暂存区就不会变</li>\n</ul>\n</li>\n<li><p>Fast Forward 和 no fast foward ，fetch+merge是什么？ </p>\n<ul>\n<li>fast forward:通常合并分支时，如果没有分歧解决，就会直接移动文件指针。</li>\n<li>no fast foward ：使用–no-ff之后，在合并时会生成 一个新的commit,这样可查看出分支信息。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"前端优化相关","date":"2019-05-06T06:02:48.000Z","_content":"\n\n\n### 为什么需要优化\n\n> 一切都是为了用户体验，为了使页面打开的更快，使代码更简洁，好维护。\n\n### 优化的分类\n\n> 从网络优化，代码优化，用户体验优化,打包优化\n\n+ **网络优化**\n\n  1. 浏览器并发\n\n     因为 ip 是基于 tcp 协议的，限制浏览器只能在同一时间内发送6-7个请求，超过请求就会阻塞。\n\n     **解决**:使用雪碧图和图片懒加载技术，对于某些静态资源，可将其合并到同一个http请求。\n\n  2. 防抖和节流，实现对请求的降频。\n\n+ **代码优化**\n\n  1. 一些不影响页面的功能代码使用 async(没有顺序) defer(有顺序) 异步加载。\n  2. 减少直接对dom的操作，避免重绘和回流。\n  3. css样式必须加 scoped 防止样式干扰。\n  4. v-if 和 v-show 的使用场景，v-if性能消耗更多，所以需要频繁切换时使用v-show。\n\n+ **用户体验优化**\n\n  1. 页面加载时或用户点击按钮时触发 loading 提示。\n\n+ **打包优化**\n\n  1. 路由使用 import  动态加载。\n  2. 第三方组件使用按需加载。","source":"_posts/前端/前端性能优化.md","raw":"---\ntitle: 前端优化相关\ndate: 2019-05-06 14:02:48\ncategories:\n- 前端\ntags:\n- 前端\n- 优化\n---\n\n\n\n### 为什么需要优化\n\n> 一切都是为了用户体验，为了使页面打开的更快，使代码更简洁，好维护。\n\n### 优化的分类\n\n> 从网络优化，代码优化，用户体验优化,打包优化\n\n+ **网络优化**\n\n  1. 浏览器并发\n\n     因为 ip 是基于 tcp 协议的，限制浏览器只能在同一时间内发送6-7个请求，超过请求就会阻塞。\n\n     **解决**:使用雪碧图和图片懒加载技术，对于某些静态资源，可将其合并到同一个http请求。\n\n  2. 防抖和节流，实现对请求的降频。\n\n+ **代码优化**\n\n  1. 一些不影响页面的功能代码使用 async(没有顺序) defer(有顺序) 异步加载。\n  2. 减少直接对dom的操作，避免重绘和回流。\n  3. css样式必须加 scoped 防止样式干扰。\n  4. v-if 和 v-show 的使用场景，v-if性能消耗更多，所以需要频繁切换时使用v-show。\n\n+ **用户体验优化**\n\n  1. 页面加载时或用户点击按钮时触发 loading 提示。\n\n+ **打包优化**\n\n  1. 路由使用 import  动态加载。\n  2. 第三方组件使用按需加载。","slug":"前端/前端性能优化","published":1,"updated":"2023-03-01T09:49:43.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbw0006awaf96f8a9v5","content":"<h3 id=\"为什么需要优化\"><a href=\"#为什么需要优化\" class=\"headerlink\" title=\"为什么需要优化\"></a>为什么需要优化</h3><blockquote>\n<p>一切都是为了用户体验，为了使页面打开的更快，使代码更简洁，好维护。</p>\n</blockquote>\n<h3 id=\"优化的分类\"><a href=\"#优化的分类\" class=\"headerlink\" title=\"优化的分类\"></a>优化的分类</h3><blockquote>\n<p>从网络优化，代码优化，用户体验优化,打包优化</p>\n</blockquote>\n<ul>\n<li><p><strong>网络优化</strong></p>\n<ol>\n<li><p>浏览器并发</p>\n<p>因为 ip 是基于 tcp 协议的，限制浏览器只能在同一时间内发送6-7个请求，超过请求就会阻塞。</p>\n<p><strong>解决</strong>:使用雪碧图和图片懒加载技术，对于某些静态资源，可将其合并到同一个http请求。</p>\n</li>\n<li><p>防抖和节流，实现对请求的降频。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>代码优化</strong></p>\n<ol>\n<li>一些不影响页面的功能代码使用 async(没有顺序) defer(有顺序) 异步加载。</li>\n<li>减少直接对dom的操作，避免重绘和回流。</li>\n<li>css样式必须加 scoped 防止样式干扰。</li>\n<li>v-if 和 v-show 的使用场景，v-if性能消耗更多，所以需要频繁切换时使用v-show。</li>\n</ol>\n</li>\n<li><p><strong>用户体验优化</strong></p>\n<ol>\n<li>页面加载时或用户点击按钮时触发 loading 提示。</li>\n</ol>\n</li>\n<li><p><strong>打包优化</strong></p>\n<ol>\n<li>路由使用 import  动态加载。</li>\n<li>第三方组件使用按需加载。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么需要优化\"><a href=\"#为什么需要优化\" class=\"headerlink\" title=\"为什么需要优化\"></a>为什么需要优化</h3><blockquote>\n<p>一切都是为了用户体验，为了使页面打开的更快，使代码更简洁，好维护。</p>\n</blockquote>\n<h3 id=\"优化的分类\"><a href=\"#优化的分类\" class=\"headerlink\" title=\"优化的分类\"></a>优化的分类</h3><blockquote>\n<p>从网络优化，代码优化，用户体验优化,打包优化</p>\n</blockquote>\n<ul>\n<li><p><strong>网络优化</strong></p>\n<ol>\n<li><p>浏览器并发</p>\n<p>因为 ip 是基于 tcp 协议的，限制浏览器只能在同一时间内发送6-7个请求，超过请求就会阻塞。</p>\n<p><strong>解决</strong>:使用雪碧图和图片懒加载技术，对于某些静态资源，可将其合并到同一个http请求。</p>\n</li>\n<li><p>防抖和节流，实现对请求的降频。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>代码优化</strong></p>\n<ol>\n<li>一些不影响页面的功能代码使用 async(没有顺序) defer(有顺序) 异步加载。</li>\n<li>减少直接对dom的操作，避免重绘和回流。</li>\n<li>css样式必须加 scoped 防止样式干扰。</li>\n<li>v-if 和 v-show 的使用场景，v-if性能消耗更多，所以需要频繁切换时使用v-show。</li>\n</ol>\n</li>\n<li><p><strong>用户体验优化</strong></p>\n<ol>\n<li>页面加载时或用户点击按钮时触发 loading 提示。</li>\n</ol>\n</li>\n<li><p><strong>打包优化</strong></p>\n<ol>\n<li>路由使用 import  动态加载。</li>\n<li>第三方组件使用按需加载。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"demo","date":"2023-03-01T08:01:30.866Z","_content":"","source":"_posts/运维/demo.md","raw":"---\ntitle: demo\ndate: {{ date }}\ncategories:\n- 运维\ntags:\n- 运维\n---","slug":"运维/demo","published":1,"updated":"2023-03-01T08:08:49.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbx0007awafgzqvam21","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"vue3杂烩","date":"2023-03-01T00:35:14.335Z","_content":"[TOC]\n# 简单的api\n```javascript\ntoRwa() 可以将proxy响应式对象转为非响应式\n```","source":"_posts/前端/vue/vue3杂烩.md","raw":"---\ntitle: vue3杂烩\ndate: {{date}}\ncategories:\n- 前端\n- vue\ntags:\n- 前端\n- vue\n---\n[TOC]\n# 简单的api\n```javascript\ntoRwa() 可以将proxy响应式对象转为非响应式\n```","slug":"前端/vue/vue3杂烩","published":1,"updated":"2023-03-01T08:09:00.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qby000bawafazd31ece","content":"<p>[TOC]</p>\n<h1 id=\"简单的api\"><a href=\"#简单的api\" class=\"headerlink\" title=\"简单的api\"></a>简单的api</h1><pre><code class=\"javascript\">toRwa() 可以将proxy响应式对象转为非响应式\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"简单的api\"><a href=\"#简单的api\" class=\"headerlink\" title=\"简单的api\"></a>简单的api</h1><pre><code class=\"javascript\">toRwa() 可以将proxy响应式对象转为非响应式\n</code></pre>\n"},{"title":"vue实现图片帧率轮播播放","date":"2020-09-24T16:00:00.000Z","_content":"\n[TOC]\n\n## 需求\n1. 传入一个数组，数组中放的是目录名称，通过本目录名称，读取文件目录下的所有图片，并循环播放，形成一个每1s播放多少张图片的效果，最后目录播放完毕后，在跳到第一个目录循环播放。\n2. 核心: 用 webpack的一个API ==require.contex==读取目录下的文件名,具体想了解的可以查一查。\n\n## 代码\n+ HTML\n```html\n<template>\n  <div id=\"imgPlay\" ref=\"container\" :style=\"[style]\">\n    <img :src=\"imgsrc\" :style=\"[{height:style.height,width:style.width}]\">\n    <div id=\"but\">\n      <button @click=\"start()\">开始</button>\n      <button @click=\"stop()\">停止</button>\n    </div>\n  </div>\n</template>\n```\n+ javascript\n```javascript\n<script>\nexport default {\n  name: 'ZxImgPlay',\n  data () {\n    return {\n      style:[\n\t\twidth:\"50px\",\n\t\theight:\"50px\"\n\t\t],\n      interval: null, // 定时器id\n      flag: true, // 定时器的开关\n      setIntervalNumber: 0, // 当前展示的图片下标\n      imgsrc: \"\", // 要展示的图片路径\n      imgUrls: [], // 所有的图片路径\n      frameRate: 0 // 帧率\n    }\n  },\n  computed: {},\n  watch: {},\n  created () { },\n  mounted () {\n    this.zxInit()\n  },\n  beforeDestroy () { },\n\n  methods: {\n    zxInit () {\n    // 这里的 this.DisplayParam 是公司内部的一套东西，混入的对象\n    // this.DisplayParam.frameRate 是一个数组[\"目录名1\",\"目录名2\"]\n    // this.DisplayParam.imgUrls 是死图当没有目录的时候就用死图\n    // this.DisplayParam.frameRate 是传入的帧率\n      this.frameRate = this.DisplayParam.frameRate && (1000 / this.DisplayParam.frameRate)\n      this.imgUrls = this.DisplayParam.imgUrls\n      this.DisplayParam.imageFileName != 0 ? this.readdir(this.DisplayParam.imageFileName) : this.showImages(true)\n    },\n\n    start () {\n      if (this.flag) return\n      this.showImages()\n      this.flag = true\n    },\n\n    stop () {\n      this.flag = false\n      clearInterval(this.interval)\n    },\n\n    readImages (imageFileName, _A) {\n      this.stop()\n      let req = require.context(\"@/../static/images\", true, /\\.(?:bmp|jpg|gif|jpeg|png)$/).keys();\n      let path = new RegExp(imageFileName[_A])\n      req.forEach(item => {\n        if (path.test(item)) {\n          this.imgUrls.push({ img: \"@/../static/images/\" + imageFileName[_A] + item.substring(item.lastIndexOf('/')) })\n        }\n      })\n      this.showImages()\n    },\n    readdir (imageFileName) {\n      this.imgUrls = []\n      for (let i = 0; i < imageFileName.length; i++) {\n        this.readImages(imageFileName, i)\n      }\n    },\n\n    showImages (_B) {\n      if (_B) this.imgUrls = this.imgUrlsSort(this.imgUrls, 'sort')\n      console.log(this.imgUrls)\n      this.interval = setInterval(this.setIntervalFun, this.frameRate)\n    },\n\n    imgUrlsSort (ary, key) {\n      return ary.sort((a, b) => {\n        let x = a[key];\n        let y = b[key];\n        return ((x < y) ? -1 : (x > y) ? 1 : 0)\n      })\n    },\n\n    setIntervalFun () {\n      if (this.setIntervalNumber >= this.imgUrls.length) {\n        this.setIntervalNumber = 0\n      }\n      this.imgsrc = this.imgUrls[this.setIntervalNumber++].img || ''\n    }\n  }\n}\n</script>\n```\n## 问题\n上述这么做已经实现了功能，但是目前来说是发现了两个问题\n1. require.context() 这个API它的第一个参数不能用一个可变的值，比如变量，会有警告。\n2. 上述代码一直更换图片的src实现的，也就是说每次换src时都会发送http请求获取图片,导致了内存不会被释放一直增加。\n\n","source":"_posts/前端/vue/vue轮播图帧率播放.md","raw":"---\ntitle: vue实现图片帧率轮播播放\ndate: 2020.09.25\ncategories:\n- 前端\n- vue\ntags:\n- 前端\n- vue\n---\n\n[TOC]\n\n## 需求\n1. 传入一个数组，数组中放的是目录名称，通过本目录名称，读取文件目录下的所有图片，并循环播放，形成一个每1s播放多少张图片的效果，最后目录播放完毕后，在跳到第一个目录循环播放。\n2. 核心: 用 webpack的一个API ==require.contex==读取目录下的文件名,具体想了解的可以查一查。\n\n## 代码\n+ HTML\n```html\n<template>\n  <div id=\"imgPlay\" ref=\"container\" :style=\"[style]\">\n    <img :src=\"imgsrc\" :style=\"[{height:style.height,width:style.width}]\">\n    <div id=\"but\">\n      <button @click=\"start()\">开始</button>\n      <button @click=\"stop()\">停止</button>\n    </div>\n  </div>\n</template>\n```\n+ javascript\n```javascript\n<script>\nexport default {\n  name: 'ZxImgPlay',\n  data () {\n    return {\n      style:[\n\t\twidth:\"50px\",\n\t\theight:\"50px\"\n\t\t],\n      interval: null, // 定时器id\n      flag: true, // 定时器的开关\n      setIntervalNumber: 0, // 当前展示的图片下标\n      imgsrc: \"\", // 要展示的图片路径\n      imgUrls: [], // 所有的图片路径\n      frameRate: 0 // 帧率\n    }\n  },\n  computed: {},\n  watch: {},\n  created () { },\n  mounted () {\n    this.zxInit()\n  },\n  beforeDestroy () { },\n\n  methods: {\n    zxInit () {\n    // 这里的 this.DisplayParam 是公司内部的一套东西，混入的对象\n    // this.DisplayParam.frameRate 是一个数组[\"目录名1\",\"目录名2\"]\n    // this.DisplayParam.imgUrls 是死图当没有目录的时候就用死图\n    // this.DisplayParam.frameRate 是传入的帧率\n      this.frameRate = this.DisplayParam.frameRate && (1000 / this.DisplayParam.frameRate)\n      this.imgUrls = this.DisplayParam.imgUrls\n      this.DisplayParam.imageFileName != 0 ? this.readdir(this.DisplayParam.imageFileName) : this.showImages(true)\n    },\n\n    start () {\n      if (this.flag) return\n      this.showImages()\n      this.flag = true\n    },\n\n    stop () {\n      this.flag = false\n      clearInterval(this.interval)\n    },\n\n    readImages (imageFileName, _A) {\n      this.stop()\n      let req = require.context(\"@/../static/images\", true, /\\.(?:bmp|jpg|gif|jpeg|png)$/).keys();\n      let path = new RegExp(imageFileName[_A])\n      req.forEach(item => {\n        if (path.test(item)) {\n          this.imgUrls.push({ img: \"@/../static/images/\" + imageFileName[_A] + item.substring(item.lastIndexOf('/')) })\n        }\n      })\n      this.showImages()\n    },\n    readdir (imageFileName) {\n      this.imgUrls = []\n      for (let i = 0; i < imageFileName.length; i++) {\n        this.readImages(imageFileName, i)\n      }\n    },\n\n    showImages (_B) {\n      if (_B) this.imgUrls = this.imgUrlsSort(this.imgUrls, 'sort')\n      console.log(this.imgUrls)\n      this.interval = setInterval(this.setIntervalFun, this.frameRate)\n    },\n\n    imgUrlsSort (ary, key) {\n      return ary.sort((a, b) => {\n        let x = a[key];\n        let y = b[key];\n        return ((x < y) ? -1 : (x > y) ? 1 : 0)\n      })\n    },\n\n    setIntervalFun () {\n      if (this.setIntervalNumber >= this.imgUrls.length) {\n        this.setIntervalNumber = 0\n      }\n      this.imgsrc = this.imgUrls[this.setIntervalNumber++].img || ''\n    }\n  }\n}\n</script>\n```\n## 问题\n上述这么做已经实现了功能，但是目前来说是发现了两个问题\n1. require.context() 这个API它的第一个参数不能用一个可变的值，比如变量，会有警告。\n2. 上述代码一直更换图片的src实现的，也就是说每次换src时都会发送http请求获取图片,导致了内存不会被释放一直增加。\n\n","slug":"前端/vue/vue轮播图帧率播放","published":1,"updated":"2023-03-01T08:58:55.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qbz000cawaf1wl0e3ap","content":"<p>[TOC]</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><ol>\n<li>传入一个数组，数组中放的是目录名称，通过本目录名称，读取文件目录下的所有图片，并循环播放，形成一个每1s播放多少张图片的效果，最后目录播放完毕后，在跳到第一个目录循环播放。</li>\n<li>核心: 用 webpack的一个API ==require.contex==读取目录下的文件名,具体想了解的可以查一查。</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><ul>\n<li><p>HTML</p>\n<pre><code class=\"html\">&lt;template&gt;\n&lt;div id=&quot;imgPlay&quot; ref=&quot;container&quot; :style=&quot;[style]&quot;&gt;\n  &lt;img :src=&quot;imgsrc&quot; :style=&quot;[&#123;height:style.height,width:style.width&#125;]&quot;&gt;\n  &lt;div id=&quot;but&quot;&gt;\n    &lt;button @click=&quot;start()&quot;&gt;开始&lt;/button&gt;\n    &lt;button @click=&quot;stop()&quot;&gt;停止&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n</li>\n<li><p>javascript</p>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\nname: &#39;ZxImgPlay&#39;,\ndata () &#123;\n  return &#123;\n    style:[\n      width:&quot;50px&quot;,\n      height:&quot;50px&quot;\n      ],\n    interval: null, // 定时器id\n    flag: true, // 定时器的开关\n    setIntervalNumber: 0, // 当前展示的图片下标\n    imgsrc: &quot;&quot;, // 要展示的图片路径\n    imgUrls: [], // 所有的图片路径\n    frameRate: 0 // 帧率\n  &#125;\n&#125;,\ncomputed: &#123;&#125;,\nwatch: &#123;&#125;,\ncreated () &#123; &#125;,\nmounted () &#123;\n  this.zxInit()\n&#125;,\nbeforeDestroy () &#123; &#125;,\n\nmethods: &#123;\n  zxInit () &#123;\n  // 这里的 this.DisplayParam 是公司内部的一套东西，混入的对象\n  // this.DisplayParam.frameRate 是一个数组[&quot;目录名1&quot;,&quot;目录名2&quot;]\n  // this.DisplayParam.imgUrls 是死图当没有目录的时候就用死图\n  // this.DisplayParam.frameRate 是传入的帧率\n    this.frameRate = this.DisplayParam.frameRate &amp;&amp; (1000 / this.DisplayParam.frameRate)\n    this.imgUrls = this.DisplayParam.imgUrls\n    this.DisplayParam.imageFileName != 0 ? this.readdir(this.DisplayParam.imageFileName) : this.showImages(true)\n  &#125;,\n\n  start () &#123;\n    if (this.flag) return\n    this.showImages()\n    this.flag = true\n  &#125;,\n\n  stop () &#123;\n    this.flag = false\n    clearInterval(this.interval)\n  &#125;,\n\n  readImages (imageFileName, _A) &#123;\n    this.stop()\n    let req = require.context(&quot;@/../static/images&quot;, true, /\\.(?:bmp|jpg|gif|jpeg|png)$/).keys();\n    let path = new RegExp(imageFileName[_A])\n    req.forEach(item =&gt; &#123;\n      if (path.test(item)) &#123;\n        this.imgUrls.push(&#123; img: &quot;@/../static/images/&quot; + imageFileName[_A] + item.substring(item.lastIndexOf(&#39;/&#39;)) &#125;)\n      &#125;\n    &#125;)\n    this.showImages()\n  &#125;,\n  readdir (imageFileName) &#123;\n    this.imgUrls = []\n    for (let i = 0; i &lt; imageFileName.length; i++) &#123;\n      this.readImages(imageFileName, i)\n    &#125;\n  &#125;,\n\n  showImages (_B) &#123;\n    if (_B) this.imgUrls = this.imgUrlsSort(this.imgUrls, &#39;sort&#39;)\n    console.log(this.imgUrls)\n    this.interval = setInterval(this.setIntervalFun, this.frameRate)\n  &#125;,\n\n  imgUrlsSort (ary, key) &#123;\n    return ary.sort((a, b) =&gt; &#123;\n      let x = a[key];\n      let y = b[key];\n      return ((x &lt; y) ? -1 : (x &gt; y) ? 1 : 0)\n    &#125;)\n  &#125;,\n\n  setIntervalFun () &#123;\n    if (this.setIntervalNumber &gt;= this.imgUrls.length) &#123;\n      this.setIntervalNumber = 0\n    &#125;\n    this.imgsrc = this.imgUrls[this.setIntervalNumber++].img || &#39;&#39;\n  &#125;\n&#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>上述这么做已经实现了功能，但是目前来说是发现了两个问题</p>\n</li>\n</ul>\n<ol>\n<li>require.context() 这个API它的第一个参数不能用一个可变的值，比如变量，会有警告。</li>\n<li>上述代码一直更换图片的src实现的，也就是说每次换src时都会发送http请求获取图片,导致了内存不会被释放一直增加。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><ol>\n<li>传入一个数组，数组中放的是目录名称，通过本目录名称，读取文件目录下的所有图片，并循环播放，形成一个每1s播放多少张图片的效果，最后目录播放完毕后，在跳到第一个目录循环播放。</li>\n<li>核心: 用 webpack的一个API ==require.contex==读取目录下的文件名,具体想了解的可以查一查。</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><ul>\n<li><p>HTML</p>\n<pre><code class=\"html\">&lt;template&gt;\n&lt;div id=&quot;imgPlay&quot; ref=&quot;container&quot; :style=&quot;[style]&quot;&gt;\n  &lt;img :src=&quot;imgsrc&quot; :style=&quot;[&#123;height:style.height,width:style.width&#125;]&quot;&gt;\n  &lt;div id=&quot;but&quot;&gt;\n    &lt;button @click=&quot;start()&quot;&gt;开始&lt;/button&gt;\n    &lt;button @click=&quot;stop()&quot;&gt;停止&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n</li>\n<li><p>javascript</p>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\nname: &#39;ZxImgPlay&#39;,\ndata () &#123;\n  return &#123;\n    style:[\n      width:&quot;50px&quot;,\n      height:&quot;50px&quot;\n      ],\n    interval: null, // 定时器id\n    flag: true, // 定时器的开关\n    setIntervalNumber: 0, // 当前展示的图片下标\n    imgsrc: &quot;&quot;, // 要展示的图片路径\n    imgUrls: [], // 所有的图片路径\n    frameRate: 0 // 帧率\n  &#125;\n&#125;,\ncomputed: &#123;&#125;,\nwatch: &#123;&#125;,\ncreated () &#123; &#125;,\nmounted () &#123;\n  this.zxInit()\n&#125;,\nbeforeDestroy () &#123; &#125;,\n\nmethods: &#123;\n  zxInit () &#123;\n  // 这里的 this.DisplayParam 是公司内部的一套东西，混入的对象\n  // this.DisplayParam.frameRate 是一个数组[&quot;目录名1&quot;,&quot;目录名2&quot;]\n  // this.DisplayParam.imgUrls 是死图当没有目录的时候就用死图\n  // this.DisplayParam.frameRate 是传入的帧率\n    this.frameRate = this.DisplayParam.frameRate &amp;&amp; (1000 / this.DisplayParam.frameRate)\n    this.imgUrls = this.DisplayParam.imgUrls\n    this.DisplayParam.imageFileName != 0 ? this.readdir(this.DisplayParam.imageFileName) : this.showImages(true)\n  &#125;,\n\n  start () &#123;\n    if (this.flag) return\n    this.showImages()\n    this.flag = true\n  &#125;,\n\n  stop () &#123;\n    this.flag = false\n    clearInterval(this.interval)\n  &#125;,\n\n  readImages (imageFileName, _A) &#123;\n    this.stop()\n    let req = require.context(&quot;@/../static/images&quot;, true, /\\.(?:bmp|jpg|gif|jpeg|png)$/).keys();\n    let path = new RegExp(imageFileName[_A])\n    req.forEach(item =&gt; &#123;\n      if (path.test(item)) &#123;\n        this.imgUrls.push(&#123; img: &quot;@/../static/images/&quot; + imageFileName[_A] + item.substring(item.lastIndexOf(&#39;/&#39;)) &#125;)\n      &#125;\n    &#125;)\n    this.showImages()\n  &#125;,\n  readdir (imageFileName) &#123;\n    this.imgUrls = []\n    for (let i = 0; i &lt; imageFileName.length; i++) &#123;\n      this.readImages(imageFileName, i)\n    &#125;\n  &#125;,\n\n  showImages (_B) &#123;\n    if (_B) this.imgUrls = this.imgUrlsSort(this.imgUrls, &#39;sort&#39;)\n    console.log(this.imgUrls)\n    this.interval = setInterval(this.setIntervalFun, this.frameRate)\n  &#125;,\n\n  imgUrlsSort (ary, key) &#123;\n    return ary.sort((a, b) =&gt; &#123;\n      let x = a[key];\n      let y = b[key];\n      return ((x &lt; y) ? -1 : (x &gt; y) ? 1 : 0)\n    &#125;)\n  &#125;,\n\n  setIntervalFun () &#123;\n    if (this.setIntervalNumber &gt;= this.imgUrls.length) &#123;\n      this.setIntervalNumber = 0\n    &#125;\n    this.imgsrc = this.imgUrls[this.setIntervalNumber++].img || &#39;&#39;\n  &#125;\n&#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>上述这么做已经实现了功能，但是目前来说是发现了两个问题</p>\n</li>\n</ul>\n<ol>\n<li>require.context() 这个API它的第一个参数不能用一个可变的值，比如变量，会有警告。</li>\n<li>上述代码一直更换图片的src实现的，也就是说每次换src时都会发送http请求获取图片,导致了内存不会被释放一直增加。</li>\n</ol>\n"},{"title":"学习vue3-admin-elementPlus","date":"2023-03-01T07:59:12.487Z","_content":"\n# 官网链接\n> https://gitee.com/kailong110120130/vue-element-plus-admin\n----\n\n","source":"_posts/前端/vue/学习vue3-admin-elementPlus.md","raw":"---\ntitle: 学习vue3-admin-elementPlus\ndate: {{ date }}\ncategories:\n- 前端\n- vue\ntags:\n- 前端\n- vue\n- vue-admin-element-plus\n---\n\n# 官网链接\n> https://gitee.com/kailong110120130/vue-element-plus-admin\n----\n\n","slug":"前端/vue/学习vue3-admin-elementPlus","published":1,"updated":"2023-03-01T09:22:26.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc1000gawaffg083cy1","content":"<h1 id=\"官网链接\"><a href=\"#官网链接\" class=\"headerlink\" title=\"官网链接\"></a>官网链接</h1><blockquote>\n<p><a href=\"https://gitee.com/kailong110120130/vue-element-plus-admin\">https://gitee.com/kailong110120130/vue-element-plus-admin</a></p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"官网链接\"><a href=\"#官网链接\" class=\"headerlink\" title=\"官网链接\"></a>官网链接</h1><blockquote>\n<p><a href=\"https://gitee.com/kailong110120130/vue-element-plus-admin\">https://gitee.com/kailong110120130/vue-element-plus-admin</a></p>\n</blockquote>\n<hr>\n"},{"title":"js线程,事件级别,宿主对象","date":"2020-08-22T14:34:23.000Z","_content":"\n\n\n\n[TOC]\n\n\n\n### js为什么是单线程的\n\njs单线程指的是它在浏览器内核中的运行环境，js引擎是单线程的。\n\njs的主要用途是与用户互动和操作dom，如果是多线程的话，js会变的很复杂，比如多个线程同时操作同一个dom元素的话那么，浏览器已那个为标准？，所以js一出生就是单线程的\n\n### js和ECMAScript的关系\n\nECMAScript简写为ES,1997第一版，98第二版(无新功能)，2002ES3(添加正则等),ES4夭折，2009(ES5)，2015（**ES6** ，ES4研究的功能到ES6才发布），JavaScript遵从了ES标准\n\n### 工厂模式\n\n工厂模式指的是函数式声明，把创建类的逻辑封装到函数内部。\n\n举个例子：根据名字，年龄 创建一个人。\n\n那么为了方便起见，我们一般会创建一个函数描述人的特征，传入名字和年龄即可创建这个人。\n\n## 严格模式 \n\n在ES5中新增的指令，\n\n使用 'use strict' 即在严格的条件下运行代码。 \n\n1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n2. 消除代码运行的一些不安全之处，保证代码运行的安全；\n3. 提高编译器效率，增加运行速度；\n4. 为未来新版本的Javascript做好铺垫。\n5. 函数内部this的指向是undefined\n\n### 宿主对象 \n\n+ 内置对象:系统所提供的对象;如Object、Array、Math、Date等等 \n+ 宿主对象：JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document。 \n+ 自定义对象：自定义构造函数所创建的对象。 \n\n### dom事件级别\n\n+ dom事件级别有0，2，3三种标准\n  + 0级：同种类的事件只能定义一个事件，重复定义会被覆盖如，Element.onclick = function(){},\n  + 2级：出了事件的自定义可以绑定多个事件，element.addEventListener，且还有事件的冒泡捕获\n  + 3级：和2级语法一样，增加了很多事件，键盘事件，鼠标事件\n\n### 解构赋值\n\n```js\nconst obj = { name:'',age:12 }\nlet {name,age } = obj\n```\n\n### 展开运算符运算\n\n```js\nlet arr = []\nlet arr2 = []\nlet arr3 = [...arr,...arr3]\n```\n\n### 宏任务和微任务队列\n\n首先他们都是属于异步队列，定时器，io(读写)，ui交互事件会存放在宏任务中，Promise和async 会存放在微任务队列，微任务对列是优先于宏任务队列的。\n\n\n\n\n\n","source":"_posts/前端/原生js/js线程,事件级别,宿主对象.md","raw":"---\ntitle: js线程,事件级别,宿主对象\ndate: 2020-08-22 22:34:23\ncategories:\n- 前端\n- 原生js\ntags:\n- 前端\n- 原生js\n---\n\n\n\n\n[TOC]\n\n\n\n### js为什么是单线程的\n\njs单线程指的是它在浏览器内核中的运行环境，js引擎是单线程的。\n\njs的主要用途是与用户互动和操作dom，如果是多线程的话，js会变的很复杂，比如多个线程同时操作同一个dom元素的话那么，浏览器已那个为标准？，所以js一出生就是单线程的\n\n### js和ECMAScript的关系\n\nECMAScript简写为ES,1997第一版，98第二版(无新功能)，2002ES3(添加正则等),ES4夭折，2009(ES5)，2015（**ES6** ，ES4研究的功能到ES6才发布），JavaScript遵从了ES标准\n\n### 工厂模式\n\n工厂模式指的是函数式声明，把创建类的逻辑封装到函数内部。\n\n举个例子：根据名字，年龄 创建一个人。\n\n那么为了方便起见，我们一般会创建一个函数描述人的特征，传入名字和年龄即可创建这个人。\n\n## 严格模式 \n\n在ES5中新增的指令，\n\n使用 'use strict' 即在严格的条件下运行代码。 \n\n1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n2. 消除代码运行的一些不安全之处，保证代码运行的安全；\n3. 提高编译器效率，增加运行速度；\n4. 为未来新版本的Javascript做好铺垫。\n5. 函数内部this的指向是undefined\n\n### 宿主对象 \n\n+ 内置对象:系统所提供的对象;如Object、Array、Math、Date等等 \n+ 宿主对象：JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document。 \n+ 自定义对象：自定义构造函数所创建的对象。 \n\n### dom事件级别\n\n+ dom事件级别有0，2，3三种标准\n  + 0级：同种类的事件只能定义一个事件，重复定义会被覆盖如，Element.onclick = function(){},\n  + 2级：出了事件的自定义可以绑定多个事件，element.addEventListener，且还有事件的冒泡捕获\n  + 3级：和2级语法一样，增加了很多事件，键盘事件，鼠标事件\n\n### 解构赋值\n\n```js\nconst obj = { name:'',age:12 }\nlet {name,age } = obj\n```\n\n### 展开运算符运算\n\n```js\nlet arr = []\nlet arr2 = []\nlet arr3 = [...arr,...arr3]\n```\n\n### 宏任务和微任务队列\n\n首先他们都是属于异步队列，定时器，io(读写)，ui交互事件会存放在宏任务中，Promise和async 会存放在微任务队列，微任务对列是优先于宏任务队列的。\n\n\n\n\n\n","slug":"前端/原生js/js线程,事件级别,宿主对象","published":1,"updated":"2023-03-01T09:49:24.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc2000iawafh6cpczl4","content":"<p>[TOC]</p>\n<h3 id=\"js为什么是单线程的\"><a href=\"#js为什么是单线程的\" class=\"headerlink\" title=\"js为什么是单线程的\"></a>js为什么是单线程的</h3><p>js单线程指的是它在浏览器内核中的运行环境，js引擎是单线程的。</p>\n<p>js的主要用途是与用户互动和操作dom，如果是多线程的话，js会变的很复杂，比如多个线程同时操作同一个dom元素的话那么，浏览器已那个为标准？，所以js一出生就是单线程的</p>\n<h3 id=\"js和ECMAScript的关系\"><a href=\"#js和ECMAScript的关系\" class=\"headerlink\" title=\"js和ECMAScript的关系\"></a>js和ECMAScript的关系</h3><p>ECMAScript简写为ES,1997第一版，98第二版(无新功能)，2002ES3(添加正则等),ES4夭折，2009(ES5)，2015（<strong>ES6</strong> ，ES4研究的功能到ES6才发布），JavaScript遵从了ES标准</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式指的是函数式声明，把创建类的逻辑封装到函数内部。</p>\n<p>举个例子：根据名字，年龄 创建一个人。</p>\n<p>那么为了方便起见，我们一般会创建一个函数描述人的特征，传入名字和年龄即可创建这个人。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>在ES5中新增的指令，</p>\n<p>使用 ‘use strict’ 即在严格的条件下运行代码。 </p>\n<ol>\n<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的Javascript做好铺垫。</li>\n<li>函数内部this的指向是undefined</li>\n</ol>\n<h3 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h3><ul>\n<li>内置对象:系统所提供的对象;如Object、Array、Math、Date等等 </li>\n<li>宿主对象：JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document。 </li>\n<li>自定义对象：自定义构造函数所创建的对象。 </li>\n</ul>\n<h3 id=\"dom事件级别\"><a href=\"#dom事件级别\" class=\"headerlink\" title=\"dom事件级别\"></a>dom事件级别</h3><ul>\n<li>dom事件级别有0，2，3三种标准<ul>\n<li>0级：同种类的事件只能定义一个事件，重复定义会被覆盖如，Element.onclick = function(){},</li>\n<li>2级：出了事件的自定义可以绑定多个事件，element.addEventListener，且还有事件的冒泡捕获</li>\n<li>3级：和2级语法一样，增加了很多事件，键盘事件，鼠标事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><pre><code class=\"js\">const obj = &#123; name:&#39;&#39;,age:12 &#125;\nlet &#123;name,age &#125; = obj\n</code></pre>\n<h3 id=\"展开运算符运算\"><a href=\"#展开运算符运算\" class=\"headerlink\" title=\"展开运算符运算\"></a>展开运算符运算</h3><pre><code class=\"js\">let arr = []\nlet arr2 = []\nlet arr3 = [...arr,...arr3]\n</code></pre>\n<h3 id=\"宏任务和微任务队列\"><a href=\"#宏任务和微任务队列\" class=\"headerlink\" title=\"宏任务和微任务队列\"></a>宏任务和微任务队列</h3><p>首先他们都是属于异步队列，定时器，io(读写)，ui交互事件会存放在宏任务中，Promise和async 会存放在微任务队列，微任务对列是优先于宏任务队列的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h3 id=\"js为什么是单线程的\"><a href=\"#js为什么是单线程的\" class=\"headerlink\" title=\"js为什么是单线程的\"></a>js为什么是单线程的</h3><p>js单线程指的是它在浏览器内核中的运行环境，js引擎是单线程的。</p>\n<p>js的主要用途是与用户互动和操作dom，如果是多线程的话，js会变的很复杂，比如多个线程同时操作同一个dom元素的话那么，浏览器已那个为标准？，所以js一出生就是单线程的</p>\n<h3 id=\"js和ECMAScript的关系\"><a href=\"#js和ECMAScript的关系\" class=\"headerlink\" title=\"js和ECMAScript的关系\"></a>js和ECMAScript的关系</h3><p>ECMAScript简写为ES,1997第一版，98第二版(无新功能)，2002ES3(添加正则等),ES4夭折，2009(ES5)，2015（<strong>ES6</strong> ，ES4研究的功能到ES6才发布），JavaScript遵从了ES标准</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式指的是函数式声明，把创建类的逻辑封装到函数内部。</p>\n<p>举个例子：根据名字，年龄 创建一个人。</p>\n<p>那么为了方便起见，我们一般会创建一个函数描述人的特征，传入名字和年龄即可创建这个人。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>在ES5中新增的指令，</p>\n<p>使用 ‘use strict’ 即在严格的条件下运行代码。 </p>\n<ol>\n<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的Javascript做好铺垫。</li>\n<li>函数内部this的指向是undefined</li>\n</ol>\n<h3 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h3><ul>\n<li>内置对象:系统所提供的对象;如Object、Array、Math、Date等等 </li>\n<li>宿主对象：JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document。 </li>\n<li>自定义对象：自定义构造函数所创建的对象。 </li>\n</ul>\n<h3 id=\"dom事件级别\"><a href=\"#dom事件级别\" class=\"headerlink\" title=\"dom事件级别\"></a>dom事件级别</h3><ul>\n<li>dom事件级别有0，2，3三种标准<ul>\n<li>0级：同种类的事件只能定义一个事件，重复定义会被覆盖如，Element.onclick = function(){},</li>\n<li>2级：出了事件的自定义可以绑定多个事件，element.addEventListener，且还有事件的冒泡捕获</li>\n<li>3级：和2级语法一样，增加了很多事件，键盘事件，鼠标事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><pre><code class=\"js\">const obj = &#123; name:&#39;&#39;,age:12 &#125;\nlet &#123;name,age &#125; = obj\n</code></pre>\n<h3 id=\"展开运算符运算\"><a href=\"#展开运算符运算\" class=\"headerlink\" title=\"展开运算符运算\"></a>展开运算符运算</h3><pre><code class=\"js\">let arr = []\nlet arr2 = []\nlet arr3 = [...arr,...arr3]\n</code></pre>\n<h3 id=\"宏任务和微任务队列\"><a href=\"#宏任务和微任务队列\" class=\"headerlink\" title=\"宏任务和微任务队列\"></a>宏任务和微任务队列</h3><p>首先他们都是属于异步队列，定时器，io(读写)，ui交互事件会存放在宏任务中，Promise和async 会存放在微任务队列，微任务对列是优先于宏任务队列的。</p>\n"},{"title":"js不常见方法及属性","date":"2020-08-22T14:34:23.000Z","_content":"\n\n[TOC]\n\n## 方法\n\n### Object.keys()\n\n+ 返回值：一个表示给定对象的所有可枚举属性的字符串数组 。\n+ object.keys和 for in 的排序没有任何区别,for in还会枚举其原型链上的属性\n\n```js\nlet ogj = {\n    name:'zs',\n    age:18,\n}\nObject.keys(obj)  // ['name','age']\n\n\nlet arr = [a,b,c]\nObject.keys(arr)\t//[\"0\",\"1\",\"2\"]\n```\n\n### Object.values()\n\n+ 返回值：对象所有的values\n\n  \n\n### Array.from()\n\n+ 可以迭代一个可遍历的对象，并转为一个真正的数组\n\n  ```js\n  Arrray.from(obj) \n  ```\n\n### Object.is()\n\n+ 判断两个对象是否相等\n\n  ```js\n  Obejct.is(obj1,obj2) //相等为true,不等为false\n  ```\n\n### toString.call()\n\n+ 判断数据类型，对每一种数据类型都实用 \n\n  ```js\n  toString.call(数据)\n  ```\n\n### Array.of()\n\n+ 该方法的作用非常类似Array 构造器，但在\n  使用单个数值参数的时候并不会导致特殊结果\n\n  ```js\n  Array.of 基本上可以用来替代Array()或newArray()，并且不存在由于参数不同而导致的重\n  载，而且他们的行为非常统一\n  ```\n\n### startsWith()\n\n+ 匹配首个指定的字符，匹配到为true,没有为false\n\n  ```js\n  str.startsWith(\"字符\") //有这个字符为true \n  ```\n\n### includes()\n\n+ 匹配指定的值，匹配到为true,无则false，可用于数组和字符串\n\n  ```js\n  str.includes('a') \n  arr.includes('a') //找a这个元素 \n  ```\n\n### Object.assign ()\n\n+ Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 \n\n```js\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。\nvar target = { a: 1 };\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n### window.onerror\n\n+ 它是一个全局的异常处理函数，可以抓取所有的JavaScript异常。\n\n  ```\n  window.onerror = function(message, source, line, column, error) {\t\n  \t\n  }\n  ```\n\n\n### Object.setPrototypeOf()\n\n```js\n用来设置一个对象的原型链。\nObject.setPrototypeOf(a,b) //b 做为 a 的原形对象\n```\n\n### Object.hasOwnProperty()\n\n```js\nObject的hasOwnProperty() 方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n```\n\n\n### Reflect.has()\n```js\n检测目标对象是否有键值，深度检测，原型链有也会检测到\nReflect.has({x: 0}, \"x\"); // true\n```\n\n\n\n\n## 属性\n\n","source":"_posts/前端/原生js/js不常见方法及属性.md","raw":"---\ntitle: js不常见方法及属性\ndate: 2020-08-22 22:34:23\ncategories:\n- 前端\n- 原生js\ntags:\n- 前端\n- 原生js\n---\n\n\n[TOC]\n\n## 方法\n\n### Object.keys()\n\n+ 返回值：一个表示给定对象的所有可枚举属性的字符串数组 。\n+ object.keys和 for in 的排序没有任何区别,for in还会枚举其原型链上的属性\n\n```js\nlet ogj = {\n    name:'zs',\n    age:18,\n}\nObject.keys(obj)  // ['name','age']\n\n\nlet arr = [a,b,c]\nObject.keys(arr)\t//[\"0\",\"1\",\"2\"]\n```\n\n### Object.values()\n\n+ 返回值：对象所有的values\n\n  \n\n### Array.from()\n\n+ 可以迭代一个可遍历的对象，并转为一个真正的数组\n\n  ```js\n  Arrray.from(obj) \n  ```\n\n### Object.is()\n\n+ 判断两个对象是否相等\n\n  ```js\n  Obejct.is(obj1,obj2) //相等为true,不等为false\n  ```\n\n### toString.call()\n\n+ 判断数据类型，对每一种数据类型都实用 \n\n  ```js\n  toString.call(数据)\n  ```\n\n### Array.of()\n\n+ 该方法的作用非常类似Array 构造器，但在\n  使用单个数值参数的时候并不会导致特殊结果\n\n  ```js\n  Array.of 基本上可以用来替代Array()或newArray()，并且不存在由于参数不同而导致的重\n  载，而且他们的行为非常统一\n  ```\n\n### startsWith()\n\n+ 匹配首个指定的字符，匹配到为true,没有为false\n\n  ```js\n  str.startsWith(\"字符\") //有这个字符为true \n  ```\n\n### includes()\n\n+ 匹配指定的值，匹配到为true,无则false，可用于数组和字符串\n\n  ```js\n  str.includes('a') \n  arr.includes('a') //找a这个元素 \n  ```\n\n### Object.assign ()\n\n+ Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 \n\n```js\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。\nvar target = { a: 1 };\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n### window.onerror\n\n+ 它是一个全局的异常处理函数，可以抓取所有的JavaScript异常。\n\n  ```\n  window.onerror = function(message, source, line, column, error) {\t\n  \t\n  }\n  ```\n\n\n### Object.setPrototypeOf()\n\n```js\n用来设置一个对象的原型链。\nObject.setPrototypeOf(a,b) //b 做为 a 的原形对象\n```\n\n### Object.hasOwnProperty()\n\n```js\nObject的hasOwnProperty() 方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n```\n\n\n### Reflect.has()\n```js\n检测目标对象是否有键值，深度检测，原型链有也会检测到\nReflect.has({x: 0}, \"x\"); // true\n```\n\n\n\n\n## 属性\n\n","slug":"前端/原生js/js不常见方法及属性","published":1,"updated":"2023-03-01T09:50:48.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc3000mawafehn7266u","content":"<p>[TOC]</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a>Object.keys()</h3><ul>\n<li>返回值：一个表示给定对象的所有可枚举属性的字符串数组 。</li>\n<li>object.keys和 for in 的排序没有任何区别,for in还会枚举其原型链上的属性</li>\n</ul>\n<pre><code class=\"js\">let ogj = &#123;\n    name:&#39;zs&#39;,\n    age:18,\n&#125;\nObject.keys(obj)  // [&#39;name&#39;,&#39;age&#39;]\n\n\nlet arr = [a,b,c]\nObject.keys(arr)    //[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]\n</code></pre>\n<h3 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a>Object.values()</h3><ul>\n<li>返回值：对象所有的values</li>\n</ul>\n<h3 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h3><ul>\n<li><p>可以迭代一个可遍历的对象，并转为一个真正的数组</p>\n<pre><code class=\"js\">Arrray.from(obj) \n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h3><ul>\n<li><p>判断两个对象是否相等</p>\n<pre><code class=\"js\">Obejct.is(obj1,obj2) //相等为true,不等为false\n</code></pre>\n</li>\n</ul>\n<h3 id=\"toString-call\"><a href=\"#toString-call\" class=\"headerlink\" title=\"toString.call()\"></a>toString.call()</h3><ul>\n<li><p>判断数据类型，对每一种数据类型都实用 </p>\n<pre><code class=\"js\">toString.call(数据)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><ul>\n<li><p>该方法的作用非常类似Array 构造器，但在<br>使用单个数值参数的时候并不会导致特殊结果</p>\n<pre><code class=\"js\">Array.of 基本上可以用来替代Array()或newArray()，并且不存在由于参数不同而导致的重\n载，而且他们的行为非常统一\n</code></pre>\n</li>\n</ul>\n<h3 id=\"startsWith\"><a href=\"#startsWith\" class=\"headerlink\" title=\"startsWith()\"></a>startsWith()</h3><ul>\n<li><p>匹配首个指定的字符，匹配到为true,没有为false</p>\n<pre><code class=\"js\">str.startsWith(&quot;字符&quot;) //有这个字符为true \n</code></pre>\n</li>\n</ul>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes()\"></a>includes()</h3><ul>\n<li><p>匹配指定的值，匹配到为true,无则false，可用于数组和字符串</p>\n<pre><code class=\"js\">str.includes(&#39;a&#39;) \narr.includes(&#39;a&#39;) //找a这个元素 \n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign ()\"></a>Object.assign ()</h3><ul>\n<li>Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 </li>\n</ul>\n<pre><code class=\"js\">Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。\nvar target = &#123; a: 1 &#125;;\nvar source1 = &#123; b: 2 &#125;;\nvar source2 = &#123; c: 3 &#125;;\nObject.assign(target, source1, source2);\ntarget // &#123;a:1, b:2, c:3&#125;\n</code></pre>\n<h3 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h3><ul>\n<li><p>它是一个全局的异常处理函数，可以抓取所有的JavaScript异常。</p>\n<pre><code>window.onerror = function(message, source, line, column, error) &#123;    \n    \n&#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h3><pre><code class=\"js\">用来设置一个对象的原型链。\nObject.setPrototypeOf(a,b) //b 做为 a 的原形对象\n</code></pre>\n<h3 id=\"Object-hasOwnProperty\"><a href=\"#Object-hasOwnProperty\" class=\"headerlink\" title=\"Object.hasOwnProperty()\"></a>Object.hasOwnProperty()</h3><pre><code class=\"js\">Object的hasOwnProperty() 方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"Reflect-has\"><a href=\"#Reflect-has\" class=\"headerlink\" title=\"Reflect.has()\"></a>Reflect.has()</h3><pre><code class=\"js\">检测目标对象是否有键值，深度检测，原型链有也会检测到\nReflect.has(&#123;x: 0&#125;, &quot;x&quot;); // true\n</code></pre>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2>","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a>Object.keys()</h3><ul>\n<li>返回值：一个表示给定对象的所有可枚举属性的字符串数组 。</li>\n<li>object.keys和 for in 的排序没有任何区别,for in还会枚举其原型链上的属性</li>\n</ul>\n<pre><code class=\"js\">let ogj = &#123;\n    name:&#39;zs&#39;,\n    age:18,\n&#125;\nObject.keys(obj)  // [&#39;name&#39;,&#39;age&#39;]\n\n\nlet arr = [a,b,c]\nObject.keys(arr)    //[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]\n</code></pre>\n<h3 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a>Object.values()</h3><ul>\n<li>返回值：对象所有的values</li>\n</ul>\n<h3 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h3><ul>\n<li><p>可以迭代一个可遍历的对象，并转为一个真正的数组</p>\n<pre><code class=\"js\">Arrray.from(obj) \n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h3><ul>\n<li><p>判断两个对象是否相等</p>\n<pre><code class=\"js\">Obejct.is(obj1,obj2) //相等为true,不等为false\n</code></pre>\n</li>\n</ul>\n<h3 id=\"toString-call\"><a href=\"#toString-call\" class=\"headerlink\" title=\"toString.call()\"></a>toString.call()</h3><ul>\n<li><p>判断数据类型，对每一种数据类型都实用 </p>\n<pre><code class=\"js\">toString.call(数据)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><ul>\n<li><p>该方法的作用非常类似Array 构造器，但在<br>使用单个数值参数的时候并不会导致特殊结果</p>\n<pre><code class=\"js\">Array.of 基本上可以用来替代Array()或newArray()，并且不存在由于参数不同而导致的重\n载，而且他们的行为非常统一\n</code></pre>\n</li>\n</ul>\n<h3 id=\"startsWith\"><a href=\"#startsWith\" class=\"headerlink\" title=\"startsWith()\"></a>startsWith()</h3><ul>\n<li><p>匹配首个指定的字符，匹配到为true,没有为false</p>\n<pre><code class=\"js\">str.startsWith(&quot;字符&quot;) //有这个字符为true \n</code></pre>\n</li>\n</ul>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes()\"></a>includes()</h3><ul>\n<li><p>匹配指定的值，匹配到为true,无则false，可用于数组和字符串</p>\n<pre><code class=\"js\">str.includes(&#39;a&#39;) \narr.includes(&#39;a&#39;) //找a这个元素 \n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign ()\"></a>Object.assign ()</h3><ul>\n<li>Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 </li>\n</ul>\n<pre><code class=\"js\">Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。\nvar target = &#123; a: 1 &#125;;\nvar source1 = &#123; b: 2 &#125;;\nvar source2 = &#123; c: 3 &#125;;\nObject.assign(target, source1, source2);\ntarget // &#123;a:1, b:2, c:3&#125;\n</code></pre>\n<h3 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h3><ul>\n<li><p>它是一个全局的异常处理函数，可以抓取所有的JavaScript异常。</p>\n<pre><code>window.onerror = function(message, source, line, column, error) &#123;    \n    \n&#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h3><pre><code class=\"js\">用来设置一个对象的原型链。\nObject.setPrototypeOf(a,b) //b 做为 a 的原形对象\n</code></pre>\n<h3 id=\"Object-hasOwnProperty\"><a href=\"#Object-hasOwnProperty\" class=\"headerlink\" title=\"Object.hasOwnProperty()\"></a>Object.hasOwnProperty()</h3><pre><code class=\"js\">Object的hasOwnProperty() 方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"Reflect-has\"><a href=\"#Reflect-has\" class=\"headerlink\" title=\"Reflect.has()\"></a>Reflect.has()</h3><pre><code class=\"js\">检测目标对象是否有键值，深度检测，原型链有也会检测到\nReflect.has(&#123;x: 0&#125;, &quot;x&quot;); // true\n</code></pre>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2>"},{"title":"清除所有页面定时器","date":"2020-08-22T14:34:23.000Z","_content":"\n> 定时器的id是连续的，可以通过循环清除所有定时器\n\n```javascript\n function clerSettimeout(){\n   let id = setTimeout(() => {  }, 0);\n   while(id > 0){\n     window.clearTimeout(id)\n     id --;\n   }\n }\n```\n\n## 注意\n1. 页面开久了定时器会有误差。\n2. 重绘和event loop也是有关的，浏览器是 60Hz 的刷新率，每 16ms才会更新一次。\n3. 尽量使用 __setTimeout__ 来代替  __setInterval__ 。\n\n\n","source":"_posts/前端/原生js/清除所有页面定时器.md","raw":"---\ntitle: 清除所有页面定时器\ndate: 2020-08-22 22:34:23\ncategories:\n- 前端\n- 原生js\ntags:\n- 前端\n- 原生js\n---\n\n> 定时器的id是连续的，可以通过循环清除所有定时器\n\n```javascript\n function clerSettimeout(){\n   let id = setTimeout(() => {  }, 0);\n   while(id > 0){\n     window.clearTimeout(id)\n     id --;\n   }\n }\n```\n\n## 注意\n1. 页面开久了定时器会有误差。\n2. 重绘和event loop也是有关的，浏览器是 60Hz 的刷新率，每 16ms才会更新一次。\n3. 尽量使用 __setTimeout__ 来代替  __setInterval__ 。\n\n\n","slug":"前端/原生js/清除所有页面定时器","published":1,"updated":"2023-03-01T09:21:28.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc4000oawaf3a0h67dv","content":"<blockquote>\n<p>定时器的id是连续的，可以通过循环清除所有定时器</p>\n</blockquote>\n<pre><code class=\"javascript\"> function clerSettimeout()&#123;\n   let id = setTimeout(() =&gt; &#123;  &#125;, 0);\n   while(id &gt; 0)&#123;\n     window.clearTimeout(id)\n     id --;\n   &#125;\n &#125;\n</code></pre>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>页面开久了定时器会有误差。</li>\n<li>重绘和event loop也是有关的，浏览器是 60Hz 的刷新率，每 16ms才会更新一次。</li>\n<li>尽量使用 <strong>setTimeout</strong> 来代替  <strong>setInterval</strong> 。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>定时器的id是连续的，可以通过循环清除所有定时器</p>\n</blockquote>\n<pre><code class=\"javascript\"> function clerSettimeout()&#123;\n   let id = setTimeout(() =&gt; &#123;  &#125;, 0);\n   while(id &gt; 0)&#123;\n     window.clearTimeout(id)\n     id --;\n   &#125;\n &#125;\n</code></pre>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>页面开久了定时器会有误差。</li>\n<li>重绘和event loop也是有关的，浏览器是 60Hz 的刷新率，每 16ms才会更新一次。</li>\n<li>尽量使用 <strong>setTimeout</strong> 来代替  <strong>setInterval</strong> 。</li>\n</ol>\n"},{"title":"es6 Api总结","date":"2020-08-20T13:34:23.000Z","_content":"\n\n# 一.\n\n## 1.let和const\n\n1. 在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 \n2. ES6 的块级作用域必须有大括号 \n3. const声明一个只读的常量。一旦声明，常量的值就不能改变。只声明不赋值，就会报错。 \n4. `const`声明的常量，也与`let`一样不可重复声明。 \n5. `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。 \n6. `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 \n7. 如果真的想将对象冻结，应该使用`Object.freeze`方法。 \n8. const用来定义常量，一般常量使用大写\n9. 声明字符串的方式，内容中可以直接出现换行\n\n## 2.模板字符串\n\n’${变量名}哈哈哈哈哈‘\n\n## 3.箭头函数\n\n1. 改变this指向\n2. 不能作为构造实例化对象\n3. 不能使用arguments变量\n4. 箭头函数 适用与this无关的回调，数组的方法回调\n5. 箭头函数不适合与this有关的回调，事件回调，对象的方法\n\n，\n\n## 4.允许给函数参数赋值的初始值\n\n具有默认值的参数，一般位置都要靠后\n\n## 5.获取实参\n\nrest参数必须要放到最后\n\nfunction fn(a,b,...args){\n\n}\n\n## 6.扩展运算符\n\n【...】\n\n能将数组转换为逗号分隔的参数序列\n\n可以进行数组合并\n\n可以进行数组克隆\n\n将伪数组转为真正的数组\n\n##7.symbol基本使用\n\nsymbol的值是唯一的。\n\n不能与其他数据进行运算。\n\nlet s=Symbol();\n\nlet s2 = Symbol(\"hh\");\n\nlet s3  = Symbol.for(\"hh\")；\n\n作用是给对象添加属性和方法:\n\nlet youxi = {\n\n​\tname:\"狼人杀\",\n\n​\t[Symbol('day')] function(){\n\n​\t\tconsole.log(\"我可以发言\")\n\n​\t}\n\n[Symbol('zibao')]:function(){\n\n​\tconsole.log(\"我可以自爆\")\n\n​\t}\n\n}\n\nconsole.log(youxi)\n\n## 8.Symol的内置属性\n\n## 9.迭代器\n\n> 迭代器是一种接口(inerator),为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成便利操作。\n>\n> Iterator 接口指的是对象原型里的 Symbol 属性。\n\n+ **原理**\n  1. 创建一个指针对象，指向当前数据结构的起始位置。\n  2. 第一次调用的 next 方法，指针自动指向数据结构的第一个成员\n  3. 往后不断调用 next ，指针一直往后移动，知道最后一个成员。\n  4. 每次调用 next 都会返回一个包含 value 和 dome 属性的对象。\n\n\n\n\n\n## 10.生成器函数Generator \n\n> 一个函数一旦开始执行，就会运行到最后或遇到return时结束，运行期间不会有其它代码能够打断它，也不能从外部再传入值到函数体内，而 Generator  函数（生成器）可以使用 yield 暂停执行，使用 next 可继续执行。 \n>\n> Generator 不能写成箭头函数形式\n\n+ **语法**\n\n  ```js\n   function *genFun(){\n       代码1\n       yield 代码; // 遇到 yield 后暂时不执行，需要 next() 后才执行。\n   \t 代码2\n   }\n       \n       \n   let genObj = genFun();\n   genObj.next() // generator 函数需要使用 next() 执行\n  ```\n\n+ **yield**\n\n  ```js\n  1.传参\n  function *genFun(nub){\n      代码1\n      let a = yield // 接第二次 next(2) 时的参\n  \t代码2\n      return 4\n   }\n  \n  \n  let genObj = genFun(3)\n  let res1 = genObj.next(1) // 这里没办法传给 yield\n   res1 // { value:2,done:false } false 表示没有执行完毕\n  let res2 = genObj.next(2) // 传给 yield \n   res2 // { value:4,done:true } true 表示执行完毕,它的 value 依靠的是 return\n  ```\n\n+ **runner()**\n\n  ```js\n  runner(function *(){\n      let data1 = yield ajax\n      let data2 = yield ajax\n      let data3 = yield ajax\n      console.log(data1,data2,data3)\n  })\n  ```\n\n  \n\n## Promise\n\n> Promise 就是用来管理异步操作的，使异步操作没有多层嵌套，就像同步操作一样\n\n### promise的状态\n\n+ pending 待解决,等待\n+ fulfilled 成功\n+ rejected 失败\n\n```js\nconst p = new Promise((resolve,reject) => {\n\tresolve() //可以将状态改为 fulfilled\n    reject() //可以使当前状态改为 rejected\n    # promise的状态是一次性的，不可同时调用。\n})\n\nconsole.log(p) \n```\n\n### Promise的结果\n\n```js\nconst p = new Promise((resolve,reject) => {\n\tresolve('成功的结果')  //传递参数，改变当前promise对象的结果\n    reject('失败的结果')  // 失败的结果\n})\nconsole.log(p) \n```\n\n### Promise的方法\n\n\n\n> promise原型中的方法\n\n+ **1.then() **\n\n  ```js\n  p.then((value)=>{\n      value resolve 的参数\n      状态是 fulfilled 时的调用\n  },(err)=>{\n      err reject 的参数\n      状态是 rejected 时的调用,相当于catch()\n  }) \n  \n  then会返回一个新的promise，状态是 pending ,从而实现一个链式操作。\n  promise的状态不改变时不会执行then。\n  在then的成功回调函数中使用 return 可以将返回的 Promise 的状态改为 fulfilled ，如果代码出错则 rejected 。\n  ```\n\n\n+ **2.catch()**\n\n+ ```js\n1.当 promise 的状态为 rejected 时被执行\n  2.当 promise 执行体中出现代码错误执行\n  p.catch((reason)=>{\n      \n  })\n  ```\n  \n+ **3.finally()**\n\n  ```js\n  不管状态如何都会执行的操作\n  p.finally() 不接受任何参数，返回原来的值,这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n  ```\n\n+ **all()**\n\n  ```js\n  将多个 Promise 实例，包装成一个新的 Promise 实例，所有的都成功 p 返回的 Promise 的状态才会为 fulfillted,否则为 rejected\n  \n  p = Promise.all([p1,p2,p3]) 参数是数组，返回的也是一个数组，数组的每一项是每一个请求对应的结果。\n  ```\n\n+ **race()**\n\n  ```js\n  将多个 Promise 实例，包装成一个新的 Promise 实例，只要有一个实例率先改变状态 Promise 的状态就跟着改变,率先改变的 Promise 实例返回值就传递给p的回调函数\n  \n  p = Promise.race([p1,p2,p3]) \n  ```\n\n+ **allSettled()**\n\n    ```js\n  接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected 包装实例才会结束。\n  ```\n\n+ **any()**\n\n  ```js\n  接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只要有一个返回 fulfilled 状态，包装实例就会变成 fulfilled 如果所有的参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。\n  ```\n\n+ **resolve()**\n\n  ```js\n  将现有对象转为 Promise 对象\n  \n  Promise.resolve(参数)\n  \n  参数情况：\n  1.参数是 Promise 实例\n    不做任何修改，原封不动的返回这个实例\n    \n  2.参数是有then方法的对象\n    转为 Promise 对象，并立即执行 then() 方法。\n   \n  3.不具有 then() 或者 不是对象\n    转为 Promise 对象，状态为 resolved。\n    \n  4.不带有任何参数\n    直接返回 resolved 状态的 Promise 对象。\n  ```\n\n+ **reject()**\n\n  ```js\n  返回一个新的 Promise 实例，该实例状态为 rejected\n  \n  const p = Promise.reject('出错了')\n  p.then(null,function(){\n      出错\n  })\n  \n  它的参数会原封不动的作为 reject 的理由，变成后续方法的参数。\n  ```\n\n  \n\n\n\n\n\n\n\n## 12.set\n\nlet s = new Set();\n\nlet s2 = new Set(['1','2'])\n\n## 13.Map\n\nlet m = new Map()\n\nm.set('name','哈哈')\n\n## 14.class类\n\nclass 类名{\n\n​\tconstructor(){\n\n​\t\t\n\n​\t}\n\n}\n\n## 15.数组扩展\n\n对象方法扩展\n\n## 16.模块化\n\n防止命名冲突，代码复用，搞维护性\n\nexport  \n\nimport  \n\n暴露有三种语法\n\n解构赋值形式\n\n\n\n使用npm下载包来导入暴露模块化\n\n\n\n# ES7新特性\n\nincludes 方法查文档\n\n# ES8新特性\n\n\n\nasync 和 await\n\nasync函数：\n\n返回的结果是Promise的对象，对象的状态由函数内部的return决定\n\nawait表达式：要放在async函数中，async中可以没有await\n\n\n\n对象方法的扩展\n\n获取所有对象值\n\nObject.keys()\n\nObgect.entries()\n\n更多请查文档\n\n# ES9新特性\n\n对象的合并\n\n正则扩展命名捕获分组\n\n反向断言\n\n\n\n# ES10\n\n##1.Object.fromEntries 用来创建对象数组\n\n##2.字符串的扩展方法\n\nstr.trimStart()：清除尾部空白\n\nstr.trimEnd()：清除头部空白\n\n##3.数组方法：\n\nflat与 flatMap\n\n##4.用来获取Symbol的字符\n\nSymbol.prototype.description\n\nlet s = Symbol('1')\n\ns.description \n\n## 5.私有属性\n\nclass Person{\n\nname:\n\n/#age\n\n}\n\n可用方法访问\n\ninfo(){\n\n​\tthis.#age\n\n}\n\n## 6.Promise.allSettled\n\n返回的结果始终是成功的，根据返回结果来顶\n\nall() 会报错\n\n\n\n## 7.matchAll\n\n用来数据的批量提取\n\n ## 8.可选链接符\n\n?.判断当问号前面的属性存在的话执行.号后属性\n\n\n\n# ES11\n\n\n\n## 1.动态import\n\nimport('111.txt').then(module =>{module.111()})\n\n## 2.大整形\n\nlet n = 134\n\nBigInt(n)\n\n用于大数值运算\n\n\n\n## 3.globalThis.js\n\n全局对象，操作全局对象\n\n\n\n\n\n","source":"_posts/前端/原生js/es6 Api总结.md","raw":"---\ntitle: es6 Api总结\ndate: 2020-08-20 21:34:23\ncategories:\n- 前端\n- 原生js\ntags:\n- 前端\n- 原生js\n---\n\n\n# 一.\n\n## 1.let和const\n\n1. 在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 \n2. ES6 的块级作用域必须有大括号 \n3. const声明一个只读的常量。一旦声明，常量的值就不能改变。只声明不赋值，就会报错。 \n4. `const`声明的常量，也与`let`一样不可重复声明。 \n5. `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。 \n6. `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 \n7. 如果真的想将对象冻结，应该使用`Object.freeze`方法。 \n8. const用来定义常量，一般常量使用大写\n9. 声明字符串的方式，内容中可以直接出现换行\n\n## 2.模板字符串\n\n’${变量名}哈哈哈哈哈‘\n\n## 3.箭头函数\n\n1. 改变this指向\n2. 不能作为构造实例化对象\n3. 不能使用arguments变量\n4. 箭头函数 适用与this无关的回调，数组的方法回调\n5. 箭头函数不适合与this有关的回调，事件回调，对象的方法\n\n，\n\n## 4.允许给函数参数赋值的初始值\n\n具有默认值的参数，一般位置都要靠后\n\n## 5.获取实参\n\nrest参数必须要放到最后\n\nfunction fn(a,b,...args){\n\n}\n\n## 6.扩展运算符\n\n【...】\n\n能将数组转换为逗号分隔的参数序列\n\n可以进行数组合并\n\n可以进行数组克隆\n\n将伪数组转为真正的数组\n\n##7.symbol基本使用\n\nsymbol的值是唯一的。\n\n不能与其他数据进行运算。\n\nlet s=Symbol();\n\nlet s2 = Symbol(\"hh\");\n\nlet s3  = Symbol.for(\"hh\")；\n\n作用是给对象添加属性和方法:\n\nlet youxi = {\n\n​\tname:\"狼人杀\",\n\n​\t[Symbol('day')] function(){\n\n​\t\tconsole.log(\"我可以发言\")\n\n​\t}\n\n[Symbol('zibao')]:function(){\n\n​\tconsole.log(\"我可以自爆\")\n\n​\t}\n\n}\n\nconsole.log(youxi)\n\n## 8.Symol的内置属性\n\n## 9.迭代器\n\n> 迭代器是一种接口(inerator),为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成便利操作。\n>\n> Iterator 接口指的是对象原型里的 Symbol 属性。\n\n+ **原理**\n  1. 创建一个指针对象，指向当前数据结构的起始位置。\n  2. 第一次调用的 next 方法，指针自动指向数据结构的第一个成员\n  3. 往后不断调用 next ，指针一直往后移动，知道最后一个成员。\n  4. 每次调用 next 都会返回一个包含 value 和 dome 属性的对象。\n\n\n\n\n\n## 10.生成器函数Generator \n\n> 一个函数一旦开始执行，就会运行到最后或遇到return时结束，运行期间不会有其它代码能够打断它，也不能从外部再传入值到函数体内，而 Generator  函数（生成器）可以使用 yield 暂停执行，使用 next 可继续执行。 \n>\n> Generator 不能写成箭头函数形式\n\n+ **语法**\n\n  ```js\n   function *genFun(){\n       代码1\n       yield 代码; // 遇到 yield 后暂时不执行，需要 next() 后才执行。\n   \t 代码2\n   }\n       \n       \n   let genObj = genFun();\n   genObj.next() // generator 函数需要使用 next() 执行\n  ```\n\n+ **yield**\n\n  ```js\n  1.传参\n  function *genFun(nub){\n      代码1\n      let a = yield // 接第二次 next(2) 时的参\n  \t代码2\n      return 4\n   }\n  \n  \n  let genObj = genFun(3)\n  let res1 = genObj.next(1) // 这里没办法传给 yield\n   res1 // { value:2,done:false } false 表示没有执行完毕\n  let res2 = genObj.next(2) // 传给 yield \n   res2 // { value:4,done:true } true 表示执行完毕,它的 value 依靠的是 return\n  ```\n\n+ **runner()**\n\n  ```js\n  runner(function *(){\n      let data1 = yield ajax\n      let data2 = yield ajax\n      let data3 = yield ajax\n      console.log(data1,data2,data3)\n  })\n  ```\n\n  \n\n## Promise\n\n> Promise 就是用来管理异步操作的，使异步操作没有多层嵌套，就像同步操作一样\n\n### promise的状态\n\n+ pending 待解决,等待\n+ fulfilled 成功\n+ rejected 失败\n\n```js\nconst p = new Promise((resolve,reject) => {\n\tresolve() //可以将状态改为 fulfilled\n    reject() //可以使当前状态改为 rejected\n    # promise的状态是一次性的，不可同时调用。\n})\n\nconsole.log(p) \n```\n\n### Promise的结果\n\n```js\nconst p = new Promise((resolve,reject) => {\n\tresolve('成功的结果')  //传递参数，改变当前promise对象的结果\n    reject('失败的结果')  // 失败的结果\n})\nconsole.log(p) \n```\n\n### Promise的方法\n\n\n\n> promise原型中的方法\n\n+ **1.then() **\n\n  ```js\n  p.then((value)=>{\n      value resolve 的参数\n      状态是 fulfilled 时的调用\n  },(err)=>{\n      err reject 的参数\n      状态是 rejected 时的调用,相当于catch()\n  }) \n  \n  then会返回一个新的promise，状态是 pending ,从而实现一个链式操作。\n  promise的状态不改变时不会执行then。\n  在then的成功回调函数中使用 return 可以将返回的 Promise 的状态改为 fulfilled ，如果代码出错则 rejected 。\n  ```\n\n\n+ **2.catch()**\n\n+ ```js\n1.当 promise 的状态为 rejected 时被执行\n  2.当 promise 执行体中出现代码错误执行\n  p.catch((reason)=>{\n      \n  })\n  ```\n  \n+ **3.finally()**\n\n  ```js\n  不管状态如何都会执行的操作\n  p.finally() 不接受任何参数，返回原来的值,这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n  ```\n\n+ **all()**\n\n  ```js\n  将多个 Promise 实例，包装成一个新的 Promise 实例，所有的都成功 p 返回的 Promise 的状态才会为 fulfillted,否则为 rejected\n  \n  p = Promise.all([p1,p2,p3]) 参数是数组，返回的也是一个数组，数组的每一项是每一个请求对应的结果。\n  ```\n\n+ **race()**\n\n  ```js\n  将多个 Promise 实例，包装成一个新的 Promise 实例，只要有一个实例率先改变状态 Promise 的状态就跟着改变,率先改变的 Promise 实例返回值就传递给p的回调函数\n  \n  p = Promise.race([p1,p2,p3]) \n  ```\n\n+ **allSettled()**\n\n    ```js\n  接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected 包装实例才会结束。\n  ```\n\n+ **any()**\n\n  ```js\n  接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只要有一个返回 fulfilled 状态，包装实例就会变成 fulfilled 如果所有的参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。\n  ```\n\n+ **resolve()**\n\n  ```js\n  将现有对象转为 Promise 对象\n  \n  Promise.resolve(参数)\n  \n  参数情况：\n  1.参数是 Promise 实例\n    不做任何修改，原封不动的返回这个实例\n    \n  2.参数是有then方法的对象\n    转为 Promise 对象，并立即执行 then() 方法。\n   \n  3.不具有 then() 或者 不是对象\n    转为 Promise 对象，状态为 resolved。\n    \n  4.不带有任何参数\n    直接返回 resolved 状态的 Promise 对象。\n  ```\n\n+ **reject()**\n\n  ```js\n  返回一个新的 Promise 实例，该实例状态为 rejected\n  \n  const p = Promise.reject('出错了')\n  p.then(null,function(){\n      出错\n  })\n  \n  它的参数会原封不动的作为 reject 的理由，变成后续方法的参数。\n  ```\n\n  \n\n\n\n\n\n\n\n## 12.set\n\nlet s = new Set();\n\nlet s2 = new Set(['1','2'])\n\n## 13.Map\n\nlet m = new Map()\n\nm.set('name','哈哈')\n\n## 14.class类\n\nclass 类名{\n\n​\tconstructor(){\n\n​\t\t\n\n​\t}\n\n}\n\n## 15.数组扩展\n\n对象方法扩展\n\n## 16.模块化\n\n防止命名冲突，代码复用，搞维护性\n\nexport  \n\nimport  \n\n暴露有三种语法\n\n解构赋值形式\n\n\n\n使用npm下载包来导入暴露模块化\n\n\n\n# ES7新特性\n\nincludes 方法查文档\n\n# ES8新特性\n\n\n\nasync 和 await\n\nasync函数：\n\n返回的结果是Promise的对象，对象的状态由函数内部的return决定\n\nawait表达式：要放在async函数中，async中可以没有await\n\n\n\n对象方法的扩展\n\n获取所有对象值\n\nObject.keys()\n\nObgect.entries()\n\n更多请查文档\n\n# ES9新特性\n\n对象的合并\n\n正则扩展命名捕获分组\n\n反向断言\n\n\n\n# ES10\n\n##1.Object.fromEntries 用来创建对象数组\n\n##2.字符串的扩展方法\n\nstr.trimStart()：清除尾部空白\n\nstr.trimEnd()：清除头部空白\n\n##3.数组方法：\n\nflat与 flatMap\n\n##4.用来获取Symbol的字符\n\nSymbol.prototype.description\n\nlet s = Symbol('1')\n\ns.description \n\n## 5.私有属性\n\nclass Person{\n\nname:\n\n/#age\n\n}\n\n可用方法访问\n\ninfo(){\n\n​\tthis.#age\n\n}\n\n## 6.Promise.allSettled\n\n返回的结果始终是成功的，根据返回结果来顶\n\nall() 会报错\n\n\n\n## 7.matchAll\n\n用来数据的批量提取\n\n ## 8.可选链接符\n\n?.判断当问号前面的属性存在的话执行.号后属性\n\n\n\n# ES11\n\n\n\n## 1.动态import\n\nimport('111.txt').then(module =>{module.111()})\n\n## 2.大整形\n\nlet n = 134\n\nBigInt(n)\n\n用于大数值运算\n\n\n\n## 3.globalThis.js\n\n全局对象，操作全局对象\n\n\n\n\n\n","slug":"前端/原生js/es6 Api总结","published":1,"updated":"2023-03-01T09:45:18.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc5000sawaf35km0a5z","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一.\"></a>一.</h1><h2 id=\"1-let和const\"><a href=\"#1-let和const\" class=\"headerlink\" title=\"1.let和const\"></a>1.let和const</h2><ol>\n<li>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 </li>\n<li>ES6 的块级作用域必须有大括号 </li>\n<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。只声明不赋值，就会报错。 </li>\n<li><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。 </li>\n<li><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。 </li>\n<li><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 </li>\n<li>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。 </li>\n<li>const用来定义常量，一般常量使用大写</li>\n<li>声明字符串的方式，内容中可以直接出现换行</li>\n</ol>\n<h2 id=\"2-模板字符串\"><a href=\"#2-模板字符串\" class=\"headerlink\" title=\"2.模板字符串\"></a>2.模板字符串</h2><p>’${变量名}哈哈哈哈哈‘</p>\n<h2 id=\"3-箭头函数\"><a href=\"#3-箭头函数\" class=\"headerlink\" title=\"3.箭头函数\"></a>3.箭头函数</h2><ol>\n<li>改变this指向</li>\n<li>不能作为构造实例化对象</li>\n<li>不能使用arguments变量</li>\n<li>箭头函数 适用与this无关的回调，数组的方法回调</li>\n<li>箭头函数不适合与this有关的回调，事件回调，对象的方法</li>\n</ol>\n<p>，</p>\n<h2 id=\"4-允许给函数参数赋值的初始值\"><a href=\"#4-允许给函数参数赋值的初始值\" class=\"headerlink\" title=\"4.允许给函数参数赋值的初始值\"></a>4.允许给函数参数赋值的初始值</h2><p>具有默认值的参数，一般位置都要靠后</p>\n<h2 id=\"5-获取实参\"><a href=\"#5-获取实参\" class=\"headerlink\" title=\"5.获取实参\"></a>5.获取实参</h2><p>rest参数必须要放到最后</p>\n<p>function fn(a,b,…args){</p>\n<p>}</p>\n<h2 id=\"6-扩展运算符\"><a href=\"#6-扩展运算符\" class=\"headerlink\" title=\"6.扩展运算符\"></a>6.扩展运算符</h2><p>【…】</p>\n<p>能将数组转换为逗号分隔的参数序列</p>\n<p>可以进行数组合并</p>\n<p>可以进行数组克隆</p>\n<p>将伪数组转为真正的数组</p>\n<p>##7.symbol基本使用</p>\n<p>symbol的值是唯一的。</p>\n<p>不能与其他数据进行运算。</p>\n<p>let s=Symbol();</p>\n<p>let s2 = Symbol(“hh”);</p>\n<p>let s3  = Symbol.for(“hh”)；</p>\n<p>作用是给对象添加属性和方法:</p>\n<p>let youxi = {</p>\n<p>​    name:”狼人杀”,</p>\n<p>​    [Symbol(‘day’)] function(){</p>\n<p>​        console.log(“我可以发言”)</p>\n<p>​    }</p>\n<p>​    console.log(“我可以自爆”)</p>\n<p>​    }</p>\n<p>}</p>\n<p>console.log(youxi)</p>\n<h2 id=\"8-Symol的内置属性\"><a href=\"#8-Symol的内置属性\" class=\"headerlink\" title=\"8.Symol的内置属性\"></a>8.Symol的内置属性</h2><h2 id=\"9-迭代器\"><a href=\"#9-迭代器\" class=\"headerlink\" title=\"9.迭代器\"></a>9.迭代器</h2><blockquote>\n<p>迭代器是一种接口(inerator),为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成便利操作。</p>\n<p>Iterator 接口指的是对象原型里的 Symbol 属性。</p>\n</blockquote>\n<ul>\n<li><strong>原理</strong><ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置。</li>\n<li>第一次调用的 next 方法，指针自动指向数据结构的第一个成员</li>\n<li>往后不断调用 next ，指针一直往后移动，知道最后一个成员。</li>\n<li>每次调用 next 都会返回一个包含 value 和 dome 属性的对象。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"10-生成器函数Generator\"><a href=\"#10-生成器函数Generator\" class=\"headerlink\" title=\"10.生成器函数Generator\"></a>10.生成器函数Generator</h2><blockquote>\n<p>一个函数一旦开始执行，就会运行到最后或遇到return时结束，运行期间不会有其它代码能够打断它，也不能从外部再传入值到函数体内，而 Generator  函数（生成器）可以使用 yield 暂停执行，使用 next 可继续执行。 </p>\n<p>Generator 不能写成箭头函数形式</p>\n</blockquote>\n<ul>\n<li><p><strong>语法</strong></p>\n<pre><code class=\"js\"> function *genFun()&#123;\n     代码1\n     yield 代码; // 遇到 yield 后暂时不执行，需要 next() 后才执行。\n      代码2\n &#125;\n     \n     \n let genObj = genFun();\n genObj.next() // generator 函数需要使用 next() 执行\n</code></pre>\n</li>\n<li><p><strong>yield</strong></p>\n<pre><code class=\"js\">1.传参\nfunction *genFun(nub)&#123;\n    代码1\n    let a = yield // 接第二次 next(2) 时的参\n    代码2\n    return 4\n &#125;\n\n\nlet genObj = genFun(3)\nlet res1 = genObj.next(1) // 这里没办法传给 yield\n res1 // &#123; value:2,done:false &#125; false 表示没有执行完毕\nlet res2 = genObj.next(2) // 传给 yield \n res2 // &#123; value:4,done:true &#125; true 表示执行完毕,它的 value 依靠的是 return\n</code></pre>\n</li>\n<li><p><strong>runner()</strong></p>\n<pre><code class=\"js\">runner(function *()&#123;\n    let data1 = yield ajax\n    let data2 = yield ajax\n    let data3 = yield ajax\n    console.log(data1,data2,data3)\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><blockquote>\n<p>Promise 就是用来管理异步操作的，使异步操作没有多层嵌套，就像同步操作一样</p>\n</blockquote>\n<h3 id=\"promise的状态\"><a href=\"#promise的状态\" class=\"headerlink\" title=\"promise的状态\"></a>promise的状态</h3><ul>\n<li>pending 待解决,等待</li>\n<li>fulfilled 成功</li>\n<li>rejected 失败</li>\n</ul>\n<pre><code class=\"js\">const p = new Promise((resolve,reject) =&gt; &#123;\n    resolve() //可以将状态改为 fulfilled\n    reject() //可以使当前状态改为 rejected\n    # promise的状态是一次性的，不可同时调用。\n&#125;)\n\nconsole.log(p) \n</code></pre>\n<h3 id=\"Promise的结果\"><a href=\"#Promise的结果\" class=\"headerlink\" title=\"Promise的结果\"></a>Promise的结果</h3><pre><code class=\"js\">const p = new Promise((resolve,reject) =&gt; &#123;\n    resolve(&#39;成功的结果&#39;)  //传递参数，改变当前promise对象的结果\n    reject(&#39;失败的结果&#39;)  // 失败的结果\n&#125;)\nconsole.log(p) \n</code></pre>\n<h3 id=\"Promise的方法\"><a href=\"#Promise的方法\" class=\"headerlink\" title=\"Promise的方法\"></a>Promise的方法</h3><blockquote>\n<p>promise原型中的方法</p>\n</blockquote>\n<ul>\n<li><p>**1.then() **</p>\n<pre><code class=\"js\">p.then((value)=&gt;&#123;\n    value resolve 的参数\n    状态是 fulfilled 时的调用\n&#125;,(err)=&gt;&#123;\n    err reject 的参数\n    状态是 rejected 时的调用,相当于catch()\n&#125;) \n\nthen会返回一个新的promise，状态是 pending ,从而实现一个链式操作。\npromise的状态不改变时不会执行then。\n在then的成功回调函数中使用 return 可以将返回的 Promise 的状态改为 fulfilled ，如果代码出错则 rejected 。\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><strong>2.catch()</strong></p>\n</li>\n<li><p>```js</p>\n</li>\n</ul>\n<p>1.当 promise 的状态为 rejected 时被执行<br>  2.当 promise 执行体中出现代码错误执行<br>  p.catch((reason)=&gt;{</p>\n<p>  })</p>\n<pre><code>\n+ **3.finally()**\n\n```js\n不管状态如何都会执行的操作\np.finally() 不接受任何参数，返回原来的值,这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n</code></pre>\n<ul>\n<li><p><strong>all()</strong></p>\n<pre><code class=\"js\">将多个 Promise 实例，包装成一个新的 Promise 实例，所有的都成功 p 返回的 Promise 的状态才会为 fulfillted,否则为 rejected\n\np = Promise.all([p1,p2,p3]) 参数是数组，返回的也是一个数组，数组的每一项是每一个请求对应的结果。\n</code></pre>\n</li>\n<li><p><strong>race()</strong></p>\n<pre><code class=\"js\">将多个 Promise 实例，包装成一个新的 Promise 实例，只要有一个实例率先改变状态 Promise 的状态就跟着改变,率先改变的 Promise 实例返回值就传递给p的回调函数\n\np = Promise.race([p1,p2,p3]) \n</code></pre>\n</li>\n<li><p><strong>allSettled()</strong></p>\n<pre><code class=\"js\">接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected 包装实例才会结束。\n</code></pre>\n</li>\n<li><p><strong>any()</strong></p>\n<pre><code class=\"js\">接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只要有一个返回 fulfilled 状态，包装实例就会变成 fulfilled 如果所有的参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。\n</code></pre>\n</li>\n<li><p><strong>resolve()</strong></p>\n<pre><code class=\"js\">将现有对象转为 Promise 对象\n\nPromise.resolve(参数)\n\n参数情况：\n1.参数是 Promise 实例\n  不做任何修改，原封不动的返回这个实例\n  \n2.参数是有then方法的对象\n  转为 Promise 对象，并立即执行 then() 方法。\n \n3.不具有 then() 或者 不是对象\n  转为 Promise 对象，状态为 resolved。\n  \n4.不带有任何参数\n  直接返回 resolved 状态的 Promise 对象。\n</code></pre>\n</li>\n<li><p><strong>reject()</strong></p>\n<pre><code class=\"js\">返回一个新的 Promise 实例，该实例状态为 rejected\n\nconst p = Promise.reject(&#39;出错了&#39;)\np.then(null,function()&#123;\n    出错\n&#125;)\n\n它的参数会原封不动的作为 reject 的理由，变成后续方法的参数。\n</code></pre>\n</li>\n</ul>\n<h2 id=\"12-set\"><a href=\"#12-set\" class=\"headerlink\" title=\"12.set\"></a>12.set</h2><p>let s = new Set();</p>\n<p>let s2 = new Set([‘1’,’2’])</p>\n<h2 id=\"13-Map\"><a href=\"#13-Map\" class=\"headerlink\" title=\"13.Map\"></a>13.Map</h2><p>let m = new Map()</p>\n<p>m.set(‘name’,’哈哈’)</p>\n<h2 id=\"14-class类\"><a href=\"#14-class类\" class=\"headerlink\" title=\"14.class类\"></a>14.class类</h2><p>class 类名{</p>\n<p>​    constructor(){</p>\n<p>​        </p>\n<p>​    }</p>\n<p>}</p>\n<h2 id=\"15-数组扩展\"><a href=\"#15-数组扩展\" class=\"headerlink\" title=\"15.数组扩展\"></a>15.数组扩展</h2><p>对象方法扩展</p>\n<h2 id=\"16-模块化\"><a href=\"#16-模块化\" class=\"headerlink\" title=\"16.模块化\"></a>16.模块化</h2><p>防止命名冲突，代码复用，搞维护性</p>\n<p>export  </p>\n<p>import  </p>\n<p>暴露有三种语法</p>\n<p>解构赋值形式</p>\n<p>使用npm下载包来导入暴露模块化</p>\n<h1 id=\"ES7新特性\"><a href=\"#ES7新特性\" class=\"headerlink\" title=\"ES7新特性\"></a>ES7新特性</h1><p>includes 方法查文档</p>\n<h1 id=\"ES8新特性\"><a href=\"#ES8新特性\" class=\"headerlink\" title=\"ES8新特性\"></a>ES8新特性</h1><p>async 和 await</p>\n<p>async函数：</p>\n<p>返回的结果是Promise的对象，对象的状态由函数内部的return决定</p>\n<p>await表达式：要放在async函数中，async中可以没有await</p>\n<p>对象方法的扩展</p>\n<p>获取所有对象值</p>\n<p>Object.keys()</p>\n<p>Obgect.entries()</p>\n<p>更多请查文档</p>\n<h1 id=\"ES9新特性\"><a href=\"#ES9新特性\" class=\"headerlink\" title=\"ES9新特性\"></a>ES9新特性</h1><p>对象的合并</p>\n<p>正则扩展命名捕获分组</p>\n<p>反向断言</p>\n<h1 id=\"ES10\"><a href=\"#ES10\" class=\"headerlink\" title=\"ES10\"></a>ES10</h1><p>##1.Object.fromEntries 用来创建对象数组</p>\n<p>##2.字符串的扩展方法</p>\n<p>str.trimStart()：清除尾部空白</p>\n<p>str.trimEnd()：清除头部空白</p>\n<p>##3.数组方法：</p>\n<p>flat与 flatMap</p>\n<p>##4.用来获取Symbol的字符</p>\n<p>Symbol.prototype.description</p>\n<p>let s = Symbol(‘1’)</p>\n<p>s.description </p>\n<h2 id=\"5-私有属性\"><a href=\"#5-私有属性\" class=\"headerlink\" title=\"5.私有属性\"></a>5.私有属性</h2><p>class Person{</p>\n<p>name:</p>\n<p>/#age</p>\n<p>}</p>\n<p>可用方法访问</p>\n<p>info(){</p>\n<p>​    this.#age</p>\n<p>}</p>\n<h2 id=\"6-Promise-allSettled\"><a href=\"#6-Promise-allSettled\" class=\"headerlink\" title=\"6.Promise.allSettled\"></a>6.Promise.allSettled</h2><p>返回的结果始终是成功的，根据返回结果来顶</p>\n<p>all() 会报错</p>\n<h2 id=\"7-matchAll\"><a href=\"#7-matchAll\" class=\"headerlink\" title=\"7.matchAll\"></a>7.matchAll</h2><p>用来数据的批量提取</p>\n<h2 id=\"8-可选链接符\"><a href=\"#8-可选链接符\" class=\"headerlink\" title=\"8.可选链接符\"></a>8.可选链接符</h2><p>?.判断当问号前面的属性存在的话执行.号后属性</p>\n<h1 id=\"ES11\"><a href=\"#ES11\" class=\"headerlink\" title=\"ES11\"></a>ES11</h1><h2 id=\"1-动态import\"><a href=\"#1-动态import\" class=\"headerlink\" title=\"1.动态import\"></a>1.动态import</h2><p>import(‘111.txt’).then(module =&gt;{module.111()})</p>\n<h2 id=\"2-大整形\"><a href=\"#2-大整形\" class=\"headerlink\" title=\"2.大整形\"></a>2.大整形</h2><p>let n = 134</p>\n<p>BigInt(n)</p>\n<p>用于大数值运算</p>\n<h2 id=\"3-globalThis-js\"><a href=\"#3-globalThis-js\" class=\"headerlink\" title=\"3.globalThis.js\"></a>3.globalThis.js</h2><p>全局对象，操作全局对象</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一.\"></a>一.</h1><h2 id=\"1-let和const\"><a href=\"#1-let和const\" class=\"headerlink\" title=\"1.let和const\"></a>1.let和const</h2><ol>\n<li>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 </li>\n<li>ES6 的块级作用域必须有大括号 </li>\n<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。只声明不赋值，就会报错。 </li>\n<li><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。 </li>\n<li><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。 </li>\n<li><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 </li>\n<li>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。 </li>\n<li>const用来定义常量，一般常量使用大写</li>\n<li>声明字符串的方式，内容中可以直接出现换行</li>\n</ol>\n<h2 id=\"2-模板字符串\"><a href=\"#2-模板字符串\" class=\"headerlink\" title=\"2.模板字符串\"></a>2.模板字符串</h2><p>’${变量名}哈哈哈哈哈‘</p>\n<h2 id=\"3-箭头函数\"><a href=\"#3-箭头函数\" class=\"headerlink\" title=\"3.箭头函数\"></a>3.箭头函数</h2><ol>\n<li>改变this指向</li>\n<li>不能作为构造实例化对象</li>\n<li>不能使用arguments变量</li>\n<li>箭头函数 适用与this无关的回调，数组的方法回调</li>\n<li>箭头函数不适合与this有关的回调，事件回调，对象的方法</li>\n</ol>\n<p>，</p>\n<h2 id=\"4-允许给函数参数赋值的初始值\"><a href=\"#4-允许给函数参数赋值的初始值\" class=\"headerlink\" title=\"4.允许给函数参数赋值的初始值\"></a>4.允许给函数参数赋值的初始值</h2><p>具有默认值的参数，一般位置都要靠后</p>\n<h2 id=\"5-获取实参\"><a href=\"#5-获取实参\" class=\"headerlink\" title=\"5.获取实参\"></a>5.获取实参</h2><p>rest参数必须要放到最后</p>\n<p>function fn(a,b,…args){</p>\n<p>}</p>\n<h2 id=\"6-扩展运算符\"><a href=\"#6-扩展运算符\" class=\"headerlink\" title=\"6.扩展运算符\"></a>6.扩展运算符</h2><p>【…】</p>\n<p>能将数组转换为逗号分隔的参数序列</p>\n<p>可以进行数组合并</p>\n<p>可以进行数组克隆</p>\n<p>将伪数组转为真正的数组</p>\n<p>##7.symbol基本使用</p>\n<p>symbol的值是唯一的。</p>\n<p>不能与其他数据进行运算。</p>\n<p>let s=Symbol();</p>\n<p>let s2 = Symbol(“hh”);</p>\n<p>let s3  = Symbol.for(“hh”)；</p>\n<p>作用是给对象添加属性和方法:</p>\n<p>let youxi = {</p>\n<p>​    name:”狼人杀”,</p>\n<p>​    [Symbol(‘day’)] function(){</p>\n<p>​        console.log(“我可以发言”)</p>\n<p>​    }</p>\n<p>​    console.log(“我可以自爆”)</p>\n<p>​    }</p>\n<p>}</p>\n<p>console.log(youxi)</p>\n<h2 id=\"8-Symol的内置属性\"><a href=\"#8-Symol的内置属性\" class=\"headerlink\" title=\"8.Symol的内置属性\"></a>8.Symol的内置属性</h2><h2 id=\"9-迭代器\"><a href=\"#9-迭代器\" class=\"headerlink\" title=\"9.迭代器\"></a>9.迭代器</h2><blockquote>\n<p>迭代器是一种接口(inerator),为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成便利操作。</p>\n<p>Iterator 接口指的是对象原型里的 Symbol 属性。</p>\n</blockquote>\n<ul>\n<li><strong>原理</strong><ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置。</li>\n<li>第一次调用的 next 方法，指针自动指向数据结构的第一个成员</li>\n<li>往后不断调用 next ，指针一直往后移动，知道最后一个成员。</li>\n<li>每次调用 next 都会返回一个包含 value 和 dome 属性的对象。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"10-生成器函数Generator\"><a href=\"#10-生成器函数Generator\" class=\"headerlink\" title=\"10.生成器函数Generator\"></a>10.生成器函数Generator</h2><blockquote>\n<p>一个函数一旦开始执行，就会运行到最后或遇到return时结束，运行期间不会有其它代码能够打断它，也不能从外部再传入值到函数体内，而 Generator  函数（生成器）可以使用 yield 暂停执行，使用 next 可继续执行。 </p>\n<p>Generator 不能写成箭头函数形式</p>\n</blockquote>\n<ul>\n<li><p><strong>语法</strong></p>\n<pre><code class=\"js\"> function *genFun()&#123;\n     代码1\n     yield 代码; // 遇到 yield 后暂时不执行，需要 next() 后才执行。\n      代码2\n &#125;\n     \n     \n let genObj = genFun();\n genObj.next() // generator 函数需要使用 next() 执行\n</code></pre>\n</li>\n<li><p><strong>yield</strong></p>\n<pre><code class=\"js\">1.传参\nfunction *genFun(nub)&#123;\n    代码1\n    let a = yield // 接第二次 next(2) 时的参\n    代码2\n    return 4\n &#125;\n\n\nlet genObj = genFun(3)\nlet res1 = genObj.next(1) // 这里没办法传给 yield\n res1 // &#123; value:2,done:false &#125; false 表示没有执行完毕\nlet res2 = genObj.next(2) // 传给 yield \n res2 // &#123; value:4,done:true &#125; true 表示执行完毕,它的 value 依靠的是 return\n</code></pre>\n</li>\n<li><p><strong>runner()</strong></p>\n<pre><code class=\"js\">runner(function *()&#123;\n    let data1 = yield ajax\n    let data2 = yield ajax\n    let data3 = yield ajax\n    console.log(data1,data2,data3)\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><blockquote>\n<p>Promise 就是用来管理异步操作的，使异步操作没有多层嵌套，就像同步操作一样</p>\n</blockquote>\n<h3 id=\"promise的状态\"><a href=\"#promise的状态\" class=\"headerlink\" title=\"promise的状态\"></a>promise的状态</h3><ul>\n<li>pending 待解决,等待</li>\n<li>fulfilled 成功</li>\n<li>rejected 失败</li>\n</ul>\n<pre><code class=\"js\">const p = new Promise((resolve,reject) =&gt; &#123;\n    resolve() //可以将状态改为 fulfilled\n    reject() //可以使当前状态改为 rejected\n    # promise的状态是一次性的，不可同时调用。\n&#125;)\n\nconsole.log(p) \n</code></pre>\n<h3 id=\"Promise的结果\"><a href=\"#Promise的结果\" class=\"headerlink\" title=\"Promise的结果\"></a>Promise的结果</h3><pre><code class=\"js\">const p = new Promise((resolve,reject) =&gt; &#123;\n    resolve(&#39;成功的结果&#39;)  //传递参数，改变当前promise对象的结果\n    reject(&#39;失败的结果&#39;)  // 失败的结果\n&#125;)\nconsole.log(p) \n</code></pre>\n<h3 id=\"Promise的方法\"><a href=\"#Promise的方法\" class=\"headerlink\" title=\"Promise的方法\"></a>Promise的方法</h3><blockquote>\n<p>promise原型中的方法</p>\n</blockquote>\n<ul>\n<li><p>**1.then() **</p>\n<pre><code class=\"js\">p.then((value)=&gt;&#123;\n    value resolve 的参数\n    状态是 fulfilled 时的调用\n&#125;,(err)=&gt;&#123;\n    err reject 的参数\n    状态是 rejected 时的调用,相当于catch()\n&#125;) \n\nthen会返回一个新的promise，状态是 pending ,从而实现一个链式操作。\npromise的状态不改变时不会执行then。\n在then的成功回调函数中使用 return 可以将返回的 Promise 的状态改为 fulfilled ，如果代码出错则 rejected 。\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><strong>2.catch()</strong></p>\n</li>\n<li><p>```js</p>\n</li>\n</ul>\n<p>1.当 promise 的状态为 rejected 时被执行<br>  2.当 promise 执行体中出现代码错误执行<br>  p.catch((reason)=&gt;{</p>\n<p>  })</p>\n<pre><code>\n+ **3.finally()**\n\n```js\n不管状态如何都会执行的操作\np.finally() 不接受任何参数，返回原来的值,这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n</code></pre>\n<ul>\n<li><p><strong>all()</strong></p>\n<pre><code class=\"js\">将多个 Promise 实例，包装成一个新的 Promise 实例，所有的都成功 p 返回的 Promise 的状态才会为 fulfillted,否则为 rejected\n\np = Promise.all([p1,p2,p3]) 参数是数组，返回的也是一个数组，数组的每一项是每一个请求对应的结果。\n</code></pre>\n</li>\n<li><p><strong>race()</strong></p>\n<pre><code class=\"js\">将多个 Promise 实例，包装成一个新的 Promise 实例，只要有一个实例率先改变状态 Promise 的状态就跟着改变,率先改变的 Promise 实例返回值就传递给p的回调函数\n\np = Promise.race([p1,p2,p3]) \n</code></pre>\n</li>\n<li><p><strong>allSettled()</strong></p>\n<pre><code class=\"js\">接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected 包装实例才会结束。\n</code></pre>\n</li>\n<li><p><strong>any()</strong></p>\n<pre><code class=\"js\">接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只要有一个返回 fulfilled 状态，包装实例就会变成 fulfilled 如果所有的参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。\n</code></pre>\n</li>\n<li><p><strong>resolve()</strong></p>\n<pre><code class=\"js\">将现有对象转为 Promise 对象\n\nPromise.resolve(参数)\n\n参数情况：\n1.参数是 Promise 实例\n  不做任何修改，原封不动的返回这个实例\n  \n2.参数是有then方法的对象\n  转为 Promise 对象，并立即执行 then() 方法。\n \n3.不具有 then() 或者 不是对象\n  转为 Promise 对象，状态为 resolved。\n  \n4.不带有任何参数\n  直接返回 resolved 状态的 Promise 对象。\n</code></pre>\n</li>\n<li><p><strong>reject()</strong></p>\n<pre><code class=\"js\">返回一个新的 Promise 实例，该实例状态为 rejected\n\nconst p = Promise.reject(&#39;出错了&#39;)\np.then(null,function()&#123;\n    出错\n&#125;)\n\n它的参数会原封不动的作为 reject 的理由，变成后续方法的参数。\n</code></pre>\n</li>\n</ul>\n<h2 id=\"12-set\"><a href=\"#12-set\" class=\"headerlink\" title=\"12.set\"></a>12.set</h2><p>let s = new Set();</p>\n<p>let s2 = new Set([‘1’,’2’])</p>\n<h2 id=\"13-Map\"><a href=\"#13-Map\" class=\"headerlink\" title=\"13.Map\"></a>13.Map</h2><p>let m = new Map()</p>\n<p>m.set(‘name’,’哈哈’)</p>\n<h2 id=\"14-class类\"><a href=\"#14-class类\" class=\"headerlink\" title=\"14.class类\"></a>14.class类</h2><p>class 类名{</p>\n<p>​    constructor(){</p>\n<p>​        </p>\n<p>​    }</p>\n<p>}</p>\n<h2 id=\"15-数组扩展\"><a href=\"#15-数组扩展\" class=\"headerlink\" title=\"15.数组扩展\"></a>15.数组扩展</h2><p>对象方法扩展</p>\n<h2 id=\"16-模块化\"><a href=\"#16-模块化\" class=\"headerlink\" title=\"16.模块化\"></a>16.模块化</h2><p>防止命名冲突，代码复用，搞维护性</p>\n<p>export  </p>\n<p>import  </p>\n<p>暴露有三种语法</p>\n<p>解构赋值形式</p>\n<p>使用npm下载包来导入暴露模块化</p>\n<h1 id=\"ES7新特性\"><a href=\"#ES7新特性\" class=\"headerlink\" title=\"ES7新特性\"></a>ES7新特性</h1><p>includes 方法查文档</p>\n<h1 id=\"ES8新特性\"><a href=\"#ES8新特性\" class=\"headerlink\" title=\"ES8新特性\"></a>ES8新特性</h1><p>async 和 await</p>\n<p>async函数：</p>\n<p>返回的结果是Promise的对象，对象的状态由函数内部的return决定</p>\n<p>await表达式：要放在async函数中，async中可以没有await</p>\n<p>对象方法的扩展</p>\n<p>获取所有对象值</p>\n<p>Object.keys()</p>\n<p>Obgect.entries()</p>\n<p>更多请查文档</p>\n<h1 id=\"ES9新特性\"><a href=\"#ES9新特性\" class=\"headerlink\" title=\"ES9新特性\"></a>ES9新特性</h1><p>对象的合并</p>\n<p>正则扩展命名捕获分组</p>\n<p>反向断言</p>\n<h1 id=\"ES10\"><a href=\"#ES10\" class=\"headerlink\" title=\"ES10\"></a>ES10</h1><p>##1.Object.fromEntries 用来创建对象数组</p>\n<p>##2.字符串的扩展方法</p>\n<p>str.trimStart()：清除尾部空白</p>\n<p>str.trimEnd()：清除头部空白</p>\n<p>##3.数组方法：</p>\n<p>flat与 flatMap</p>\n<p>##4.用来获取Symbol的字符</p>\n<p>Symbol.prototype.description</p>\n<p>let s = Symbol(‘1’)</p>\n<p>s.description </p>\n<h2 id=\"5-私有属性\"><a href=\"#5-私有属性\" class=\"headerlink\" title=\"5.私有属性\"></a>5.私有属性</h2><p>class Person{</p>\n<p>name:</p>\n<p>/#age</p>\n<p>}</p>\n<p>可用方法访问</p>\n<p>info(){</p>\n<p>​    this.#age</p>\n<p>}</p>\n<h2 id=\"6-Promise-allSettled\"><a href=\"#6-Promise-allSettled\" class=\"headerlink\" title=\"6.Promise.allSettled\"></a>6.Promise.allSettled</h2><p>返回的结果始终是成功的，根据返回结果来顶</p>\n<p>all() 会报错</p>\n<h2 id=\"7-matchAll\"><a href=\"#7-matchAll\" class=\"headerlink\" title=\"7.matchAll\"></a>7.matchAll</h2><p>用来数据的批量提取</p>\n<h2 id=\"8-可选链接符\"><a href=\"#8-可选链接符\" class=\"headerlink\" title=\"8.可选链接符\"></a>8.可选链接符</h2><p>?.判断当问号前面的属性存在的话执行.号后属性</p>\n<h1 id=\"ES11\"><a href=\"#ES11\" class=\"headerlink\" title=\"ES11\"></a>ES11</h1><h2 id=\"1-动态import\"><a href=\"#1-动态import\" class=\"headerlink\" title=\"1.动态import\"></a>1.动态import</h2><p>import(‘111.txt’).then(module =&gt;{module.111()})</p>\n<h2 id=\"2-大整形\"><a href=\"#2-大整形\" class=\"headerlink\" title=\"2.大整形\"></a>2.大整形</h2><p>let n = 134</p>\n<p>BigInt(n)</p>\n<p>用于大数值运算</p>\n<h2 id=\"3-globalThis-js\"><a href=\"#3-globalThis-js\" class=\"headerlink\" title=\"3.globalThis.js\"></a>3.globalThis.js</h2><p>全局对象，操作全局对象</p>\n"},{"title":"正则-01","date":"2019-04-02T11:41:48.000Z","_content":"\n\n\n[TOC]\n\n# 正则\n\n> 依赖于一个语言环境，比原生的 jsApi 更灵活,专门来验证特定字符串，或取一些内容，正则表达式是一个复杂数据类型。\n\n### 创建\n\n1. __字面量创建__\n\n   ```javascript\n   // 声明的为正则\n   test() 检测一个字符串是否匹配某个模式,返回的是布尔值\n   exec() 获取符合规则的字符串,没有为null\n   \n   let str = 'houddd'\n   reg.test(str)\n   reg.exec(str)\n   ```\n\n   + __缺点__\n     1. 不可放在 __/ /__ 中放变量，可在 __eval()__ 方法中用 __${变量名}__解决。\n\n2. __new创建__\n\n   ```javascript\n   let reg = new RegExp('u','g')\n   reg.test(str)\n   ```\n\n### 选择符\n\n```js\n1. /u|a/  | 或者\n```\n\n### 元字表或元字组\n\n```js\n1. () 一个整体\n\t\n2. [] \n\t一个整体，里面自带 | 功能\n\t[abcd]  = a|b|c|d\n\n3. | \n\t或 (abc|dfe) \n\n4. [^] \n    取反，表示不是里面的任意一个就可以 [^abcd]\n\t当 . 出现在 [.] 中，它表示单纯的点文本\n\n5. (?:) \n\t匹配一个整体但不捕获\n\n6. - \t\n    表示从那一个字符到哪一个字符，前提是ASCII码值需要连接 [a-z]\n\n```\n\n### 转义\n\n```js\n1. \\ 为转义\n2. \\\\ 双转义\n```\n\n### 字符边界\n\n```js\n1. ^ 开始\n2. $ 结束\n```\n\n### 元字符\n\n1. /d 匹配数字\n2. /D 匹配非数字\n3. /s 匹配空白\n4. /S 非空格\n5. /w 字母数字下划线\n6. /W 除了字母数字下划线\n7. .  除了换行之外的任何字符\n8.  /t 匹配一个制表符，一个tab就是一个制表符\n9. s　视为单行匹配\n10. g 全局匹配\n11. i 忽略大小写\n12. y 粘性全局（每一次捕获的索引必须是连贯的）\n13. +表示出现1--n次\n14. *表示出现0--n次\n15. ？表示出现0--1次\n16. {n} 出现指定次数\n17. {n,x} 从 n -- x 次\n18.  {2,} 从 2 -- n次\n\n### 贪婪和非贪婪\n\n> 使用限定元字符时\n>\n> 贪婪：会捕获到最大长度\n>\n> 非贪婪：按照最小值捕获，在表达式后面加？\n\n### 正则预查\n\n+ 正向肯定预查\n\n  ```js\n  尽管前面相同，捕获后面必须写着指定的字符，而且还不需要指定的字符。\n  如：\n  \tlet reg = /ES(?=2015|2016)/\n      console.log(reg.exec('ES2015')) // 只要ES 没有后面的部分\n  ```\n\n+ 正向否定预查\n\n  ```js\n  和正向相反，后面匹配的是不要的字符。\n  \tlet reg = /ES(?!2015|2016)/\n      console.log(reg.exec('ES2015')) // 只要ES 没有后面的部分\n  ```\n\n+ 负向肯定预查\n\n  ```js\n  前面必须按照指定字符匹配，但是不需要，只要后面的字符\n  \tlet reg = /(?<=2015|2016)ES/\n      console.log(reg.exec('2015ES')) // 只要ES 没有前面的部分\n  ```\n\n+ 负向否定预查\n\n  ```js\n  和负向肯定预查相反,前面除了指定的字符其它都可以匹配\n  \tlet reg = /(?<!2015|2016)ES/\n      console.log(reg.exec('2015ES')) // 只要ES 没有前面的部分\n  ```\n\n\n\n### 重复出现\n\n```js\n/num ：是一个正整数字，表示必须重复出现几次第一个可__被捕获__的 () 的内容\n如：\n\tlet reg = /([abcd])\\d+/1/\n    reg.test('a111a') //true\n\treg.test('a111b') // true\n\t\n```\n\n\n\n### 字符串方法配合正则\n\n```js\n1. replace(正则,要替换的内容)\n2. search(正则) // 如果匹配到则返回索引\n3. match(正则) // 查找到字符串内一个满足字符串片段的内容返回，和 exec 一样，如果是全局 g ,那么返回的是一个数组\n```\n\n### 正则匹配中文\n\n```js\n\\u 表示匹配中文，后面带上中文的 unicode 编码\n[\\u4e00-\\u9fa5]：表示任意一个中文字符\n```\n\n","source":"_posts/笔记/ocean/00-常用正则/00-note.md","raw":"---\ntitle: 正则-01\ndate: 2019-04-02 19:41:48\ncategories:\n- 笔记\n- 正则\ntags:\n- 前端\n- 正则\n---\n\n\n\n[TOC]\n\n# 正则\n\n> 依赖于一个语言环境，比原生的 jsApi 更灵活,专门来验证特定字符串，或取一些内容，正则表达式是一个复杂数据类型。\n\n### 创建\n\n1. __字面量创建__\n\n   ```javascript\n   // 声明的为正则\n   test() 检测一个字符串是否匹配某个模式,返回的是布尔值\n   exec() 获取符合规则的字符串,没有为null\n   \n   let str = 'houddd'\n   reg.test(str)\n   reg.exec(str)\n   ```\n\n   + __缺点__\n     1. 不可放在 __/ /__ 中放变量，可在 __eval()__ 方法中用 __${变量名}__解决。\n\n2. __new创建__\n\n   ```javascript\n   let reg = new RegExp('u','g')\n   reg.test(str)\n   ```\n\n### 选择符\n\n```js\n1. /u|a/  | 或者\n```\n\n### 元字表或元字组\n\n```js\n1. () 一个整体\n\t\n2. [] \n\t一个整体，里面自带 | 功能\n\t[abcd]  = a|b|c|d\n\n3. | \n\t或 (abc|dfe) \n\n4. [^] \n    取反，表示不是里面的任意一个就可以 [^abcd]\n\t当 . 出现在 [.] 中，它表示单纯的点文本\n\n5. (?:) \n\t匹配一个整体但不捕获\n\n6. - \t\n    表示从那一个字符到哪一个字符，前提是ASCII码值需要连接 [a-z]\n\n```\n\n### 转义\n\n```js\n1. \\ 为转义\n2. \\\\ 双转义\n```\n\n### 字符边界\n\n```js\n1. ^ 开始\n2. $ 结束\n```\n\n### 元字符\n\n1. /d 匹配数字\n2. /D 匹配非数字\n3. /s 匹配空白\n4. /S 非空格\n5. /w 字母数字下划线\n6. /W 除了字母数字下划线\n7. .  除了换行之外的任何字符\n8.  /t 匹配一个制表符，一个tab就是一个制表符\n9. s　视为单行匹配\n10. g 全局匹配\n11. i 忽略大小写\n12. y 粘性全局（每一次捕获的索引必须是连贯的）\n13. +表示出现1--n次\n14. *表示出现0--n次\n15. ？表示出现0--1次\n16. {n} 出现指定次数\n17. {n,x} 从 n -- x 次\n18.  {2,} 从 2 -- n次\n\n### 贪婪和非贪婪\n\n> 使用限定元字符时\n>\n> 贪婪：会捕获到最大长度\n>\n> 非贪婪：按照最小值捕获，在表达式后面加？\n\n### 正则预查\n\n+ 正向肯定预查\n\n  ```js\n  尽管前面相同，捕获后面必须写着指定的字符，而且还不需要指定的字符。\n  如：\n  \tlet reg = /ES(?=2015|2016)/\n      console.log(reg.exec('ES2015')) // 只要ES 没有后面的部分\n  ```\n\n+ 正向否定预查\n\n  ```js\n  和正向相反，后面匹配的是不要的字符。\n  \tlet reg = /ES(?!2015|2016)/\n      console.log(reg.exec('ES2015')) // 只要ES 没有后面的部分\n  ```\n\n+ 负向肯定预查\n\n  ```js\n  前面必须按照指定字符匹配，但是不需要，只要后面的字符\n  \tlet reg = /(?<=2015|2016)ES/\n      console.log(reg.exec('2015ES')) // 只要ES 没有前面的部分\n  ```\n\n+ 负向否定预查\n\n  ```js\n  和负向肯定预查相反,前面除了指定的字符其它都可以匹配\n  \tlet reg = /(?<!2015|2016)ES/\n      console.log(reg.exec('2015ES')) // 只要ES 没有前面的部分\n  ```\n\n\n\n### 重复出现\n\n```js\n/num ：是一个正整数字，表示必须重复出现几次第一个可__被捕获__的 () 的内容\n如：\n\tlet reg = /([abcd])\\d+/1/\n    reg.test('a111a') //true\n\treg.test('a111b') // true\n\t\n```\n\n\n\n### 字符串方法配合正则\n\n```js\n1. replace(正则,要替换的内容)\n2. search(正则) // 如果匹配到则返回索引\n3. match(正则) // 查找到字符串内一个满足字符串片段的内容返回，和 exec 一样，如果是全局 g ,那么返回的是一个数组\n```\n\n### 正则匹配中文\n\n```js\n\\u 表示匹配中文，后面带上中文的 unicode 编码\n[\\u4e00-\\u9fa5]：表示任意一个中文字符\n```\n\n","slug":"笔记/ocean/00-常用正则/00-note","published":1,"updated":"2023-03-01T07:06:35.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc6000tawafbp8sbchg","content":"<p>[TOC]</p>\n<h1 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h1><blockquote>\n<p>依赖于一个语言环境，比原生的 jsApi 更灵活,专门来验证特定字符串，或取一些内容，正则表达式是一个复杂数据类型。</p>\n</blockquote>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><ol>\n<li><p><strong>字面量创建</strong></p>\n<pre><code class=\"javascript\">// 声明的为正则\ntest() 检测一个字符串是否匹配某个模式,返回的是布尔值\nexec() 获取符合规则的字符串,没有为null\n\nlet str = &#39;houddd&#39;\nreg.test(str)\nreg.exec(str)\n</code></pre>\n<ul>\n<li><strong>缺点</strong><ol>\n<li>不可放在 <strong>/ /</strong> 中放变量，可在 <strong>eval()</strong> 方法中用 __${变量名}__解决。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>new创建</strong></p>\n<pre><code class=\"javascript\">let reg = new RegExp(&#39;u&#39;,&#39;g&#39;)\nreg.test(str)\n</code></pre>\n</li>\n</ol>\n<h3 id=\"选择符\"><a href=\"#选择符\" class=\"headerlink\" title=\"选择符\"></a>选择符</h3><pre><code class=\"js\">1. /u|a/  | 或者\n</code></pre>\n<h3 id=\"元字表或元字组\"><a href=\"#元字表或元字组\" class=\"headerlink\" title=\"元字表或元字组\"></a>元字表或元字组</h3><pre><code class=\"js\">1. () 一个整体\n    \n2. [] \n    一个整体，里面自带 | 功能\n    [abcd]  = a|b|c|d\n\n3. | \n    或 (abc|dfe) \n\n4. [^] \n    取反，表示不是里面的任意一个就可以 [^abcd]\n    当 . 出现在 [.] 中，它表示单纯的点文本\n\n5. (?:) \n    匹配一个整体但不捕获\n\n6. -     \n    表示从那一个字符到哪一个字符，前提是ASCII码值需要连接 [a-z]\n</code></pre>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><pre><code class=\"js\">1. \\ 为转义\n2. \\\\ 双转义\n</code></pre>\n<h3 id=\"字符边界\"><a href=\"#字符边界\" class=\"headerlink\" title=\"字符边界\"></a>字符边界</h3><pre><code class=\"js\">1. ^ 开始\n2. $ 结束\n</code></pre>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ol>\n<li>/d 匹配数字</li>\n<li>/D 匹配非数字</li>\n<li>/s 匹配空白</li>\n<li>/S 非空格</li>\n<li>/w 字母数字下划线</li>\n<li>/W 除了字母数字下划线</li>\n<li>.  除了换行之外的任何字符</li>\n<li> /t 匹配一个制表符，一个tab就是一个制表符</li>\n<li>s　视为单行匹配</li>\n<li>g 全局匹配</li>\n<li>i 忽略大小写</li>\n<li>y 粘性全局（每一次捕获的索引必须是连贯的）</li>\n<li>+表示出现1–n次</li>\n<li>*表示出现0–n次</li>\n<li>？表示出现0–1次</li>\n<li>{n} 出现指定次数</li>\n<li>{n,x} 从 n – x 次</li>\n<li> {2,} 从 2 – n次</li>\n</ol>\n<h3 id=\"贪婪和非贪婪\"><a href=\"#贪婪和非贪婪\" class=\"headerlink\" title=\"贪婪和非贪婪\"></a>贪婪和非贪婪</h3><blockquote>\n<p>使用限定元字符时</p>\n<p>贪婪：会捕获到最大长度</p>\n<p>非贪婪：按照最小值捕获，在表达式后面加？</p>\n</blockquote>\n<h3 id=\"正则预查\"><a href=\"#正则预查\" class=\"headerlink\" title=\"正则预查\"></a>正则预查</h3><ul>\n<li><p>正向肯定预查</p>\n<pre><code class=\"js\">尽管前面相同，捕获后面必须写着指定的字符，而且还不需要指定的字符。\n如：\n    let reg = /ES(?=2015|2016)/\n    console.log(reg.exec(&#39;ES2015&#39;)) // 只要ES 没有后面的部分\n</code></pre>\n</li>\n<li><p>正向否定预查</p>\n<pre><code class=\"js\">和正向相反，后面匹配的是不要的字符。\n    let reg = /ES(?!2015|2016)/\n    console.log(reg.exec(&#39;ES2015&#39;)) // 只要ES 没有后面的部分\n</code></pre>\n</li>\n<li><p>负向肯定预查</p>\n<pre><code class=\"js\">前面必须按照指定字符匹配，但是不需要，只要后面的字符\n    let reg = /(?&lt;=2015|2016)ES/\n    console.log(reg.exec(&#39;2015ES&#39;)) // 只要ES 没有前面的部分\n</code></pre>\n</li>\n<li><p>负向否定预查</p>\n<pre><code class=\"js\">和负向肯定预查相反,前面除了指定的字符其它都可以匹配\n    let reg = /(?&lt;!2015|2016)ES/\n    console.log(reg.exec(&#39;2015ES&#39;)) // 只要ES 没有前面的部分\n</code></pre>\n</li>\n</ul>\n<h3 id=\"重复出现\"><a href=\"#重复出现\" class=\"headerlink\" title=\"重复出现\"></a>重复出现</h3><pre><code class=\"js\">/num ：是一个正整数字，表示必须重复出现几次第一个可__被捕获__的 () 的内容\n如：\n    let reg = /([abcd])\\d+/1/\n    reg.test(&#39;a111a&#39;) //true\n    reg.test(&#39;a111b&#39;) // true\n    \n</code></pre>\n<h3 id=\"字符串方法配合正则\"><a href=\"#字符串方法配合正则\" class=\"headerlink\" title=\"字符串方法配合正则\"></a>字符串方法配合正则</h3><pre><code class=\"js\">1. replace(正则,要替换的内容)\n2. search(正则) // 如果匹配到则返回索引\n3. match(正则) // 查找到字符串内一个满足字符串片段的内容返回，和 exec 一样，如果是全局 g ,那么返回的是一个数组\n</code></pre>\n<h3 id=\"正则匹配中文\"><a href=\"#正则匹配中文\" class=\"headerlink\" title=\"正则匹配中文\"></a>正则匹配中文</h3><pre><code class=\"js\">\\u 表示匹配中文，后面带上中文的 unicode 编码\n[\\u4e00-\\u9fa5]：表示任意一个中文字符\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h1><blockquote>\n<p>依赖于一个语言环境，比原生的 jsApi 更灵活,专门来验证特定字符串，或取一些内容，正则表达式是一个复杂数据类型。</p>\n</blockquote>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><ol>\n<li><p><strong>字面量创建</strong></p>\n<pre><code class=\"javascript\">// 声明的为正则\ntest() 检测一个字符串是否匹配某个模式,返回的是布尔值\nexec() 获取符合规则的字符串,没有为null\n\nlet str = &#39;houddd&#39;\nreg.test(str)\nreg.exec(str)\n</code></pre>\n<ul>\n<li><strong>缺点</strong><ol>\n<li>不可放在 <strong>/ /</strong> 中放变量，可在 <strong>eval()</strong> 方法中用 __${变量名}__解决。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>new创建</strong></p>\n<pre><code class=\"javascript\">let reg = new RegExp(&#39;u&#39;,&#39;g&#39;)\nreg.test(str)\n</code></pre>\n</li>\n</ol>\n<h3 id=\"选择符\"><a href=\"#选择符\" class=\"headerlink\" title=\"选择符\"></a>选择符</h3><pre><code class=\"js\">1. /u|a/  | 或者\n</code></pre>\n<h3 id=\"元字表或元字组\"><a href=\"#元字表或元字组\" class=\"headerlink\" title=\"元字表或元字组\"></a>元字表或元字组</h3><pre><code class=\"js\">1. () 一个整体\n    \n2. [] \n    一个整体，里面自带 | 功能\n    [abcd]  = a|b|c|d\n\n3. | \n    或 (abc|dfe) \n\n4. [^] \n    取反，表示不是里面的任意一个就可以 [^abcd]\n    当 . 出现在 [.] 中，它表示单纯的点文本\n\n5. (?:) \n    匹配一个整体但不捕获\n\n6. -     \n    表示从那一个字符到哪一个字符，前提是ASCII码值需要连接 [a-z]\n</code></pre>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><pre><code class=\"js\">1. \\ 为转义\n2. \\\\ 双转义\n</code></pre>\n<h3 id=\"字符边界\"><a href=\"#字符边界\" class=\"headerlink\" title=\"字符边界\"></a>字符边界</h3><pre><code class=\"js\">1. ^ 开始\n2. $ 结束\n</code></pre>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ol>\n<li>/d 匹配数字</li>\n<li>/D 匹配非数字</li>\n<li>/s 匹配空白</li>\n<li>/S 非空格</li>\n<li>/w 字母数字下划线</li>\n<li>/W 除了字母数字下划线</li>\n<li>.  除了换行之外的任何字符</li>\n<li> /t 匹配一个制表符，一个tab就是一个制表符</li>\n<li>s　视为单行匹配</li>\n<li>g 全局匹配</li>\n<li>i 忽略大小写</li>\n<li>y 粘性全局（每一次捕获的索引必须是连贯的）</li>\n<li>+表示出现1–n次</li>\n<li>*表示出现0–n次</li>\n<li>？表示出现0–1次</li>\n<li>{n} 出现指定次数</li>\n<li>{n,x} 从 n – x 次</li>\n<li> {2,} 从 2 – n次</li>\n</ol>\n<h3 id=\"贪婪和非贪婪\"><a href=\"#贪婪和非贪婪\" class=\"headerlink\" title=\"贪婪和非贪婪\"></a>贪婪和非贪婪</h3><blockquote>\n<p>使用限定元字符时</p>\n<p>贪婪：会捕获到最大长度</p>\n<p>非贪婪：按照最小值捕获，在表达式后面加？</p>\n</blockquote>\n<h3 id=\"正则预查\"><a href=\"#正则预查\" class=\"headerlink\" title=\"正则预查\"></a>正则预查</h3><ul>\n<li><p>正向肯定预查</p>\n<pre><code class=\"js\">尽管前面相同，捕获后面必须写着指定的字符，而且还不需要指定的字符。\n如：\n    let reg = /ES(?=2015|2016)/\n    console.log(reg.exec(&#39;ES2015&#39;)) // 只要ES 没有后面的部分\n</code></pre>\n</li>\n<li><p>正向否定预查</p>\n<pre><code class=\"js\">和正向相反，后面匹配的是不要的字符。\n    let reg = /ES(?!2015|2016)/\n    console.log(reg.exec(&#39;ES2015&#39;)) // 只要ES 没有后面的部分\n</code></pre>\n</li>\n<li><p>负向肯定预查</p>\n<pre><code class=\"js\">前面必须按照指定字符匹配，但是不需要，只要后面的字符\n    let reg = /(?&lt;=2015|2016)ES/\n    console.log(reg.exec(&#39;2015ES&#39;)) // 只要ES 没有前面的部分\n</code></pre>\n</li>\n<li><p>负向否定预查</p>\n<pre><code class=\"js\">和负向肯定预查相反,前面除了指定的字符其它都可以匹配\n    let reg = /(?&lt;!2015|2016)ES/\n    console.log(reg.exec(&#39;2015ES&#39;)) // 只要ES 没有前面的部分\n</code></pre>\n</li>\n</ul>\n<h3 id=\"重复出现\"><a href=\"#重复出现\" class=\"headerlink\" title=\"重复出现\"></a>重复出现</h3><pre><code class=\"js\">/num ：是一个正整数字，表示必须重复出现几次第一个可__被捕获__的 () 的内容\n如：\n    let reg = /([abcd])\\d+/1/\n    reg.test(&#39;a111a&#39;) //true\n    reg.test(&#39;a111b&#39;) // true\n    \n</code></pre>\n<h3 id=\"字符串方法配合正则\"><a href=\"#字符串方法配合正则\" class=\"headerlink\" title=\"字符串方法配合正则\"></a>字符串方法配合正则</h3><pre><code class=\"js\">1. replace(正则,要替换的内容)\n2. search(正则) // 如果匹配到则返回索引\n3. match(正则) // 查找到字符串内一个满足字符串片段的内容返回，和 exec 一样，如果是全局 g ,那么返回的是一个数组\n</code></pre>\n<h3 id=\"正则匹配中文\"><a href=\"#正则匹配中文\" class=\"headerlink\" title=\"正则匹配中文\"></a>正则匹配中文</h3><pre><code class=\"js\">\\u 表示匹配中文，后面带上中文的 unicode 编码\n[\\u4e00-\\u9fa5]：表示任意一个中文字符\n</code></pre>\n"},{"title":"js一些问题","date":"2019-05-06T06:02:48.000Z","_content":"\n[TOC]\n\n\n\n## attribute和property的区别?\n\n自带的 attribute已经附加在property对象上了所以property中包含了自带的attribute，可以通过 dom节点.id访问。\n\n而自定attribute不会附加到property,会在property子集中attributes中找到，可使用 setAttribute()来设置任何属性和属性值，使用getAttribute()来获取任何属性\n\n\n\n## DOM和BOM?\n\nDOM的跟对象是：document，DOM就是html和xml的一套api\n\nBOM的跟对象是：window中包含document,location，等\n\n所以BOM包含DOM\n\n\n\n## for in 和for of的区别\n\nfor in 遍历键名，一般用于遍历对象\n\nfor of 是ES6新特新，遍历键值，一般用于遍历数组\n\n\n\n## 块域和局部作用域的区别\n\n块域是{} ,作用域是全局和局部作用域。\n\n块级作用域一般是使用let和const时创建的，就是指使用let和const声明的变量只在当前块域生效。\n\n在局部作用域中不管用var还是let都是只能在当前作用域生效\n\n\n\n## Object.prototype.toString和toString()有关系吗？\n\ntoString()其实是按照原型链去找到 Object.prototype 上的。\n\nObject.prototype.toString() 方法是严格函数 。\n\nObject.prototype.toString.call()与toString.call()是真正意义上的等价 \n\n\n\n\n\n\n\n","source":"_posts/笔记/ocean/00-new知识/doubt.md","raw":"---\ntitle: js一些问题\ndate: 2019-05-06 14:02:48\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n---\n\n[TOC]\n\n\n\n## attribute和property的区别?\n\n自带的 attribute已经附加在property对象上了所以property中包含了自带的attribute，可以通过 dom节点.id访问。\n\n而自定attribute不会附加到property,会在property子集中attributes中找到，可使用 setAttribute()来设置任何属性和属性值，使用getAttribute()来获取任何属性\n\n\n\n## DOM和BOM?\n\nDOM的跟对象是：document，DOM就是html和xml的一套api\n\nBOM的跟对象是：window中包含document,location，等\n\n所以BOM包含DOM\n\n\n\n## for in 和for of的区别\n\nfor in 遍历键名，一般用于遍历对象\n\nfor of 是ES6新特新，遍历键值，一般用于遍历数组\n\n\n\n## 块域和局部作用域的区别\n\n块域是{} ,作用域是全局和局部作用域。\n\n块级作用域一般是使用let和const时创建的，就是指使用let和const声明的变量只在当前块域生效。\n\n在局部作用域中不管用var还是let都是只能在当前作用域生效\n\n\n\n## Object.prototype.toString和toString()有关系吗？\n\ntoString()其实是按照原型链去找到 Object.prototype 上的。\n\nObject.prototype.toString() 方法是严格函数 。\n\nObject.prototype.toString.call()与toString.call()是真正意义上的等价 \n\n\n\n\n\n\n\n","slug":"笔记/ocean/00-new知识/doubt","published":1,"updated":"2023-03-01T07:06:44.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc8000xawaf25nq8u87","content":"<p>[TOC]</p>\n<h2 id=\"attribute和property的区别\"><a href=\"#attribute和property的区别\" class=\"headerlink\" title=\"attribute和property的区别?\"></a>attribute和property的区别?</h2><p>自带的 attribute已经附加在property对象上了所以property中包含了自带的attribute，可以通过 dom节点.id访问。</p>\n<p>而自定attribute不会附加到property,会在property子集中attributes中找到，可使用 setAttribute()来设置任何属性和属性值，使用getAttribute()来获取任何属性</p>\n<h2 id=\"DOM和BOM\"><a href=\"#DOM和BOM\" class=\"headerlink\" title=\"DOM和BOM?\"></a>DOM和BOM?</h2><p>DOM的跟对象是：document，DOM就是html和xml的一套api</p>\n<p>BOM的跟对象是：window中包含document,location，等</p>\n<p>所以BOM包含DOM</p>\n<h2 id=\"for-in-和for-of的区别\"><a href=\"#for-in-和for-of的区别\" class=\"headerlink\" title=\"for in 和for of的区别\"></a>for in 和for of的区别</h2><p>for in 遍历键名，一般用于遍历对象</p>\n<p>for of 是ES6新特新，遍历键值，一般用于遍历数组</p>\n<h2 id=\"块域和局部作用域的区别\"><a href=\"#块域和局部作用域的区别\" class=\"headerlink\" title=\"块域和局部作用域的区别\"></a>块域和局部作用域的区别</h2><p>块域是{} ,作用域是全局和局部作用域。</p>\n<p>块级作用域一般是使用let和const时创建的，就是指使用let和const声明的变量只在当前块域生效。</p>\n<p>在局部作用域中不管用var还是let都是只能在当前作用域生效</p>\n<h2 id=\"Object-prototype-toString和toString-有关系吗？\"><a href=\"#Object-prototype-toString和toString-有关系吗？\" class=\"headerlink\" title=\"Object.prototype.toString和toString()有关系吗？\"></a>Object.prototype.toString和toString()有关系吗？</h2><p>toString()其实是按照原型链去找到 Object.prototype 上的。</p>\n<p>Object.prototype.toString() 方法是严格函数 。</p>\n<p>Object.prototype.toString.call()与toString.call()是真正意义上的等价 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"attribute和property的区别\"><a href=\"#attribute和property的区别\" class=\"headerlink\" title=\"attribute和property的区别?\"></a>attribute和property的区别?</h2><p>自带的 attribute已经附加在property对象上了所以property中包含了自带的attribute，可以通过 dom节点.id访问。</p>\n<p>而自定attribute不会附加到property,会在property子集中attributes中找到，可使用 setAttribute()来设置任何属性和属性值，使用getAttribute()来获取任何属性</p>\n<h2 id=\"DOM和BOM\"><a href=\"#DOM和BOM\" class=\"headerlink\" title=\"DOM和BOM?\"></a>DOM和BOM?</h2><p>DOM的跟对象是：document，DOM就是html和xml的一套api</p>\n<p>BOM的跟对象是：window中包含document,location，等</p>\n<p>所以BOM包含DOM</p>\n<h2 id=\"for-in-和for-of的区别\"><a href=\"#for-in-和for-of的区别\" class=\"headerlink\" title=\"for in 和for of的区别\"></a>for in 和for of的区别</h2><p>for in 遍历键名，一般用于遍历对象</p>\n<p>for of 是ES6新特新，遍历键值，一般用于遍历数组</p>\n<h2 id=\"块域和局部作用域的区别\"><a href=\"#块域和局部作用域的区别\" class=\"headerlink\" title=\"块域和局部作用域的区别\"></a>块域和局部作用域的区别</h2><p>块域是{} ,作用域是全局和局部作用域。</p>\n<p>块级作用域一般是使用let和const时创建的，就是指使用let和const声明的变量只在当前块域生效。</p>\n<p>在局部作用域中不管用var还是let都是只能在当前作用域生效</p>\n<h2 id=\"Object-prototype-toString和toString-有关系吗？\"><a href=\"#Object-prototype-toString和toString-有关系吗？\" class=\"headerlink\" title=\"Object.prototype.toString和toString()有关系吗？\"></a>Object.prototype.toString和toString()有关系吗？</h2><p>toString()其实是按照原型链去找到 Object.prototype 上的。</p>\n<p>Object.prototype.toString() 方法是严格函数 。</p>\n<p>Object.prototype.toString.call()与toString.call()是真正意义上的等价 </p>\n"},{"title":"常用正则","date":"2019-04-12T02:41:48.000Z","_content":"\n\n# 常用正则\n\n## 用户名正则\n\n```js\n4到16位，包括（字母，数字，下划线，减号）:\t /^[a-zA-Z0-9_-]{4,16}$/\n```\n\n\n\n## 手机号验证\n\n```js\n以1开头，11位以内的手机号:  /^[1][3,4,5,7,8][0-9]{9}$/ \t\n```\n\n## 验证码\n\n```js\n4位的验证码： /^\\d{4}$/\n```\n\n\n\n\n\n","source":"_posts/笔记/ocean/00-常用正则/常用正则.md","raw":"---\ntitle: 常用正则\ndate: 2019-04-12 10:41:48\ncategories:\n- 笔记\n- 正则\ntags:\n- 前端\n- 正则\n---\n\n\n# 常用正则\n\n## 用户名正则\n\n```js\n4到16位，包括（字母，数字，下划线，减号）:\t /^[a-zA-Z0-9_-]{4,16}$/\n```\n\n\n\n## 手机号验证\n\n```js\n以1开头，11位以内的手机号:  /^[1][3,4,5,7,8][0-9]{9}$/ \t\n```\n\n## 验证码\n\n```js\n4位的验证码： /^\\d{4}$/\n```\n\n\n\n\n\n","slug":"笔记/ocean/00-常用正则/常用正则","published":1,"updated":"2023-03-01T07:06:37.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc8000zawaf097ih2rz","content":"<h1 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h1><h2 id=\"用户名正则\"><a href=\"#用户名正则\" class=\"headerlink\" title=\"用户名正则\"></a>用户名正则</h2><pre><code class=\"js\">4到16位，包括（字母，数字，下划线，减号）:     /^[a-zA-Z0-9_-]&#123;4,16&#125;$/\n</code></pre>\n<h2 id=\"手机号验证\"><a href=\"#手机号验证\" class=\"headerlink\" title=\"手机号验证\"></a>手机号验证</h2><pre><code class=\"js\">以1开头，11位以内的手机号:  /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/     \n</code></pre>\n<h2 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h2><pre><code class=\"js\">4位的验证码： /^\\d&#123;4&#125;$/\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h1><h2 id=\"用户名正则\"><a href=\"#用户名正则\" class=\"headerlink\" title=\"用户名正则\"></a>用户名正则</h2><pre><code class=\"js\">4到16位，包括（字母，数字，下划线，减号）:     /^[a-zA-Z0-9_-]&#123;4,16&#125;$/\n</code></pre>\n<h2 id=\"手机号验证\"><a href=\"#手机号验证\" class=\"headerlink\" title=\"手机号验证\"></a>手机号验证</h2><pre><code class=\"js\">以1开头，11位以内的手机号:  /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/     \n</code></pre>\n<h2 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h2><pre><code class=\"js\">4位的验证码： /^\\d&#123;4&#125;$/\n</code></pre>\n"},{"title":"javascript基础-数组,字符串，对象方法补充","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 数组方法\n\n- join()  将数组按什么格式拼接为字符串。\n- push()和pop() 添加 和 最后一个元素。\n- shift() 和 unshift()  添加和删除第一个元素。\n- sort() 从小到大排序数组。\n- reverse() 反转数组，改变原数组\n- concat() 拼接数组\n- slice() 截取数组，从第几个位置开始，第几个位置结束\n- splice() 截取数组，从第几个位置开始，截取几个下标。\n- indexOf()和 lastIndexOf() （ES5新增）查找匹配的第一个元素，有返回下标无返回-1\n- forEach() （ES5新增）循环数组，不会改变元素本身。\n- map() （ES5新增）遍历数组，对其每一个元素进行操作后返回，会返回一个新数组。\n- filter() （ES5新增）遍历数组，如果为true 返回当前元素。\n- every () （ES5新增）遍历数组，所有元素都为true才会返回true\n- some () （ES5新增） 遍历数组，有一项为true就为true\n\n\n\n## join()\t转成字符串\n\njoin，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)\n\n- 书写格式：`join(\" \")`，括号里面写字符串 (\"要加引号\"),\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.join()); 　　　　// 1,2,3\nconsole.log(arr.join(\"-\")); 　　// 1-2-3\nconsole.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）\n```\n\n\n\n## push()和pop()\t数组末尾增/删\n\npush(): 把里面的内容添加到数组末尾，并`返回`修改后的长度。\n\n- 书写格式：`arr.push(\" \")`，括号里面写内容 (\"字符串要加引号\"),\n\npop()：移除数组最后一项，`返回`移除的那个值，减少数组的length。\n\n-  书写格式：`arr.pop( )`\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.push(\"Jack\",\"Sean\");\nconsole.log(count); 　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop();\nconsole.log(item); 　　　　　　　　　　 // Sean\nconsole.log(arr); 　　　　　　　　　　  // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n\n\n\n## shift() 和 unshift()\t数组开头删/增\n\n(和上面的push，pop相反，针对第一项内容)\n\n**shift()：删除原数组第一项，并`返回`删除元素的值；如果数组为空则`返回`undefined 。**\n\n**unshift:将参数添加到原数组开头，并`返回`数组的长度 。**\n\n- 书写格式：`arr.shift(\" \")`，括号里面写内容 (\"字符串要加引号\"),\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.unshift(\"Jack\",\"Sean\");\nconsole.log(count); 　　　　　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　　　　　//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift();\nconsole.log(item); 　　　　　　　　　　　　　　// Jack\nconsole.log(arr); 　　　　　　　　　　　　　　 // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n\n\n\n## sort()\t数组从小到大排序\n\n**sort()：将数组里的项从小到大排序**\n\n- 书写格式：`arr.sort( )`\n\n```js\nvar arr1 = [\"a\", \"d\", \"c\", \"b\"];\nconsole.log(arr1.sort()); 　　　　　　　　　　// [\"a\", \"b\", \"c\", \"d\"]\n```\n\n- sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数\n\n```js\nfunction sortNumber(a,b)\n{\n　　return a - b\n}\n```\n\n```js\narr = [13, 24, 51, 3]; \nconsole.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] \nconsole.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)\n```\n\n\n\n## reverse()\t数组翻转\n\nreverse()：反转数组项的顺序。\n\n- 书写格式：`arr.reverse( )`\n\n```js\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)\n```\n\n\n\n## concat()\t数组的拼接\n\n**concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后`返回`新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并`返回`副本。**\n\n- 书写格式：`arr.concat()`，括号里面写内容 (\"字符串要加引号\"),\n\n```js\nvar arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)\n```\n\n\n\n## slice()\t 截取\n\n**slice()：`返回`从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要`返回`项的起始和结束位置。在只有一个参数的情况下， slice()方法`返回`从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法`返回`起始和结束位置之间的项——但不包括结束位置的项。**\n\n- 书写格式：`arr.slice( 1 , 3 )`\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]\n```\n\n- arrCopy只设置了一个参数，也就是起始下标为1，所以`返回`的数组为下标1（包括下标1）开始到数组最后。 \n- arrCopy2设置了两个参数，`返回`起始下标（包括1）开始到终止下标（不包括4）的子数组。 \n- arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 \n- arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。\n\n\n\n## splice\t删除，增加，替换\n\nsplice()：删除、插入和替换。\n\n**删除**：指定 2 个参数：要删除的第一项的位置和要删除的项数。\n\n- 书写格式：`arr.splice( 1 , 3 )`\n\n**插入**：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。\n\n-  书写格式：`arr.splice( 2,0,4,6 )`\n\n**替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。\n\n- 书写格式：`arr.splice( 2,0,4,6 )`\n\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]\nconsole.log(arrRemoved); 　　　　　　　　　　　//[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); 　　　　　　　　　　// []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); 　　　　　　　　　　// [7]\n```\n\n\n\n## indexOf()和 lastIndexOf()\t查找\n\n**indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。**\n\n- 书写格式：`arr.indexof( 5 )`\n\n**lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。**\n\n- 书写格式：`arr.lastIndexOf( 5,4 )`\n\n```js\nvar arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); 　　　　　　//2\nconsole.log(arr.lastIndexOf(5)); 　　　 //5\nconsole.log(arr.indexOf(5,2)); 　　　　 //2\nconsole.log(arr.lastIndexOf(5,4)); 　　//2\nconsole.log(arr.indexOf(\"5\")); 　　　　 //-1\n```\n\n\n\n## forEach()\t遍历\n\n**forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有`返回`值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。**\n\n- 书写格式：`arr.forEach()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a){\nconsole.log(x + '|' + index + '|' + (a === arr));\n});\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n\n\n\n## map()\t遍历\n\n**map()：指“映射”，对数组中的每一项运行给定函数，`返回`每次函数调用的结果组成的数组。**\n\n书写格式：`arr.map()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item){\nreturn item*item;\n});\nconsole.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]\n```\n\n\n\n## filter()\t过滤\n\n**filter()：“过滤”功能，数组中的每一项运行给定函数，`返回`满足过滤条件组成的数组。**\n\n- 书写格式：`arr.filter()`\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n}); \nconsole.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]\n```\n\n\n\n## every()\t判断是否每一项满足条件\n\n**every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会`返回`true。**\n\n- 书写格式：`arr.every()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) {\nreturn x < 10;\n}); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.every(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr3); 　　　　　　　　// false\n```\n\n\n\n## some()\t判断是否有一项满足条件\n\n**some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会`返回`true。**\n\n- 书写格式：`arr.some()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.some(function(x) {\nreturn x < 1;\n}); \nconsole.log(arr3); 　　　　　　　　// false\n```\n\n\n\n# string字符串\n\n| **charAT（index）**     | 通过索引找字符                                               |\n| ----------------------- | ------------------------------------------------------------ |\n| **charCodeAt**（index） | 通过索引找到字符的 Unicode 编码。这个`返回`值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者`返回`的是位于指定位置的字符的编码，而后者`返回`的是字符子串。 |\n| **indexOf（）**         | 从前往后找，找到`返回`内容的索引，找不到`返回`-1；           |\n| **lastIndexOf**（）     | 从后往前找，找到`返回`内容的索引，找不到`返回`-1；           |\n| **slice（n，m）**       | 从索引n 查找到索引m  但不包括m，slice可以取负值              |\n| **substring（n，m）**   | 从索引n 查找到索引m ，但不包括m， 不可以取负值               |\n| **substr（n，m）**      | 从索引n开始截取m 个                                          |\n| **split（切割形式）**   | 把一个字符串分割成字符串数组。                               |\n| **toUpperCase（）**     | 转大写字母                                                   |\n| **toLowerCase（）**     | 转小写字母                                                   |\n| replace(n，m)           | 替换                                                         |\n\n \n\n# Math对象\n\n| **Math.floor（）**   | 向下取整            |\n| -------------------- | ------------------- |\n| **Math.ceil（）**    | 向上取整            |\n| **Math.random（）**  | 取0-1之间的随机小数 |\n| **Math.round（）**   | 四舍五入            |\n| **Math.max（）**     | 取最大值            |\n| **Math.min（）**     | 取最小值            |\n| **Math.abs（）**     | 取绝对值            |\n| **Math.pow（x，y）** | x的y次幂            |\n| **Math.sqrt（）**    | 开平方              |\n\n\n\n# Date日期对象\n\n| **new Date（）**              | 创建一个日期对象                                             |\n| ----------------------------- | ------------------------------------------------------------ |\n| **getFullYear（）**           | `返回`年份                                                   |\n| **getMonth（）**              | `返回`月份数（0-11），想要得到几月，需要加1                  |\n| **getDay（）**                | `返回`一周的第几天（0-6），想要得到星期几，需要加一          |\n| **getDate（）**               | `返回`日                                                     |\n| **getHours（）**              | `返回`时                                                     |\n| **getMinutes（）**            | `返回`分                                                     |\n| **getSeconds（）**            | `返回`秒                                                     |\n| **getTime（）**               | `返回`从1970年1月1日00：00到现在的毫秒数（格林尼治时间），也就是时间戳 |\n| **setYear(yearInt)**          | 设置年份.2位数或4位数                                        |\n| **setFullYear(yearInt)**      | 设置年份.4位数                                               |\n| **setMonth(monthInt)**        | 设置月份(0-11)                                               |\n| **setDate(dateInt)**          | 设置日(1-31)                                                 |\n| **setHours(hourInt)**         | 设置小时数(0-23)                                             |\n| **setMinutes(minInt)**        | 设置分钟数(0-59)                                             |\n| **setSeconds(secInt)**        | 设置秒数(0-59)                                               |\n| **setMilliseconds(milliInt)** | 设置毫秒(0-999)                                              |\n\n","source":"_posts/笔记/ocean/03-javascript基础总结/JS数组,字符串,对象.md","raw":"---\ntitle: javascript基础-数组,字符串，对象方法补充\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 数组方法\n\n- join()  将数组按什么格式拼接为字符串。\n- push()和pop() 添加 和 最后一个元素。\n- shift() 和 unshift()  添加和删除第一个元素。\n- sort() 从小到大排序数组。\n- reverse() 反转数组，改变原数组\n- concat() 拼接数组\n- slice() 截取数组，从第几个位置开始，第几个位置结束\n- splice() 截取数组，从第几个位置开始，截取几个下标。\n- indexOf()和 lastIndexOf() （ES5新增）查找匹配的第一个元素，有返回下标无返回-1\n- forEach() （ES5新增）循环数组，不会改变元素本身。\n- map() （ES5新增）遍历数组，对其每一个元素进行操作后返回，会返回一个新数组。\n- filter() （ES5新增）遍历数组，如果为true 返回当前元素。\n- every () （ES5新增）遍历数组，所有元素都为true才会返回true\n- some () （ES5新增） 遍历数组，有一项为true就为true\n\n\n\n## join()\t转成字符串\n\njoin，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)\n\n- 书写格式：`join(\" \")`，括号里面写字符串 (\"要加引号\"),\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.join()); 　　　　// 1,2,3\nconsole.log(arr.join(\"-\")); 　　// 1-2-3\nconsole.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）\n```\n\n\n\n## push()和pop()\t数组末尾增/删\n\npush(): 把里面的内容添加到数组末尾，并`返回`修改后的长度。\n\n- 书写格式：`arr.push(\" \")`，括号里面写内容 (\"字符串要加引号\"),\n\npop()：移除数组最后一项，`返回`移除的那个值，减少数组的length。\n\n-  书写格式：`arr.pop( )`\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.push(\"Jack\",\"Sean\");\nconsole.log(count); 　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop();\nconsole.log(item); 　　　　　　　　　　 // Sean\nconsole.log(arr); 　　　　　　　　　　  // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n\n\n\n## shift() 和 unshift()\t数组开头删/增\n\n(和上面的push，pop相反，针对第一项内容)\n\n**shift()：删除原数组第一项，并`返回`删除元素的值；如果数组为空则`返回`undefined 。**\n\n**unshift:将参数添加到原数组开头，并`返回`数组的长度 。**\n\n- 书写格式：`arr.shift(\" \")`，括号里面写内容 (\"字符串要加引号\"),\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.unshift(\"Jack\",\"Sean\");\nconsole.log(count); 　　　　　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　　　　　//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift();\nconsole.log(item); 　　　　　　　　　　　　　　// Jack\nconsole.log(arr); 　　　　　　　　　　　　　　 // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n\n\n\n## sort()\t数组从小到大排序\n\n**sort()：将数组里的项从小到大排序**\n\n- 书写格式：`arr.sort( )`\n\n```js\nvar arr1 = [\"a\", \"d\", \"c\", \"b\"];\nconsole.log(arr1.sort()); 　　　　　　　　　　// [\"a\", \"b\", \"c\", \"d\"]\n```\n\n- sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数\n\n```js\nfunction sortNumber(a,b)\n{\n　　return a - b\n}\n```\n\n```js\narr = [13, 24, 51, 3]; \nconsole.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] \nconsole.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)\n```\n\n\n\n## reverse()\t数组翻转\n\nreverse()：反转数组项的顺序。\n\n- 书写格式：`arr.reverse( )`\n\n```js\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)\n```\n\n\n\n## concat()\t数组的拼接\n\n**concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后`返回`新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并`返回`副本。**\n\n- 书写格式：`arr.concat()`，括号里面写内容 (\"字符串要加引号\"),\n\n```js\nvar arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)\n```\n\n\n\n## slice()\t 截取\n\n**slice()：`返回`从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要`返回`项的起始和结束位置。在只有一个参数的情况下， slice()方法`返回`从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法`返回`起始和结束位置之间的项——但不包括结束位置的项。**\n\n- 书写格式：`arr.slice( 1 , 3 )`\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]\n```\n\n- arrCopy只设置了一个参数，也就是起始下标为1，所以`返回`的数组为下标1（包括下标1）开始到数组最后。 \n- arrCopy2设置了两个参数，`返回`起始下标（包括1）开始到终止下标（不包括4）的子数组。 \n- arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 \n- arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。\n\n\n\n## splice\t删除，增加，替换\n\nsplice()：删除、插入和替换。\n\n**删除**：指定 2 个参数：要删除的第一项的位置和要删除的项数。\n\n- 书写格式：`arr.splice( 1 , 3 )`\n\n**插入**：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。\n\n-  书写格式：`arr.splice( 2,0,4,6 )`\n\n**替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。\n\n- 书写格式：`arr.splice( 2,0,4,6 )`\n\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]\nconsole.log(arrRemoved); 　　　　　　　　　　　//[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); 　　　　　　　　　　// []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); 　　　　　　　　　　// [7]\n```\n\n\n\n## indexOf()和 lastIndexOf()\t查找\n\n**indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。**\n\n- 书写格式：`arr.indexof( 5 )`\n\n**lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。**\n\n- 书写格式：`arr.lastIndexOf( 5,4 )`\n\n```js\nvar arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); 　　　　　　//2\nconsole.log(arr.lastIndexOf(5)); 　　　 //5\nconsole.log(arr.indexOf(5,2)); 　　　　 //2\nconsole.log(arr.lastIndexOf(5,4)); 　　//2\nconsole.log(arr.indexOf(\"5\")); 　　　　 //-1\n```\n\n\n\n## forEach()\t遍历\n\n**forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有`返回`值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。**\n\n- 书写格式：`arr.forEach()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a){\nconsole.log(x + '|' + index + '|' + (a === arr));\n});\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n\n\n\n## map()\t遍历\n\n**map()：指“映射”，对数组中的每一项运行给定函数，`返回`每次函数调用的结果组成的数组。**\n\n书写格式：`arr.map()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item){\nreturn item*item;\n});\nconsole.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]\n```\n\n\n\n## filter()\t过滤\n\n**filter()：“过滤”功能，数组中的每一项运行给定函数，`返回`满足过滤条件组成的数组。**\n\n- 书写格式：`arr.filter()`\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n}); \nconsole.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]\n```\n\n\n\n## every()\t判断是否每一项满足条件\n\n**every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会`返回`true。**\n\n- 书写格式：`arr.every()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) {\nreturn x < 10;\n}); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.every(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr3); 　　　　　　　　// false\n```\n\n\n\n## some()\t判断是否有一项满足条件\n\n**some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会`返回`true。**\n\n- 书写格式：`arr.some()`\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.some(function(x) {\nreturn x < 1;\n}); \nconsole.log(arr3); 　　　　　　　　// false\n```\n\n\n\n# string字符串\n\n| **charAT（index）**     | 通过索引找字符                                               |\n| ----------------------- | ------------------------------------------------------------ |\n| **charCodeAt**（index） | 通过索引找到字符的 Unicode 编码。这个`返回`值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者`返回`的是位于指定位置的字符的编码，而后者`返回`的是字符子串。 |\n| **indexOf（）**         | 从前往后找，找到`返回`内容的索引，找不到`返回`-1；           |\n| **lastIndexOf**（）     | 从后往前找，找到`返回`内容的索引，找不到`返回`-1；           |\n| **slice（n，m）**       | 从索引n 查找到索引m  但不包括m，slice可以取负值              |\n| **substring（n，m）**   | 从索引n 查找到索引m ，但不包括m， 不可以取负值               |\n| **substr（n，m）**      | 从索引n开始截取m 个                                          |\n| **split（切割形式）**   | 把一个字符串分割成字符串数组。                               |\n| **toUpperCase（）**     | 转大写字母                                                   |\n| **toLowerCase（）**     | 转小写字母                                                   |\n| replace(n，m)           | 替换                                                         |\n\n \n\n# Math对象\n\n| **Math.floor（）**   | 向下取整            |\n| -------------------- | ------------------- |\n| **Math.ceil（）**    | 向上取整            |\n| **Math.random（）**  | 取0-1之间的随机小数 |\n| **Math.round（）**   | 四舍五入            |\n| **Math.max（）**     | 取最大值            |\n| **Math.min（）**     | 取最小值            |\n| **Math.abs（）**     | 取绝对值            |\n| **Math.pow（x，y）** | x的y次幂            |\n| **Math.sqrt（）**    | 开平方              |\n\n\n\n# Date日期对象\n\n| **new Date（）**              | 创建一个日期对象                                             |\n| ----------------------------- | ------------------------------------------------------------ |\n| **getFullYear（）**           | `返回`年份                                                   |\n| **getMonth（）**              | `返回`月份数（0-11），想要得到几月，需要加1                  |\n| **getDay（）**                | `返回`一周的第几天（0-6），想要得到星期几，需要加一          |\n| **getDate（）**               | `返回`日                                                     |\n| **getHours（）**              | `返回`时                                                     |\n| **getMinutes（）**            | `返回`分                                                     |\n| **getSeconds（）**            | `返回`秒                                                     |\n| **getTime（）**               | `返回`从1970年1月1日00：00到现在的毫秒数（格林尼治时间），也就是时间戳 |\n| **setYear(yearInt)**          | 设置年份.2位数或4位数                                        |\n| **setFullYear(yearInt)**      | 设置年份.4位数                                               |\n| **setMonth(monthInt)**        | 设置月份(0-11)                                               |\n| **setDate(dateInt)**          | 设置日(1-31)                                                 |\n| **setHours(hourInt)**         | 设置小时数(0-23)                                             |\n| **setMinutes(minInt)**        | 设置分钟数(0-59)                                             |\n| **setSeconds(secInt)**        | 设置秒数(0-59)                                               |\n| **setMilliseconds(milliInt)** | 设置毫秒(0-999)                                              |\n\n","slug":"笔记/ocean/03-javascript基础总结/JS数组,字符串,对象","published":1,"updated":"2023-03-01T07:07:26.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qc90013awaf4ok037ad","content":"<h1 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h1><ul>\n<li>join()  将数组按什么格式拼接为字符串。</li>\n<li>push()和pop() 添加 和 最后一个元素。</li>\n<li>shift() 和 unshift()  添加和删除第一个元素。</li>\n<li>sort() 从小到大排序数组。</li>\n<li>reverse() 反转数组，改变原数组</li>\n<li>concat() 拼接数组</li>\n<li>slice() 截取数组，从第几个位置开始，第几个位置结束</li>\n<li>splice() 截取数组，从第几个位置开始，截取几个下标。</li>\n<li>indexOf()和 lastIndexOf() （ES5新增）查找匹配的第一个元素，有返回下标无返回-1</li>\n<li>forEach() （ES5新增）循环数组，不会改变元素本身。</li>\n<li>map() （ES5新增）遍历数组，对其每一个元素进行操作后返回，会返回一个新数组。</li>\n<li>filter() （ES5新增）遍历数组，如果为true 返回当前元素。</li>\n<li>every () （ES5新增）遍历数组，所有元素都为true才会返回true</li>\n<li>some () （ES5新增） 遍历数组，有一项为true就为true</li>\n</ul>\n<h2 id=\"join-转成字符串\"><a href=\"#join-转成字符串\" class=\"headerlink\" title=\"join()    转成字符串\"></a>join()    转成字符串</h2><p>join，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)</p>\n<ul>\n<li>书写格式：<code>join(&quot; &quot;)</code>，括号里面写字符串 (“要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [1,2,3];\nconsole.log(arr.join()); 　　　　// 1,2,3\nconsole.log(arr.join(&quot;-&quot;)); 　　// 1-2-3\nconsole.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）\n</code></pre>\n<h2 id=\"push-和pop-数组末尾增-删\"><a href=\"#push-和pop-数组末尾增-删\" class=\"headerlink\" title=\"push()和pop()    数组末尾增/删\"></a>push()和pop()    数组末尾增/删</h2><p>push(): 把里面的内容添加到数组末尾，并<code>返回</code>修改后的长度。</p>\n<ul>\n<li>书写格式：<code>arr.push(&quot; &quot;)</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<p>pop()：移除数组最后一项，<code>返回</code>移除的那个值，减少数组的length。</p>\n<ul>\n<li> 书写格式：<code>arr.pop( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];\nvar count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);\nconsole.log(count); 　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　// [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]\nvar item = arr.pop();\nconsole.log(item); 　　　　　　　　　　 // Sean\nconsole.log(arr); 　　　　　　　　　　  // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]\n</code></pre>\n<h2 id=\"shift-和-unshift-数组开头删-增\"><a href=\"#shift-和-unshift-数组开头删-增\" class=\"headerlink\" title=\"shift() 和 unshift()    数组开头删/增\"></a>shift() 和 unshift()    数组开头删/增</h2><p>(和上面的push，pop相反，针对第一项内容)</p>\n<p><strong>shift()：删除原数组第一项，并<code>返回</code>删除元素的值；如果数组为空则<code>返回</code>undefined 。</strong></p>\n<p><strong>unshift:将参数添加到原数组开头，并<code>返回</code>数组的长度 。</strong></p>\n<ul>\n<li>书写格式：<code>arr.shift(&quot; &quot;)</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];\nvar count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);\nconsole.log(count); 　　　　　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　　　　　//[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]\nvar item = arr.shift();\nconsole.log(item); 　　　　　　　　　　　　　　// Jack\nconsole.log(arr); 　　　　　　　　　　　　　　 // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]\n</code></pre>\n<h2 id=\"sort-数组从小到大排序\"><a href=\"#sort-数组从小到大排序\" class=\"headerlink\" title=\"sort()    数组从小到大排序\"></a>sort()    数组从小到大排序</h2><p><strong>sort()：将数组里的项从小到大排序</strong></p>\n<ul>\n<li>书写格式：<code>arr.sort( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];\nconsole.log(arr1.sort()); 　　　　　　　　　　// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]\n</code></pre>\n<ul>\n<li>sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数</li>\n</ul>\n<pre><code class=\"js\">function sortNumber(a,b)\n&#123;\n　　return a - b\n&#125;\n</code></pre>\n<pre><code class=\"js\">arr = [13, 24, 51, 3]; \nconsole.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] \nconsole.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)\n</code></pre>\n<h2 id=\"reverse-数组翻转\"><a href=\"#reverse-数组翻转\" class=\"headerlink\" title=\"reverse()    数组翻转\"></a>reverse()    数组翻转</h2><p>reverse()：反转数组项的顺序。</p>\n<ul>\n<li>书写格式：<code>arr.reverse( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)\n</code></pre>\n<h2 id=\"concat-数组的拼接\"><a href=\"#concat-数组的拼接\" class=\"headerlink\" title=\"concat()    数组的拼接\"></a>concat()    数组的拼接</h2><p><strong>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后<code>返回</code>新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并<code>返回</code>副本。</strong></p>\n<ul>\n<li>书写格式：<code>arr.concat()</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)\n</code></pre>\n<h2 id=\"slice-截取\"><a href=\"#slice-截取\" class=\"headerlink\" title=\"slice()     截取\"></a>slice()     截取</h2><p><strong>slice()：<code>返回</code>从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要<code>返回</code>项的起始和结束位置。在只有一个参数的情况下， slice()方法<code>返回</code>从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法<code>返回</code>起始和结束位置之间的项——但不包括结束位置的项。</strong></p>\n<ul>\n<li>书写格式：<code>arr.slice( 1 , 3 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]\n</code></pre>\n<ul>\n<li>arrCopy只设置了一个参数，也就是起始下标为1，所以<code>返回</code>的数组为下标1（包括下标1）开始到数组最后。 </li>\n<li>arrCopy2设置了两个参数，<code>返回</code>起始下标（包括1）开始到终止下标（不包括4）的子数组。 </li>\n<li>arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 </li>\n<li>arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。</li>\n</ul>\n<h2 id=\"splice-删除，增加，替换\"><a href=\"#splice-删除，增加，替换\" class=\"headerlink\" title=\"splice    删除，增加，替换\"></a>splice    删除，增加，替换</h2><p>splice()：删除、插入和替换。</p>\n<p><strong>删除</strong>：指定 2 个参数：要删除的第一项的位置和要删除的项数。</p>\n<ul>\n<li>书写格式：<code>arr.splice( 1 , 3 )</code></li>\n</ul>\n<p><strong>插入</strong>：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。</p>\n<ul>\n<li> 书写格式：<code>arr.splice( 2,0,4,6 )</code></li>\n</ul>\n<p><strong>替换</strong>：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</p>\n<ul>\n<li>书写格式：<code>arr.splice( 2,0,4,6 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]\nconsole.log(arrRemoved); 　　　　　　　　　　　//[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); 　　　　　　　　　　// []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); 　　　　　　　　　　// [7]\n</code></pre>\n<h2 id=\"indexOf-和-lastIndexOf-查找\"><a href=\"#indexOf-和-lastIndexOf-查找\" class=\"headerlink\" title=\"indexOf()和 lastIndexOf()    查找\"></a>indexOf()和 lastIndexOf()    查找</h2><p><strong>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。</strong></p>\n<ul>\n<li>书写格式：<code>arr.indexof( 5 )</code></li>\n</ul>\n<p><strong>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</strong></p>\n<ul>\n<li>书写格式：<code>arr.lastIndexOf( 5,4 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); 　　　　　　//2\nconsole.log(arr.lastIndexOf(5)); 　　　 //5\nconsole.log(arr.indexOf(5,2)); 　　　　 //2\nconsole.log(arr.lastIndexOf(5,4)); 　　//2\nconsole.log(arr.indexOf(&quot;5&quot;)); 　　　　 //-1\n</code></pre>\n<h2 id=\"forEach-遍历\"><a href=\"#forEach-遍历\" class=\"headerlink\" title=\"forEach()    遍历\"></a>forEach()    遍历</h2><p><strong>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有<code>返回</code>值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</strong></p>\n<ul>\n<li>书写格式：<code>arr.forEach()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a)&#123;\nconsole.log(x + &#39;|&#39; + index + &#39;|&#39; + (a === arr));\n&#125;);\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n</code></pre>\n<h2 id=\"map-遍历\"><a href=\"#map-遍历\" class=\"headerlink\" title=\"map()    遍历\"></a>map()    遍历</h2><p><strong>map()：指“映射”，对数组中的每一项运行给定函数，<code>返回</code>每次函数调用的结果组成的数组。</strong></p>\n<p>书写格式：<code>arr.map()</code></p>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item)&#123;\nreturn item*item;\n&#125;);\nconsole.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]\n</code></pre>\n<h2 id=\"filter-过滤\"><a href=\"#filter-过滤\" class=\"headerlink\" title=\"filter()    过滤\"></a>filter()    过滤</h2><p><strong>filter()：“过滤”功能，数组中的每一项运行给定函数，<code>返回</code>满足过滤条件组成的数组。</strong></p>\n<ul>\n<li>书写格式：<code>arr.filter()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) &#123;\nreturn index % 3 === 0 || x &gt;= 8;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]\n</code></pre>\n<h2 id=\"every-判断是否每一项满足条件\"><a href=\"#every-判断是否每一项满足条件\" class=\"headerlink\" title=\"every()    判断是否每一项满足条件\"></a>every()    判断是否每一项满足条件</h2><p><strong>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会<code>返回</code>true。</strong></p>\n<ul>\n<li>书写格式：<code>arr.every()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) &#123;\nreturn x &lt; 10;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.every(function(x) &#123;\nreturn x &lt; 3;\n&#125;); \nconsole.log(arr3); 　　　　　　　　// false\n</code></pre>\n<h2 id=\"some-判断是否有一项满足条件\"><a href=\"#some-判断是否有一项满足条件\" class=\"headerlink\" title=\"some()    判断是否有一项满足条件\"></a>some()    判断是否有一项满足条件</h2><p><strong>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会<code>返回</code>true。</strong></p>\n<ul>\n<li>书写格式：<code>arr.some()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) &#123;\nreturn x &lt; 3;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.some(function(x) &#123;\nreturn x &lt; 1;\n&#125;); \nconsole.log(arr3); 　　　　　　　　// false\n</code></pre>\n<h1 id=\"string字符串\"><a href=\"#string字符串\" class=\"headerlink\" title=\"string字符串\"></a>string字符串</h1><table>\n<thead>\n<tr>\n<th><strong>charAT（index）</strong></th>\n<th>通过索引找字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>charCodeAt</strong>（index）</td>\n<td>通过索引找到字符的 Unicode 编码。这个<code>返回</code>值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者<code>返回</code>的是位于指定位置的字符的编码，而后者<code>返回</code>的是字符子串。</td>\n</tr>\n<tr>\n<td><strong>indexOf（）</strong></td>\n<td>从前往后找，找到<code>返回</code>内容的索引，找不到<code>返回</code>-1；</td>\n</tr>\n<tr>\n<td><strong>lastIndexOf</strong>（）</td>\n<td>从后往前找，找到<code>返回</code>内容的索引，找不到<code>返回</code>-1；</td>\n</tr>\n<tr>\n<td><strong>slice（n，m）</strong></td>\n<td>从索引n 查找到索引m  但不包括m，slice可以取负值</td>\n</tr>\n<tr>\n<td><strong>substring（n，m）</strong></td>\n<td>从索引n 查找到索引m ，但不包括m， 不可以取负值</td>\n</tr>\n<tr>\n<td><strong>substr（n，m）</strong></td>\n<td>从索引n开始截取m 个</td>\n</tr>\n<tr>\n<td><strong>split（切割形式）</strong></td>\n<td>把一个字符串分割成字符串数组。</td>\n</tr>\n<tr>\n<td><strong>toUpperCase（）</strong></td>\n<td>转大写字母</td>\n</tr>\n<tr>\n<td><strong>toLowerCase（）</strong></td>\n<td>转小写字母</td>\n</tr>\n<tr>\n<td>replace(n，m)</td>\n<td>替换</td>\n</tr>\n</tbody></table>\n<h1 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h1><table>\n<thead>\n<tr>\n<th><strong>Math.floor（）</strong></th>\n<th>向下取整</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Math.ceil（）</strong></td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td><strong>Math.random（）</strong></td>\n<td>取0-1之间的随机小数</td>\n</tr>\n<tr>\n<td><strong>Math.round（）</strong></td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td><strong>Math.max（）</strong></td>\n<td>取最大值</td>\n</tr>\n<tr>\n<td><strong>Math.min（）</strong></td>\n<td>取最小值</td>\n</tr>\n<tr>\n<td><strong>Math.abs（）</strong></td>\n<td>取绝对值</td>\n</tr>\n<tr>\n<td><strong>Math.pow（x，y）</strong></td>\n<td>x的y次幂</td>\n</tr>\n<tr>\n<td><strong>Math.sqrt（）</strong></td>\n<td>开平方</td>\n</tr>\n</tbody></table>\n<h1 id=\"Date日期对象\"><a href=\"#Date日期对象\" class=\"headerlink\" title=\"Date日期对象\"></a>Date日期对象</h1><table>\n<thead>\n<tr>\n<th><strong>new Date（）</strong></th>\n<th>创建一个日期对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>getFullYear（）</strong></td>\n<td><code>返回</code>年份</td>\n</tr>\n<tr>\n<td><strong>getMonth（）</strong></td>\n<td><code>返回</code>月份数（0-11），想要得到几月，需要加1</td>\n</tr>\n<tr>\n<td><strong>getDay（）</strong></td>\n<td><code>返回</code>一周的第几天（0-6），想要得到星期几，需要加一</td>\n</tr>\n<tr>\n<td><strong>getDate（）</strong></td>\n<td><code>返回</code>日</td>\n</tr>\n<tr>\n<td><strong>getHours（）</strong></td>\n<td><code>返回</code>时</td>\n</tr>\n<tr>\n<td><strong>getMinutes（）</strong></td>\n<td><code>返回</code>分</td>\n</tr>\n<tr>\n<td><strong>getSeconds（）</strong></td>\n<td><code>返回</code>秒</td>\n</tr>\n<tr>\n<td><strong>getTime（）</strong></td>\n<td><code>返回</code>从1970年1月1日00：00到现在的毫秒数（格林尼治时间），也就是时间戳</td>\n</tr>\n<tr>\n<td><strong>setYear(yearInt)</strong></td>\n<td>设置年份.2位数或4位数</td>\n</tr>\n<tr>\n<td><strong>setFullYear(yearInt)</strong></td>\n<td>设置年份.4位数</td>\n</tr>\n<tr>\n<td><strong>setMonth(monthInt)</strong></td>\n<td>设置月份(0-11)</td>\n</tr>\n<tr>\n<td><strong>setDate(dateInt)</strong></td>\n<td>设置日(1-31)</td>\n</tr>\n<tr>\n<td><strong>setHours(hourInt)</strong></td>\n<td>设置小时数(0-23)</td>\n</tr>\n<tr>\n<td><strong>setMinutes(minInt)</strong></td>\n<td>设置分钟数(0-59)</td>\n</tr>\n<tr>\n<td><strong>setSeconds(secInt)</strong></td>\n<td>设置秒数(0-59)</td>\n</tr>\n<tr>\n<td><strong>setMilliseconds(milliInt)</strong></td>\n<td>设置毫秒(0-999)</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h1><ul>\n<li>join()  将数组按什么格式拼接为字符串。</li>\n<li>push()和pop() 添加 和 最后一个元素。</li>\n<li>shift() 和 unshift()  添加和删除第一个元素。</li>\n<li>sort() 从小到大排序数组。</li>\n<li>reverse() 反转数组，改变原数组</li>\n<li>concat() 拼接数组</li>\n<li>slice() 截取数组，从第几个位置开始，第几个位置结束</li>\n<li>splice() 截取数组，从第几个位置开始，截取几个下标。</li>\n<li>indexOf()和 lastIndexOf() （ES5新增）查找匹配的第一个元素，有返回下标无返回-1</li>\n<li>forEach() （ES5新增）循环数组，不会改变元素本身。</li>\n<li>map() （ES5新增）遍历数组，对其每一个元素进行操作后返回，会返回一个新数组。</li>\n<li>filter() （ES5新增）遍历数组，如果为true 返回当前元素。</li>\n<li>every () （ES5新增）遍历数组，所有元素都为true才会返回true</li>\n<li>some () （ES5新增） 遍历数组，有一项为true就为true</li>\n</ul>\n<h2 id=\"join-转成字符串\"><a href=\"#join-转成字符串\" class=\"headerlink\" title=\"join()    转成字符串\"></a>join()    转成字符串</h2><p>join，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)</p>\n<ul>\n<li>书写格式：<code>join(&quot; &quot;)</code>，括号里面写字符串 (“要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [1,2,3];\nconsole.log(arr.join()); 　　　　// 1,2,3\nconsole.log(arr.join(&quot;-&quot;)); 　　// 1-2-3\nconsole.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）\n</code></pre>\n<h2 id=\"push-和pop-数组末尾增-删\"><a href=\"#push-和pop-数组末尾增-删\" class=\"headerlink\" title=\"push()和pop()    数组末尾增/删\"></a>push()和pop()    数组末尾增/删</h2><p>push(): 把里面的内容添加到数组末尾，并<code>返回</code>修改后的长度。</p>\n<ul>\n<li>书写格式：<code>arr.push(&quot; &quot;)</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<p>pop()：移除数组最后一项，<code>返回</code>移除的那个值，减少数组的length。</p>\n<ul>\n<li> 书写格式：<code>arr.pop( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];\nvar count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);\nconsole.log(count); 　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　// [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]\nvar item = arr.pop();\nconsole.log(item); 　　　　　　　　　　 // Sean\nconsole.log(arr); 　　　　　　　　　　  // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]\n</code></pre>\n<h2 id=\"shift-和-unshift-数组开头删-增\"><a href=\"#shift-和-unshift-数组开头删-增\" class=\"headerlink\" title=\"shift() 和 unshift()    数组开头删/增\"></a>shift() 和 unshift()    数组开头删/增</h2><p>(和上面的push，pop相反，针对第一项内容)</p>\n<p><strong>shift()：删除原数组第一项，并<code>返回</code>删除元素的值；如果数组为空则<code>返回</code>undefined 。</strong></p>\n<p><strong>unshift:将参数添加到原数组开头，并<code>返回</code>数组的长度 。</strong></p>\n<ul>\n<li>书写格式：<code>arr.shift(&quot; &quot;)</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];\nvar count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);\nconsole.log(count); 　　　　　　　　　　　　　　// 5\nconsole.log(arr); 　　　　　　　　　　　　　　　//[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]\nvar item = arr.shift();\nconsole.log(item); 　　　　　　　　　　　　　　// Jack\nconsole.log(arr); 　　　　　　　　　　　　　　 // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]\n</code></pre>\n<h2 id=\"sort-数组从小到大排序\"><a href=\"#sort-数组从小到大排序\" class=\"headerlink\" title=\"sort()    数组从小到大排序\"></a>sort()    数组从小到大排序</h2><p><strong>sort()：将数组里的项从小到大排序</strong></p>\n<ul>\n<li>书写格式：<code>arr.sort( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];\nconsole.log(arr1.sort()); 　　　　　　　　　　// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]\n</code></pre>\n<ul>\n<li>sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数</li>\n</ul>\n<pre><code class=\"js\">function sortNumber(a,b)\n&#123;\n　　return a - b\n&#125;\n</code></pre>\n<pre><code class=\"js\">arr = [13, 24, 51, 3]; \nconsole.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] \nconsole.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)\n</code></pre>\n<h2 id=\"reverse-数组翻转\"><a href=\"#reverse-数组翻转\" class=\"headerlink\" title=\"reverse()    数组翻转\"></a>reverse()    数组翻转</h2><p>reverse()：反转数组项的顺序。</p>\n<ul>\n<li>书写格式：<code>arr.reverse( )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)\n</code></pre>\n<h2 id=\"concat-数组的拼接\"><a href=\"#concat-数组的拼接\" class=\"headerlink\" title=\"concat()    数组的拼接\"></a>concat()    数组的拼接</h2><p><strong>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后<code>返回</code>新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并<code>返回</code>副本。</strong></p>\n<ul>\n<li>书写格式：<code>arr.concat()</code>，括号里面写内容 (“字符串要加引号”),</li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)\n</code></pre>\n<h2 id=\"slice-截取\"><a href=\"#slice-截取\" class=\"headerlink\" title=\"slice()     截取\"></a>slice()     截取</h2><p><strong>slice()：<code>返回</code>从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要<code>返回</code>项的起始和结束位置。在只有一个参数的情况下， slice()方法<code>返回</code>从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法<code>返回</code>起始和结束位置之间的项——但不包括结束位置的项。</strong></p>\n<ul>\n<li>书写格式：<code>arr.slice( 1 , 3 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]\nconsole.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]\n</code></pre>\n<ul>\n<li>arrCopy只设置了一个参数，也就是起始下标为1，所以<code>返回</code>的数组为下标1（包括下标1）开始到数组最后。 </li>\n<li>arrCopy2设置了两个参数，<code>返回</code>起始下标（包括1）开始到终止下标（不包括4）的子数组。 </li>\n<li>arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 </li>\n<li>arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。</li>\n</ul>\n<h2 id=\"splice-删除，增加，替换\"><a href=\"#splice-删除，增加，替换\" class=\"headerlink\" title=\"splice    删除，增加，替换\"></a>splice    删除，增加，替换</h2><p>splice()：删除、插入和替换。</p>\n<p><strong>删除</strong>：指定 2 个参数：要删除的第一项的位置和要删除的项数。</p>\n<ul>\n<li>书写格式：<code>arr.splice( 1 , 3 )</code></li>\n</ul>\n<p><strong>插入</strong>：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。</p>\n<ul>\n<li> 书写格式：<code>arr.splice( 2,0,4,6 )</code></li>\n</ul>\n<p><strong>替换</strong>：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</p>\n<ul>\n<li>书写格式：<code>arr.splice( 2,0,4,6 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]\nconsole.log(arrRemoved); 　　　　　　　　　　　//[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); 　　　　　　　　　　// []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); 　　　　　　　　　　// [7]\n</code></pre>\n<h2 id=\"indexOf-和-lastIndexOf-查找\"><a href=\"#indexOf-和-lastIndexOf-查找\" class=\"headerlink\" title=\"indexOf()和 lastIndexOf()    查找\"></a>indexOf()和 lastIndexOf()    查找</h2><p><strong>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。</strong></p>\n<ul>\n<li>书写格式：<code>arr.indexof( 5 )</code></li>\n</ul>\n<p><strong>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</strong></p>\n<ul>\n<li>书写格式：<code>arr.lastIndexOf( 5,4 )</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); 　　　　　　//2\nconsole.log(arr.lastIndexOf(5)); 　　　 //5\nconsole.log(arr.indexOf(5,2)); 　　　　 //2\nconsole.log(arr.lastIndexOf(5,4)); 　　//2\nconsole.log(arr.indexOf(&quot;5&quot;)); 　　　　 //-1\n</code></pre>\n<h2 id=\"forEach-遍历\"><a href=\"#forEach-遍历\" class=\"headerlink\" title=\"forEach()    遍历\"></a>forEach()    遍历</h2><p><strong>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有<code>返回</code>值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</strong></p>\n<ul>\n<li>书写格式：<code>arr.forEach()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a)&#123;\nconsole.log(x + &#39;|&#39; + index + &#39;|&#39; + (a === arr));\n&#125;);\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n</code></pre>\n<h2 id=\"map-遍历\"><a href=\"#map-遍历\" class=\"headerlink\" title=\"map()    遍历\"></a>map()    遍历</h2><p><strong>map()：指“映射”，对数组中的每一项运行给定函数，<code>返回</code>每次函数调用的结果组成的数组。</strong></p>\n<p>书写格式：<code>arr.map()</code></p>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item)&#123;\nreturn item*item;\n&#125;);\nconsole.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]\n</code></pre>\n<h2 id=\"filter-过滤\"><a href=\"#filter-过滤\" class=\"headerlink\" title=\"filter()    过滤\"></a>filter()    过滤</h2><p><strong>filter()：“过滤”功能，数组中的每一项运行给定函数，<code>返回</code>满足过滤条件组成的数组。</strong></p>\n<ul>\n<li>书写格式：<code>arr.filter()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) &#123;\nreturn index % 3 === 0 || x &gt;= 8;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]\n</code></pre>\n<h2 id=\"every-判断是否每一项满足条件\"><a href=\"#every-判断是否每一项满足条件\" class=\"headerlink\" title=\"every()    判断是否每一项满足条件\"></a>every()    判断是否每一项满足条件</h2><p><strong>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会<code>返回</code>true。</strong></p>\n<ul>\n<li>书写格式：<code>arr.every()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) &#123;\nreturn x &lt; 10;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.every(function(x) &#123;\nreturn x &lt; 3;\n&#125;); \nconsole.log(arr3); 　　　　　　　　// false\n</code></pre>\n<h2 id=\"some-判断是否有一项满足条件\"><a href=\"#some-判断是否有一项满足条件\" class=\"headerlink\" title=\"some()    判断是否有一项满足条件\"></a>some()    判断是否有一项满足条件</h2><p><strong>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会<code>返回</code>true。</strong></p>\n<ul>\n<li>书写格式：<code>arr.some()</code></li>\n</ul>\n<pre><code class=\"js\">var arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) &#123;\nreturn x &lt; 3;\n&#125;); \nconsole.log(arr2); 　　　　　　　　//true\nvar arr3 = arr.some(function(x) &#123;\nreturn x &lt; 1;\n&#125;); \nconsole.log(arr3); 　　　　　　　　// false\n</code></pre>\n<h1 id=\"string字符串\"><a href=\"#string字符串\" class=\"headerlink\" title=\"string字符串\"></a>string字符串</h1><table>\n<thead>\n<tr>\n<th><strong>charAT（index）</strong></th>\n<th>通过索引找字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>charCodeAt</strong>（index）</td>\n<td>通过索引找到字符的 Unicode 编码。这个<code>返回</code>值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者<code>返回</code>的是位于指定位置的字符的编码，而后者<code>返回</code>的是字符子串。</td>\n</tr>\n<tr>\n<td><strong>indexOf（）</strong></td>\n<td>从前往后找，找到<code>返回</code>内容的索引，找不到<code>返回</code>-1；</td>\n</tr>\n<tr>\n<td><strong>lastIndexOf</strong>（）</td>\n<td>从后往前找，找到<code>返回</code>内容的索引，找不到<code>返回</code>-1；</td>\n</tr>\n<tr>\n<td><strong>slice（n，m）</strong></td>\n<td>从索引n 查找到索引m  但不包括m，slice可以取负值</td>\n</tr>\n<tr>\n<td><strong>substring（n，m）</strong></td>\n<td>从索引n 查找到索引m ，但不包括m， 不可以取负值</td>\n</tr>\n<tr>\n<td><strong>substr（n，m）</strong></td>\n<td>从索引n开始截取m 个</td>\n</tr>\n<tr>\n<td><strong>split（切割形式）</strong></td>\n<td>把一个字符串分割成字符串数组。</td>\n</tr>\n<tr>\n<td><strong>toUpperCase（）</strong></td>\n<td>转大写字母</td>\n</tr>\n<tr>\n<td><strong>toLowerCase（）</strong></td>\n<td>转小写字母</td>\n</tr>\n<tr>\n<td>replace(n，m)</td>\n<td>替换</td>\n</tr>\n</tbody></table>\n<h1 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h1><table>\n<thead>\n<tr>\n<th><strong>Math.floor（）</strong></th>\n<th>向下取整</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Math.ceil（）</strong></td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td><strong>Math.random（）</strong></td>\n<td>取0-1之间的随机小数</td>\n</tr>\n<tr>\n<td><strong>Math.round（）</strong></td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td><strong>Math.max（）</strong></td>\n<td>取最大值</td>\n</tr>\n<tr>\n<td><strong>Math.min（）</strong></td>\n<td>取最小值</td>\n</tr>\n<tr>\n<td><strong>Math.abs（）</strong></td>\n<td>取绝对值</td>\n</tr>\n<tr>\n<td><strong>Math.pow（x，y）</strong></td>\n<td>x的y次幂</td>\n</tr>\n<tr>\n<td><strong>Math.sqrt（）</strong></td>\n<td>开平方</td>\n</tr>\n</tbody></table>\n<h1 id=\"Date日期对象\"><a href=\"#Date日期对象\" class=\"headerlink\" title=\"Date日期对象\"></a>Date日期对象</h1><table>\n<thead>\n<tr>\n<th><strong>new Date（）</strong></th>\n<th>创建一个日期对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>getFullYear（）</strong></td>\n<td><code>返回</code>年份</td>\n</tr>\n<tr>\n<td><strong>getMonth（）</strong></td>\n<td><code>返回</code>月份数（0-11），想要得到几月，需要加1</td>\n</tr>\n<tr>\n<td><strong>getDay（）</strong></td>\n<td><code>返回</code>一周的第几天（0-6），想要得到星期几，需要加一</td>\n</tr>\n<tr>\n<td><strong>getDate（）</strong></td>\n<td><code>返回</code>日</td>\n</tr>\n<tr>\n<td><strong>getHours（）</strong></td>\n<td><code>返回</code>时</td>\n</tr>\n<tr>\n<td><strong>getMinutes（）</strong></td>\n<td><code>返回</code>分</td>\n</tr>\n<tr>\n<td><strong>getSeconds（）</strong></td>\n<td><code>返回</code>秒</td>\n</tr>\n<tr>\n<td><strong>getTime（）</strong></td>\n<td><code>返回</code>从1970年1月1日00：00到现在的毫秒数（格林尼治时间），也就是时间戳</td>\n</tr>\n<tr>\n<td><strong>setYear(yearInt)</strong></td>\n<td>设置年份.2位数或4位数</td>\n</tr>\n<tr>\n<td><strong>setFullYear(yearInt)</strong></td>\n<td>设置年份.4位数</td>\n</tr>\n<tr>\n<td><strong>setMonth(monthInt)</strong></td>\n<td>设置月份(0-11)</td>\n</tr>\n<tr>\n<td><strong>setDate(dateInt)</strong></td>\n<td>设置日(1-31)</td>\n</tr>\n<tr>\n<td><strong>setHours(hourInt)</strong></td>\n<td>设置小时数(0-23)</td>\n</tr>\n<tr>\n<td><strong>setMinutes(minInt)</strong></td>\n<td>设置分钟数(0-59)</td>\n</tr>\n<tr>\n<td><strong>setSeconds(secInt)</strong></td>\n<td>设置秒数(0-59)</td>\n</tr>\n<tr>\n<td><strong>setMilliseconds(milliInt)</strong></td>\n<td>设置毫秒(0-999)</td>\n</tr>\n</tbody></table>\n"},{"title":"vue基础-问题","date":"2020-08-20T13:34:23.000Z","_content":"[toc]\n\n\n\n### watch的immediate执行,优先于mounted\n\n```js\nwangeditor 富文本编辑器的使用\n手动监听watch, 写到watch配置项里面的监听是随着实例初始化一起完成的\nthis.$watch('value',()=>{\n    this.xxx\n},{\n\timmediate:true\n})\n```\n\n### 木偶组件，智能组件，业务组件，通用组件\n\n```js\n// 智能组件：功能更强大，可以和后端通信并把获取到的数据分发给内部的组件\n//木偶组件：不需要和后端交互，给什么就渲染什么\n```\n\n### 虚拟dom\n\n> 浏览器直接操作dom很浪费性能，通过js的形式模拟一个对象形式的dom\n\n","source":"_posts/笔记/ocean/12-Vue总结/问提.md","raw":"---\ntitle: vue基础-问题\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n[toc]\n\n\n\n### watch的immediate执行,优先于mounted\n\n```js\nwangeditor 富文本编辑器的使用\n手动监听watch, 写到watch配置项里面的监听是随着实例初始化一起完成的\nthis.$watch('value',()=>{\n    this.xxx\n},{\n\timmediate:true\n})\n```\n\n### 木偶组件，智能组件，业务组件，通用组件\n\n```js\n// 智能组件：功能更强大，可以和后端通信并把获取到的数据分发给内部的组件\n//木偶组件：不需要和后端交互，给什么就渲染什么\n```\n\n### 虚拟dom\n\n> 浏览器直接操作dom很浪费性能，通过js的形式模拟一个对象形式的dom\n\n","slug":"笔记/ocean/12-Vue总结/问提","published":1,"updated":"2023-03-01T07:28:58.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcb0016awafdsa5e4b6","content":"<p>[toc]</p>\n<h3 id=\"watch的immediate执行-优先于mounted\"><a href=\"#watch的immediate执行-优先于mounted\" class=\"headerlink\" title=\"watch的immediate执行,优先于mounted\"></a>watch的immediate执行,优先于mounted</h3><pre><code class=\"js\">wangeditor 富文本编辑器的使用\n手动监听watch, 写到watch配置项里面的监听是随着实例初始化一起完成的\nthis.$watch(&#39;value&#39;,()=&gt;&#123;\n    this.xxx\n&#125;,&#123;\n    immediate:true\n&#125;)\n</code></pre>\n<h3 id=\"木偶组件，智能组件，业务组件，通用组件\"><a href=\"#木偶组件，智能组件，业务组件，通用组件\" class=\"headerlink\" title=\"木偶组件，智能组件，业务组件，通用组件\"></a>木偶组件，智能组件，业务组件，通用组件</h3><pre><code class=\"js\">// 智能组件：功能更强大，可以和后端通信并把获取到的数据分发给内部的组件\n//木偶组件：不需要和后端交互，给什么就渲染什么\n</code></pre>\n<h3 id=\"虚拟dom\"><a href=\"#虚拟dom\" class=\"headerlink\" title=\"虚拟dom\"></a>虚拟dom</h3><blockquote>\n<p>浏览器直接操作dom很浪费性能，通过js的形式模拟一个对象形式的dom</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h3 id=\"watch的immediate执行-优先于mounted\"><a href=\"#watch的immediate执行-优先于mounted\" class=\"headerlink\" title=\"watch的immediate执行,优先于mounted\"></a>watch的immediate执行,优先于mounted</h3><pre><code class=\"js\">wangeditor 富文本编辑器的使用\n手动监听watch, 写到watch配置项里面的监听是随着实例初始化一起完成的\nthis.$watch(&#39;value&#39;,()=&gt;&#123;\n    this.xxx\n&#125;,&#123;\n    immediate:true\n&#125;)\n</code></pre>\n<h3 id=\"木偶组件，智能组件，业务组件，通用组件\"><a href=\"#木偶组件，智能组件，业务组件，通用组件\" class=\"headerlink\" title=\"木偶组件，智能组件，业务组件，通用组件\"></a>木偶组件，智能组件，业务组件，通用组件</h3><pre><code class=\"js\">// 智能组件：功能更强大，可以和后端通信并把获取到的数据分发给内部的组件\n//木偶组件：不需要和后端交互，给什么就渲染什么\n</code></pre>\n<h3 id=\"虚拟dom\"><a href=\"#虚拟dom\" class=\"headerlink\" title=\"虚拟dom\"></a>虚拟dom</h3><blockquote>\n<p>浏览器直接操作dom很浪费性能，通过js的形式模拟一个对象形式的dom</p>\n</blockquote>\n"},{"title":"javascript是什么","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# js01\n\n## javaScript是什么\n\n+ 一种编程语言，通常用于客户端的网页动态脚本，也常通过Node.js这样的包，用于服务器端\n\n## 引入方式\n\n+ 内嵌，行内，外链\n\n## 注释\n\n```js\n\n// 单行注释 //\n// 多行注释/* */\n\n```\n\n## 输入输出\n\n```js\n//1.弹窗带输入框\nprompt()\n\n//2.弹窗无输入框\nalert()\n\n//3.控制台输出\nconsole.log()\n\n//4.页面输出\ndocument.writer()\n```\n\n## 变量\n\n+ 规范\n  1. 不能以数字开头\n  2. 不可使用关键字，保留字\n\n> 每次var 一次 就相当于在内存上开了一块存储。\n\n```js\n1.声明\nvar a;\nvar a,b,c;\n\n2.赋值\na = 10\n\n3.声明加赋值\nvar a = 10\nvar a = 10,b = 20\n\n4.重新赋值\na = 20\n```\n\n+ 两个变量换值\n\n  ```js\n  var a = 10\n  var b = 20\n  var c \n  c = a\n  a = b\n  b = c\n  ```\n\n  \n\n## 简单数据类型\n\n```js\n1.Number类型\n数字，小数\n\n2.String类型\n以\"\",''包住的文字，字符串\n\n3.Boolean类型\ntrue，false\n\n4.null类\nnull，空\n\n5.undefined\n已声明但为赋值就会出现undefined\n```\n\n+ 类型检查\n\n  ```js\n  //格式：\n  typeof 要检测的数据 //返回值为true和false\n  数据 instanceof\t数据类型 //一致为true \n  ```\n\n+ null和undefined的区别\n\n  null是一个表示无的对象，转为数值为0，undefined是一个表示无的原始值，转为数值为NaN。\n\n  ```js\n  undefined的典型用法：\n  a、变量被声明了，但没有赋值时，就等于undefined\n  b、调用函数时，应该提供的参数没有提供，该参数等于undefined\n  c、对象没有赋值属性，该属性的值为undefined\n  d、函数没有返回值时，默认返回undefined\n  \n  \n  null表示”没有对象”，即该处不应该有值。典型用法是：\n  a、作为函数的参数，表示该函数的参数不是对象\n  b、作为对象原型链的终点\n  ```\n\n  \n\n## 转换方法\n\n+ 转数字\n\n  ```js\n  //1.返回的是Number类型\n  Number(变量)\n  \n  //2.ParseInt()，parseFloat()\n  ParseInt() //转整数，只有前面是数字的字符串才能转为数字，其它为NaN\n  parseFloat() //转小数\n  ```\n\n+ 转字符串\n\n  ```js\n  //1.String()\n  任何数据都可以转为字符串\n  \n  //2.toString()\n  不可以转null,undefined\n  \n  //3.使用+号做隐式转换\n  var a = \"2\" + 1\n  \n  \n  ```\n\n+ 转布尔值\n\n  ```js\n  Boolean(123) //true\n  ```\n\n  + 只有6个情况为false\n    1. 转换0\n    2. 转换NaN\n    3. 转换空字符串\n    4. 转换false\n    5. 转换null\n    6. 转换undefiend\n\n","source":"_posts/笔记/ocean/03-javascript基础总结/01-js是什么/01-笔记.md","raw":"---\ntitle: javascript是什么\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# js01\n\n## javaScript是什么\n\n+ 一种编程语言，通常用于客户端的网页动态脚本，也常通过Node.js这样的包，用于服务器端\n\n## 引入方式\n\n+ 内嵌，行内，外链\n\n## 注释\n\n```js\n\n// 单行注释 //\n// 多行注释/* */\n\n```\n\n## 输入输出\n\n```js\n//1.弹窗带输入框\nprompt()\n\n//2.弹窗无输入框\nalert()\n\n//3.控制台输出\nconsole.log()\n\n//4.页面输出\ndocument.writer()\n```\n\n## 变量\n\n+ 规范\n  1. 不能以数字开头\n  2. 不可使用关键字，保留字\n\n> 每次var 一次 就相当于在内存上开了一块存储。\n\n```js\n1.声明\nvar a;\nvar a,b,c;\n\n2.赋值\na = 10\n\n3.声明加赋值\nvar a = 10\nvar a = 10,b = 20\n\n4.重新赋值\na = 20\n```\n\n+ 两个变量换值\n\n  ```js\n  var a = 10\n  var b = 20\n  var c \n  c = a\n  a = b\n  b = c\n  ```\n\n  \n\n## 简单数据类型\n\n```js\n1.Number类型\n数字，小数\n\n2.String类型\n以\"\",''包住的文字，字符串\n\n3.Boolean类型\ntrue，false\n\n4.null类\nnull，空\n\n5.undefined\n已声明但为赋值就会出现undefined\n```\n\n+ 类型检查\n\n  ```js\n  //格式：\n  typeof 要检测的数据 //返回值为true和false\n  数据 instanceof\t数据类型 //一致为true \n  ```\n\n+ null和undefined的区别\n\n  null是一个表示无的对象，转为数值为0，undefined是一个表示无的原始值，转为数值为NaN。\n\n  ```js\n  undefined的典型用法：\n  a、变量被声明了，但没有赋值时，就等于undefined\n  b、调用函数时，应该提供的参数没有提供，该参数等于undefined\n  c、对象没有赋值属性，该属性的值为undefined\n  d、函数没有返回值时，默认返回undefined\n  \n  \n  null表示”没有对象”，即该处不应该有值。典型用法是：\n  a、作为函数的参数，表示该函数的参数不是对象\n  b、作为对象原型链的终点\n  ```\n\n  \n\n## 转换方法\n\n+ 转数字\n\n  ```js\n  //1.返回的是Number类型\n  Number(变量)\n  \n  //2.ParseInt()，parseFloat()\n  ParseInt() //转整数，只有前面是数字的字符串才能转为数字，其它为NaN\n  parseFloat() //转小数\n  ```\n\n+ 转字符串\n\n  ```js\n  //1.String()\n  任何数据都可以转为字符串\n  \n  //2.toString()\n  不可以转null,undefined\n  \n  //3.使用+号做隐式转换\n  var a = \"2\" + 1\n  \n  \n  ```\n\n+ 转布尔值\n\n  ```js\n  Boolean(123) //true\n  ```\n\n  + 只有6个情况为false\n    1. 转换0\n    2. 转换NaN\n    3. 转换空字符串\n    4. 转换false\n    5. 转换null\n    6. 转换undefiend\n\n","slug":"笔记/ocean/03-javascript基础总结/01-js是什么/01-笔记","published":1,"updated":"2023-03-01T07:07:01.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcc0018awaf797e3avq","content":"<h1 id=\"js01\"><a href=\"#js01\" class=\"headerlink\" title=\"js01\"></a>js01</h1><h2 id=\"javaScript是什么\"><a href=\"#javaScript是什么\" class=\"headerlink\" title=\"javaScript是什么\"></a>javaScript是什么</h2><ul>\n<li>一种编程语言，通常用于客户端的网页动态脚本，也常通过Node.js这样的包，用于服务器端</li>\n</ul>\n<h2 id=\"引入方式\"><a href=\"#引入方式\" class=\"headerlink\" title=\"引入方式\"></a>引入方式</h2><ul>\n<li>内嵌，行内，外链</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code class=\"js\">\n// 单行注释 //\n// 多行注释/* */\n</code></pre>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><pre><code class=\"js\">//1.弹窗带输入框\nprompt()\n\n//2.弹窗无输入框\nalert()\n\n//3.控制台输出\nconsole.log()\n\n//4.页面输出\ndocument.writer()\n</code></pre>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>规范<ol>\n<li>不能以数字开头</li>\n<li>不可使用关键字，保留字</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>每次var 一次 就相当于在内存上开了一块存储。</p>\n</blockquote>\n<pre><code class=\"js\">1.声明\nvar a;\nvar a,b,c;\n\n2.赋值\na = 10\n\n3.声明加赋值\nvar a = 10\nvar a = 10,b = 20\n\n4.重新赋值\na = 20\n</code></pre>\n<ul>\n<li><p>两个变量换值</p>\n<pre><code class=\"js\">var a = 10\nvar b = 20\nvar c \nc = a\na = b\nb = c\n</code></pre>\n</li>\n</ul>\n<h2 id=\"简单数据类型\"><a href=\"#简单数据类型\" class=\"headerlink\" title=\"简单数据类型\"></a>简单数据类型</h2><pre><code class=\"js\">1.Number类型\n数字，小数\n\n2.String类型\n以&quot;&quot;,&#39;&#39;包住的文字，字符串\n\n3.Boolean类型\ntrue，false\n\n4.null类\nnull，空\n\n5.undefined\n已声明但为赋值就会出现undefined\n</code></pre>\n<ul>\n<li><p>类型检查</p>\n<pre><code class=\"js\">//格式：\ntypeof 要检测的数据 //返回值为true和false\n数据 instanceof    数据类型 //一致为true \n</code></pre>\n</li>\n<li><p>null和undefined的区别</p>\n<p>null是一个表示无的对象，转为数值为0，undefined是一个表示无的原始值，转为数值为NaN。</p>\n<pre><code class=\"js\">undefined的典型用法：\na、变量被声明了，但没有赋值时，就等于undefined\nb、调用函数时，应该提供的参数没有提供，该参数等于undefined\nc、对象没有赋值属性，该属性的值为undefined\nd、函数没有返回值时，默认返回undefined\n\n\nnull表示”没有对象”，即该处不应该有值。典型用法是：\na、作为函数的参数，表示该函数的参数不是对象\nb、作为对象原型链的终点\n</code></pre>\n</li>\n</ul>\n<h2 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h2><ul>\n<li><p>转数字</p>\n<pre><code class=\"js\">//1.返回的是Number类型\nNumber(变量)\n\n//2.ParseInt()，parseFloat()\nParseInt() //转整数，只有前面是数字的字符串才能转为数字，其它为NaN\nparseFloat() //转小数\n</code></pre>\n</li>\n<li><p>转字符串</p>\n<pre><code class=\"js\">//1.String()\n任何数据都可以转为字符串\n\n//2.toString()\n不可以转null,undefined\n\n//3.使用+号做隐式转换\nvar a = &quot;2&quot; + 1\n\n</code></pre>\n</li>\n<li><p>转布尔值</p>\n<pre><code class=\"js\">Boolean(123) //true\n</code></pre>\n<ul>\n<li>只有6个情况为false<ol>\n<li>转换0</li>\n<li>转换NaN</li>\n<li>转换空字符串</li>\n<li>转换false</li>\n<li>转换null</li>\n<li>转换undefiend</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"js01\"><a href=\"#js01\" class=\"headerlink\" title=\"js01\"></a>js01</h1><h2 id=\"javaScript是什么\"><a href=\"#javaScript是什么\" class=\"headerlink\" title=\"javaScript是什么\"></a>javaScript是什么</h2><ul>\n<li>一种编程语言，通常用于客户端的网页动态脚本，也常通过Node.js这样的包，用于服务器端</li>\n</ul>\n<h2 id=\"引入方式\"><a href=\"#引入方式\" class=\"headerlink\" title=\"引入方式\"></a>引入方式</h2><ul>\n<li>内嵌，行内，外链</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code class=\"js\">\n// 单行注释 //\n// 多行注释/* */\n</code></pre>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><pre><code class=\"js\">//1.弹窗带输入框\nprompt()\n\n//2.弹窗无输入框\nalert()\n\n//3.控制台输出\nconsole.log()\n\n//4.页面输出\ndocument.writer()\n</code></pre>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>规范<ol>\n<li>不能以数字开头</li>\n<li>不可使用关键字，保留字</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>每次var 一次 就相当于在内存上开了一块存储。</p>\n</blockquote>\n<pre><code class=\"js\">1.声明\nvar a;\nvar a,b,c;\n\n2.赋值\na = 10\n\n3.声明加赋值\nvar a = 10\nvar a = 10,b = 20\n\n4.重新赋值\na = 20\n</code></pre>\n<ul>\n<li><p>两个变量换值</p>\n<pre><code class=\"js\">var a = 10\nvar b = 20\nvar c \nc = a\na = b\nb = c\n</code></pre>\n</li>\n</ul>\n<h2 id=\"简单数据类型\"><a href=\"#简单数据类型\" class=\"headerlink\" title=\"简单数据类型\"></a>简单数据类型</h2><pre><code class=\"js\">1.Number类型\n数字，小数\n\n2.String类型\n以&quot;&quot;,&#39;&#39;包住的文字，字符串\n\n3.Boolean类型\ntrue，false\n\n4.null类\nnull，空\n\n5.undefined\n已声明但为赋值就会出现undefined\n</code></pre>\n<ul>\n<li><p>类型检查</p>\n<pre><code class=\"js\">//格式：\ntypeof 要检测的数据 //返回值为true和false\n数据 instanceof    数据类型 //一致为true \n</code></pre>\n</li>\n<li><p>null和undefined的区别</p>\n<p>null是一个表示无的对象，转为数值为0，undefined是一个表示无的原始值，转为数值为NaN。</p>\n<pre><code class=\"js\">undefined的典型用法：\na、变量被声明了，但没有赋值时，就等于undefined\nb、调用函数时，应该提供的参数没有提供，该参数等于undefined\nc、对象没有赋值属性，该属性的值为undefined\nd、函数没有返回值时，默认返回undefined\n\n\nnull表示”没有对象”，即该处不应该有值。典型用法是：\na、作为函数的参数，表示该函数的参数不是对象\nb、作为对象原型链的终点\n</code></pre>\n</li>\n</ul>\n<h2 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h2><ul>\n<li><p>转数字</p>\n<pre><code class=\"js\">//1.返回的是Number类型\nNumber(变量)\n\n//2.ParseInt()，parseFloat()\nParseInt() //转整数，只有前面是数字的字符串才能转为数字，其它为NaN\nparseFloat() //转小数\n</code></pre>\n</li>\n<li><p>转字符串</p>\n<pre><code class=\"js\">//1.String()\n任何数据都可以转为字符串\n\n//2.toString()\n不可以转null,undefined\n\n//3.使用+号做隐式转换\nvar a = &quot;2&quot; + 1\n\n</code></pre>\n</li>\n<li><p>转布尔值</p>\n<pre><code class=\"js\">Boolean(123) //true\n</code></pre>\n<ul>\n<li>只有6个情况为false<ol>\n<li>转换0</li>\n<li>转换NaN</li>\n<li>转换空字符串</li>\n<li>转换false</li>\n<li>转换null</li>\n<li>转换undefiend</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"vue原理","date":"2020-08-20T13:34:23.000Z","_content":"[TOC]\n\n## mvc和mvvm\n\n### mvc\n\n```js\nview(视图层)  \ncontroller(路由，控制器)\nmodel(后端给的JSON数据或死数据)\n\n用户通过视图向后端发送请求，通过路由拦截，转发到对应的控制器的处理，获取到后端数据，最终渲染到页面\n```\n\n```mermaid\ngraph TD\nA[View:视图发送请求] -->B[Controller:路由拦截转发到对应控制器]\n\tB --> C[Model:后端数据]\n```\n\n### mvvm\n\n```js\nModel(数据)\nView(视图)\nViewModel(视图数据)\n\n\nVue就是一个典型的 mvvm 。\n直接把数据挂载在vue实例中，通过vue可直接将数据渲染视图\n视图发生改变，vue也会监听到视图的变化，在将视图中的数据写回数据层，\n数据发生改变时，vue也会监听到数据变化，在将数据同步到视图。\n称为数据的双向绑定。\n```\n\n```mermaid\ngraph TD\nA[view:视图] -->B[viewModel:视图模型]\n\tB -->C[model:数据]\n```\n\n\n\n## 监听响应式数据\n\n### 监听对象变化\n\n> 通过数据劫持结合发布者,订阅者模式的方式来实的,通过 Object.definePropertyget劫持各个属性的getter和setter方法，get是获取属性时调用，set属性变化时调用，从而可以在里面做一些更新视图的操作，但是订阅者(watcher)是有多个的，怎么能知道那些订阅者需要更新，这时候就需要使用一个dep来收集订阅者(watcher)，进行统一管理，此外还需要一个指令解析器，对每个节点元素进行扫描和解析指令，再将对应的指令初始化并绑定相应更新(update)函数，此时订阅者接收到相应属性的变化，就会执行对应的更新函数，实现更新视图。\n\n```js\n执行的步骤大概是这样的：\n\n1.vue实例在初始化时会拿到当前data中的数据，调用一个 initData(vm) 方法初始化数据。 \n2.在 initData 方法中调用 Observer(val) 方法并传入数据，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,观测的一种是数组，一种是对象。\n3.如果是对象型非数组的话调用 this.walk(value) 方法，会把当前传入的对象进行循环调用Object.defineProperty。\n4.使用 Object.defineProperty 重新定义数据,在判断如果当前对象的至还是一个对象的话，回到第2步进行递归。\n5.取值时调用 Object.defineProperty 的 get() 方法收集（订阅者）watcher。\n6.如果数据改变时调用set()，通知（订阅者）watcher去更新数据,如果当前值和数据的值不一样的话调用 dep.notify() 通知视图更新。\n\n\t\n** 基础类型的数据是不会进行观测，只监测data对象\n```\n\n### 监听数组的变化\n\n> Object.defineProperty是监听不到数组的变化的，而是使用函数劫持，对数组常用的7个原生可改变数组的方法进行了改写，只要数组一改变就通知观测者\n\n```js\nvue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组内包含引用类型，会对数组中的引用类型再次进行监控。\n\n1.vue初始化时会拿到当前data中的数据，调用 initData(vm) 方法初始化数据。 \n2.在initData中调用 Observer(val) 方法，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,再判断如果有__ob__且类型是observer的话说明已经被监听了直接返回数据，观测的一种是数组，一种是对象。\n3.如果为数组，让就让它的原型链指向 arrayMethods ，来改写数组方法。\n4.只要调用了数组方法，就会执行一个函数，执行原来的方法并通知视图更新，ob.dep.notify()\n5.如果使用了数组新增方法,push,unshift,splice的话，调用ob.observeArray(新增的数据)遍历数组的每个对象进行深度观测，所以只有数组里的对象才能进行响应式的数据变化。\n```\n\n## 为何采用异步渲染\n\n> vue是组件级更新，当组件数据变就会更新 ,如果不采用异步更新，那么组件内的数据每次更新都会对当前组件进行重新渲染， 所以为了性能考虑，vue在本轮数据更新后，再去异步更新视图\n\n```js\n1.当数据变化后，调用dep.notify()方法,通知watcher进行更新\n2.watcher会调用 update() 方法，调用时并不会立即更新，而是调用 queueWatcher方法 判断watcher的id（uid）去重后放入 queue队列 中。\n3.最后在调用 nextTick(flushScheduierQueue) 异步刷新 queue队列,执行watcher,update钩子函数\n\n**可以说是 渲染节流\n```\n\n\n\n## key的原理\n\n> 首先它的作用是：更高效的更新虚拟dom，提高diff算法的速度。\n>\n> 在vue中，我们是不需要直接操作dom的，只需要操作数据就可完成页面的渲染,vue通过虚拟dom去操作真实dom实现渲染，在渲染时使用的是diff算法，v-for更新渲染过的元素列表时会采用就地复用策略，简单复用此处每个元素。\n\n+ 默认的diff算法,也就是不加key的话，比如有abcd4个节点，我们要在b和c之间插入一个e节点，那么当e插进去后，旧节点c的状态就会被e复用，d被c复用,这样新d永远都会在最后一个节点。\n\n+ 加上key之后，相当于给每个节点加上一个唯一的标识，diff算法就可以正确的识别此节点，找到正确的位置插入新节点，并复用自身的状态，从而重用和重新排序已有节点。\n\n+ **diff算法**：通过对比同一层的新旧虚拟dom,将有变化更新的地方渲染在真实dom。\n\n+ **虚拟dom**：用js对象的形式模拟一个真实dom，如果直接操作dom的话，每次更新dom 都会造成重绘和回流，而使用虚拟dom 对比节点时放在js来做，可以避免真实dom 重复大量渲染。\n\n  **其实，虚拟dom的子元素列表只包含文本节点且dom结构一致，不设置key效率会更高，因为不会涉及到过多的判读逻辑**","source":"_posts/笔记/ocean/14-vue原理/01-note.md","raw":"---\ntitle: vue原理\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n[TOC]\n\n## mvc和mvvm\n\n### mvc\n\n```js\nview(视图层)  \ncontroller(路由，控制器)\nmodel(后端给的JSON数据或死数据)\n\n用户通过视图向后端发送请求，通过路由拦截，转发到对应的控制器的处理，获取到后端数据，最终渲染到页面\n```\n\n```mermaid\ngraph TD\nA[View:视图发送请求] -->B[Controller:路由拦截转发到对应控制器]\n\tB --> C[Model:后端数据]\n```\n\n### mvvm\n\n```js\nModel(数据)\nView(视图)\nViewModel(视图数据)\n\n\nVue就是一个典型的 mvvm 。\n直接把数据挂载在vue实例中，通过vue可直接将数据渲染视图\n视图发生改变，vue也会监听到视图的变化，在将视图中的数据写回数据层，\n数据发生改变时，vue也会监听到数据变化，在将数据同步到视图。\n称为数据的双向绑定。\n```\n\n```mermaid\ngraph TD\nA[view:视图] -->B[viewModel:视图模型]\n\tB -->C[model:数据]\n```\n\n\n\n## 监听响应式数据\n\n### 监听对象变化\n\n> 通过数据劫持结合发布者,订阅者模式的方式来实的,通过 Object.definePropertyget劫持各个属性的getter和setter方法，get是获取属性时调用，set属性变化时调用，从而可以在里面做一些更新视图的操作，但是订阅者(watcher)是有多个的，怎么能知道那些订阅者需要更新，这时候就需要使用一个dep来收集订阅者(watcher)，进行统一管理，此外还需要一个指令解析器，对每个节点元素进行扫描和解析指令，再将对应的指令初始化并绑定相应更新(update)函数，此时订阅者接收到相应属性的变化，就会执行对应的更新函数，实现更新视图。\n\n```js\n执行的步骤大概是这样的：\n\n1.vue实例在初始化时会拿到当前data中的数据，调用一个 initData(vm) 方法初始化数据。 \n2.在 initData 方法中调用 Observer(val) 方法并传入数据，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,观测的一种是数组，一种是对象。\n3.如果是对象型非数组的话调用 this.walk(value) 方法，会把当前传入的对象进行循环调用Object.defineProperty。\n4.使用 Object.defineProperty 重新定义数据,在判断如果当前对象的至还是一个对象的话，回到第2步进行递归。\n5.取值时调用 Object.defineProperty 的 get() 方法收集（订阅者）watcher。\n6.如果数据改变时调用set()，通知（订阅者）watcher去更新数据,如果当前值和数据的值不一样的话调用 dep.notify() 通知视图更新。\n\n\t\n** 基础类型的数据是不会进行观测，只监测data对象\n```\n\n### 监听数组的变化\n\n> Object.defineProperty是监听不到数组的变化的，而是使用函数劫持，对数组常用的7个原生可改变数组的方法进行了改写，只要数组一改变就通知观测者\n\n```js\nvue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组内包含引用类型，会对数组中的引用类型再次进行监控。\n\n1.vue初始化时会拿到当前data中的数据，调用 initData(vm) 方法初始化数据。 \n2.在initData中调用 Observer(val) 方法，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,再判断如果有__ob__且类型是observer的话说明已经被监听了直接返回数据，观测的一种是数组，一种是对象。\n3.如果为数组，让就让它的原型链指向 arrayMethods ，来改写数组方法。\n4.只要调用了数组方法，就会执行一个函数，执行原来的方法并通知视图更新，ob.dep.notify()\n5.如果使用了数组新增方法,push,unshift,splice的话，调用ob.observeArray(新增的数据)遍历数组的每个对象进行深度观测，所以只有数组里的对象才能进行响应式的数据变化。\n```\n\n## 为何采用异步渲染\n\n> vue是组件级更新，当组件数据变就会更新 ,如果不采用异步更新，那么组件内的数据每次更新都会对当前组件进行重新渲染， 所以为了性能考虑，vue在本轮数据更新后，再去异步更新视图\n\n```js\n1.当数据变化后，调用dep.notify()方法,通知watcher进行更新\n2.watcher会调用 update() 方法，调用时并不会立即更新，而是调用 queueWatcher方法 判断watcher的id（uid）去重后放入 queue队列 中。\n3.最后在调用 nextTick(flushScheduierQueue) 异步刷新 queue队列,执行watcher,update钩子函数\n\n**可以说是 渲染节流\n```\n\n\n\n## key的原理\n\n> 首先它的作用是：更高效的更新虚拟dom，提高diff算法的速度。\n>\n> 在vue中，我们是不需要直接操作dom的，只需要操作数据就可完成页面的渲染,vue通过虚拟dom去操作真实dom实现渲染，在渲染时使用的是diff算法，v-for更新渲染过的元素列表时会采用就地复用策略，简单复用此处每个元素。\n\n+ 默认的diff算法,也就是不加key的话，比如有abcd4个节点，我们要在b和c之间插入一个e节点，那么当e插进去后，旧节点c的状态就会被e复用，d被c复用,这样新d永远都会在最后一个节点。\n\n+ 加上key之后，相当于给每个节点加上一个唯一的标识，diff算法就可以正确的识别此节点，找到正确的位置插入新节点，并复用自身的状态，从而重用和重新排序已有节点。\n\n+ **diff算法**：通过对比同一层的新旧虚拟dom,将有变化更新的地方渲染在真实dom。\n\n+ **虚拟dom**：用js对象的形式模拟一个真实dom，如果直接操作dom的话，每次更新dom 都会造成重绘和回流，而使用虚拟dom 对比节点时放在js来做，可以避免真实dom 重复大量渲染。\n\n  **其实，虚拟dom的子元素列表只包含文本节点且dom结构一致，不设置key效率会更高，因为不会涉及到过多的判读逻辑**","slug":"笔记/ocean/14-vue原理/01-note","published":1,"updated":"2023-03-01T07:29:17.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcd001aawaf0bpj65tt","content":"<p>[TOC]</p>\n<h2 id=\"mvc和mvvm\"><a href=\"#mvc和mvvm\" class=\"headerlink\" title=\"mvc和mvvm\"></a>mvc和mvvm</h2><h3 id=\"mvc\"><a href=\"#mvc\" class=\"headerlink\" title=\"mvc\"></a>mvc</h3><pre><code class=\"js\">view(视图层)  \ncontroller(路由，控制器)\nmodel(后端给的JSON数据或死数据)\n\n用户通过视图向后端发送请求，通过路由拦截，转发到对应的控制器的处理，获取到后端数据，最终渲染到页面\n</code></pre>\n<pre><code class=\"mermaid\">graph TD\nA[View:视图发送请求] --&gt;B[Controller:路由拦截转发到对应控制器]\n    B --&gt; C[Model:后端数据]\n</code></pre>\n<h3 id=\"mvvm\"><a href=\"#mvvm\" class=\"headerlink\" title=\"mvvm\"></a>mvvm</h3><pre><code class=\"js\">Model(数据)\nView(视图)\nViewModel(视图数据)\n\n\nVue就是一个典型的 mvvm 。\n直接把数据挂载在vue实例中，通过vue可直接将数据渲染视图\n视图发生改变，vue也会监听到视图的变化，在将视图中的数据写回数据层，\n数据发生改变时，vue也会监听到数据变化，在将数据同步到视图。\n称为数据的双向绑定。\n</code></pre>\n<pre><code class=\"mermaid\">graph TD\nA[view:视图] --&gt;B[viewModel:视图模型]\n    B --&gt;C[model:数据]\n</code></pre>\n<h2 id=\"监听响应式数据\"><a href=\"#监听响应式数据\" class=\"headerlink\" title=\"监听响应式数据\"></a>监听响应式数据</h2><h3 id=\"监听对象变化\"><a href=\"#监听对象变化\" class=\"headerlink\" title=\"监听对象变化\"></a>监听对象变化</h3><blockquote>\n<p>通过数据劫持结合发布者,订阅者模式的方式来实的,通过 Object.definePropertyget劫持各个属性的getter和setter方法，get是获取属性时调用，set属性变化时调用，从而可以在里面做一些更新视图的操作，但是订阅者(watcher)是有多个的，怎么能知道那些订阅者需要更新，这时候就需要使用一个dep来收集订阅者(watcher)，进行统一管理，此外还需要一个指令解析器，对每个节点元素进行扫描和解析指令，再将对应的指令初始化并绑定相应更新(update)函数，此时订阅者接收到相应属性的变化，就会执行对应的更新函数，实现更新视图。</p>\n</blockquote>\n<pre><code class=\"js\">执行的步骤大概是这样的：\n\n1.vue实例在初始化时会拿到当前data中的数据，调用一个 initData(vm) 方法初始化数据。 \n2.在 initData 方法中调用 Observer(val) 方法并传入数据，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,观测的一种是数组，一种是对象。\n3.如果是对象型非数组的话调用 this.walk(value) 方法，会把当前传入的对象进行循环调用Object.defineProperty。\n4.使用 Object.defineProperty 重新定义数据,在判断如果当前对象的至还是一个对象的话，回到第2步进行递归。\n5.取值时调用 Object.defineProperty 的 get() 方法收集（订阅者）watcher。\n6.如果数据改变时调用set()，通知（订阅者）watcher去更新数据,如果当前值和数据的值不一样的话调用 dep.notify() 通知视图更新。\n\n    \n** 基础类型的数据是不会进行观测，只监测data对象\n</code></pre>\n<h3 id=\"监听数组的变化\"><a href=\"#监听数组的变化\" class=\"headerlink\" title=\"监听数组的变化\"></a>监听数组的变化</h3><blockquote>\n<p>Object.defineProperty是监听不到数组的变化的，而是使用函数劫持，对数组常用的7个原生可改变数组的方法进行了改写，只要数组一改变就通知观测者</p>\n</blockquote>\n<pre><code class=\"js\">vue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组内包含引用类型，会对数组中的引用类型再次进行监控。\n\n1.vue初始化时会拿到当前data中的数据，调用 initData(vm) 方法初始化数据。 \n2.在initData中调用 Observer(val) 方法，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,再判断如果有__ob__且类型是observer的话说明已经被监听了直接返回数据，观测的一种是数组，一种是对象。\n3.如果为数组，让就让它的原型链指向 arrayMethods ，来改写数组方法。\n4.只要调用了数组方法，就会执行一个函数，执行原来的方法并通知视图更新，ob.dep.notify()\n5.如果使用了数组新增方法,push,unshift,splice的话，调用ob.observeArray(新增的数据)遍历数组的每个对象进行深度观测，所以只有数组里的对象才能进行响应式的数据变化。\n</code></pre>\n<h2 id=\"为何采用异步渲染\"><a href=\"#为何采用异步渲染\" class=\"headerlink\" title=\"为何采用异步渲染\"></a>为何采用异步渲染</h2><blockquote>\n<p>vue是组件级更新，当组件数据变就会更新 ,如果不采用异步更新，那么组件内的数据每次更新都会对当前组件进行重新渲染， 所以为了性能考虑，vue在本轮数据更新后，再去异步更新视图</p>\n</blockquote>\n<pre><code class=\"js\">1.当数据变化后，调用dep.notify()方法,通知watcher进行更新\n2.watcher会调用 update() 方法，调用时并不会立即更新，而是调用 queueWatcher方法 判断watcher的id（uid）去重后放入 queue队列 中。\n3.最后在调用 nextTick(flushScheduierQueue) 异步刷新 queue队列,执行watcher,update钩子函数\n\n**可以说是 渲染节流\n</code></pre>\n<h2 id=\"key的原理\"><a href=\"#key的原理\" class=\"headerlink\" title=\"key的原理\"></a>key的原理</h2><blockquote>\n<p>首先它的作用是：更高效的更新虚拟dom，提高diff算法的速度。</p>\n<p>在vue中，我们是不需要直接操作dom的，只需要操作数据就可完成页面的渲染,vue通过虚拟dom去操作真实dom实现渲染，在渲染时使用的是diff算法，v-for更新渲染过的元素列表时会采用就地复用策略，简单复用此处每个元素。</p>\n</blockquote>\n<ul>\n<li><p>默认的diff算法,也就是不加key的话，比如有abcd4个节点，我们要在b和c之间插入一个e节点，那么当e插进去后，旧节点c的状态就会被e复用，d被c复用,这样新d永远都会在最后一个节点。</p>\n</li>\n<li><p>加上key之后，相当于给每个节点加上一个唯一的标识，diff算法就可以正确的识别此节点，找到正确的位置插入新节点，并复用自身的状态，从而重用和重新排序已有节点。</p>\n</li>\n<li><p><strong>diff算法</strong>：通过对比同一层的新旧虚拟dom,将有变化更新的地方渲染在真实dom。</p>\n</li>\n<li><p><strong>虚拟dom</strong>：用js对象的形式模拟一个真实dom，如果直接操作dom的话，每次更新dom 都会造成重绘和回流，而使用虚拟dom 对比节点时放在js来做，可以避免真实dom 重复大量渲染。</p>\n<p><strong>其实，虚拟dom的子元素列表只包含文本节点且dom结构一致，不设置key效率会更高，因为不会涉及到过多的判读逻辑</strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"mvc和mvvm\"><a href=\"#mvc和mvvm\" class=\"headerlink\" title=\"mvc和mvvm\"></a>mvc和mvvm</h2><h3 id=\"mvc\"><a href=\"#mvc\" class=\"headerlink\" title=\"mvc\"></a>mvc</h3><pre><code class=\"js\">view(视图层)  \ncontroller(路由，控制器)\nmodel(后端给的JSON数据或死数据)\n\n用户通过视图向后端发送请求，通过路由拦截，转发到对应的控制器的处理，获取到后端数据，最终渲染到页面\n</code></pre>\n<pre><code class=\"mermaid\">graph TD\nA[View:视图发送请求] --&gt;B[Controller:路由拦截转发到对应控制器]\n    B --&gt; C[Model:后端数据]\n</code></pre>\n<h3 id=\"mvvm\"><a href=\"#mvvm\" class=\"headerlink\" title=\"mvvm\"></a>mvvm</h3><pre><code class=\"js\">Model(数据)\nView(视图)\nViewModel(视图数据)\n\n\nVue就是一个典型的 mvvm 。\n直接把数据挂载在vue实例中，通过vue可直接将数据渲染视图\n视图发生改变，vue也会监听到视图的变化，在将视图中的数据写回数据层，\n数据发生改变时，vue也会监听到数据变化，在将数据同步到视图。\n称为数据的双向绑定。\n</code></pre>\n<pre><code class=\"mermaid\">graph TD\nA[view:视图] --&gt;B[viewModel:视图模型]\n    B --&gt;C[model:数据]\n</code></pre>\n<h2 id=\"监听响应式数据\"><a href=\"#监听响应式数据\" class=\"headerlink\" title=\"监听响应式数据\"></a>监听响应式数据</h2><h3 id=\"监听对象变化\"><a href=\"#监听对象变化\" class=\"headerlink\" title=\"监听对象变化\"></a>监听对象变化</h3><blockquote>\n<p>通过数据劫持结合发布者,订阅者模式的方式来实的,通过 Object.definePropertyget劫持各个属性的getter和setter方法，get是获取属性时调用，set属性变化时调用，从而可以在里面做一些更新视图的操作，但是订阅者(watcher)是有多个的，怎么能知道那些订阅者需要更新，这时候就需要使用一个dep来收集订阅者(watcher)，进行统一管理，此外还需要一个指令解析器，对每个节点元素进行扫描和解析指令，再将对应的指令初始化并绑定相应更新(update)函数，此时订阅者接收到相应属性的变化，就会执行对应的更新函数，实现更新视图。</p>\n</blockquote>\n<pre><code class=\"js\">执行的步骤大概是这样的：\n\n1.vue实例在初始化时会拿到当前data中的数据，调用一个 initData(vm) 方法初始化数据。 \n2.在 initData 方法中调用 Observer(val) 方法并传入数据，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,观测的一种是数组，一种是对象。\n3.如果是对象型非数组的话调用 this.walk(value) 方法，会把当前传入的对象进行循环调用Object.defineProperty。\n4.使用 Object.defineProperty 重新定义数据,在判断如果当前对象的至还是一个对象的话，回到第2步进行递归。\n5.取值时调用 Object.defineProperty 的 get() 方法收集（订阅者）watcher。\n6.如果数据改变时调用set()，通知（订阅者）watcher去更新数据,如果当前值和数据的值不一样的话调用 dep.notify() 通知视图更新。\n\n    \n** 基础类型的数据是不会进行观测，只监测data对象\n</code></pre>\n<h3 id=\"监听数组的变化\"><a href=\"#监听数组的变化\" class=\"headerlink\" title=\"监听数组的变化\"></a>监听数组的变化</h3><blockquote>\n<p>Object.defineProperty是监听不到数组的变化的，而是使用函数劫持，对数组常用的7个原生可改变数组的方法进行了改写，只要数组一改变就通知观测者</p>\n</blockquote>\n<pre><code class=\"js\">vue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组内包含引用类型，会对数组中的引用类型再次进行监控。\n\n1.vue初始化时会拿到当前data中的数据，调用 initData(vm) 方法初始化数据。 \n2.在initData中调用 Observer(val) 方法，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,再判断如果有__ob__且类型是observer的话说明已经被监听了直接返回数据，观测的一种是数组，一种是对象。\n3.如果为数组，让就让它的原型链指向 arrayMethods ，来改写数组方法。\n4.只要调用了数组方法，就会执行一个函数，执行原来的方法并通知视图更新，ob.dep.notify()\n5.如果使用了数组新增方法,push,unshift,splice的话，调用ob.observeArray(新增的数据)遍历数组的每个对象进行深度观测，所以只有数组里的对象才能进行响应式的数据变化。\n</code></pre>\n<h2 id=\"为何采用异步渲染\"><a href=\"#为何采用异步渲染\" class=\"headerlink\" title=\"为何采用异步渲染\"></a>为何采用异步渲染</h2><blockquote>\n<p>vue是组件级更新，当组件数据变就会更新 ,如果不采用异步更新，那么组件内的数据每次更新都会对当前组件进行重新渲染， 所以为了性能考虑，vue在本轮数据更新后，再去异步更新视图</p>\n</blockquote>\n<pre><code class=\"js\">1.当数据变化后，调用dep.notify()方法,通知watcher进行更新\n2.watcher会调用 update() 方法，调用时并不会立即更新，而是调用 queueWatcher方法 判断watcher的id（uid）去重后放入 queue队列 中。\n3.最后在调用 nextTick(flushScheduierQueue) 异步刷新 queue队列,执行watcher,update钩子函数\n\n**可以说是 渲染节流\n</code></pre>\n<h2 id=\"key的原理\"><a href=\"#key的原理\" class=\"headerlink\" title=\"key的原理\"></a>key的原理</h2><blockquote>\n<p>首先它的作用是：更高效的更新虚拟dom，提高diff算法的速度。</p>\n<p>在vue中，我们是不需要直接操作dom的，只需要操作数据就可完成页面的渲染,vue通过虚拟dom去操作真实dom实现渲染，在渲染时使用的是diff算法，v-for更新渲染过的元素列表时会采用就地复用策略，简单复用此处每个元素。</p>\n</blockquote>\n<ul>\n<li><p>默认的diff算法,也就是不加key的话，比如有abcd4个节点，我们要在b和c之间插入一个e节点，那么当e插进去后，旧节点c的状态就会被e复用，d被c复用,这样新d永远都会在最后一个节点。</p>\n</li>\n<li><p>加上key之后，相当于给每个节点加上一个唯一的标识，diff算法就可以正确的识别此节点，找到正确的位置插入新节点，并复用自身的状态，从而重用和重新排序已有节点。</p>\n</li>\n<li><p><strong>diff算法</strong>：通过对比同一层的新旧虚拟dom,将有变化更新的地方渲染在真实dom。</p>\n</li>\n<li><p><strong>虚拟dom</strong>：用js对象的形式模拟一个真实dom，如果直接操作dom的话，每次更新dom 都会造成重绘和回流，而使用虚拟dom 对比节点时放在js来做，可以避免真实dom 重复大量渲染。</p>\n<p><strong>其实，虚拟dom的子元素列表只包含文本节点且dom结构一致，不设置key效率会更高，因为不会涉及到过多的判读逻辑</strong></p>\n</li>\n</ul>\n"},{"title":"javascript基础-数组和冒泡排序","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 03-js基础\n\n\n\n##循环结构\n\n###while循环\n\n+ 当条件为true时，则开启无限月读模式，为flase时不执行。\n\n###do-while循环\n\n+ 先执行循环体后在进行判断，所以至少执行一次。\n\n###for循环\n\n+ 语法：\n\n  ```javascript\n  for(var i = 0;i<=10;i++){  }\n  ```\n\n+ 初始化表达式只执行一次，然后执行条件表达式，如果条件表达式返回结果为false则结束循环，最后执行自增\n\n## break和continue\n\n+ break : 中止循环\n+ continue: 中止本次循环\n\n\n\n\n\n##数组\n\n+ 概念\n\n  > 管理大量数据，有位置，顺序，下标，索引\n\n+ 创建\n\n  ```js\n  1.字面量创建\n  var arr = []\n  2.简洁\n  var arr2 = new Array()\n  3.\n  var arr3 = new Array(3) //规定长度\n  ```\n\n+ 下标\n\n  ```js\n  1.获取下标为0\n  arr[0]\n  2.赋值\n  arr[0] = 值\n  ```\n\n+ 数组长度\n\n  ```js\n  arr.length\n  ```\n\n\n## 冒泡排序\n\n> 原理：两个相邻的元素比较大小，当前者大于后者则，两者互换位置\n\n```js\nvar arr = [2,1,4,3]\n\n//遍历数组，数组长度减1就是要交互的次数\nfor(let i =0;i<arr.length-1;i++){\n    //根据外层的for循环，逐渐减少内层循环次数，因为每次循环都会将最大值放到最后\n    for(let j=0;j<arr.length-1-i;j++){\n        \n        //设置一个开关，\n        var on = true;\n        if(arr[i]>arr[i+1]){\n            var a;\n            a = arr[i]\n            arr[i] = arr[i+1]\n            arr[i+1] = a\n            on = false\n        }\n       // 当排序不在换位置时终止多余的排序\n        if(on) break;\n        \n    }\n}\nconsole.log(arr)\n\n\nvar arr = data.options\n      for (let i = 0; i < arr.length - 1; i++) {\n        for (let j = 0; j < arr.length - 1 - i; j++) {\n          if (arr[j].code.charCodeAt() > arr[j + 1].code.charCodeAt()) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n          }\n        }\n      }\nconsole.log(arr)\n\n```\n\n","source":"_posts/笔记/ocean/03-javascript基础总结/03-数组和冒泡排序/03-笔记.md","raw":"---\ntitle: javascript基础-数组和冒泡排序\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 03-js基础\n\n\n\n##循环结构\n\n###while循环\n\n+ 当条件为true时，则开启无限月读模式，为flase时不执行。\n\n###do-while循环\n\n+ 先执行循环体后在进行判断，所以至少执行一次。\n\n###for循环\n\n+ 语法：\n\n  ```javascript\n  for(var i = 0;i<=10;i++){  }\n  ```\n\n+ 初始化表达式只执行一次，然后执行条件表达式，如果条件表达式返回结果为false则结束循环，最后执行自增\n\n## break和continue\n\n+ break : 中止循环\n+ continue: 中止本次循环\n\n\n\n\n\n##数组\n\n+ 概念\n\n  > 管理大量数据，有位置，顺序，下标，索引\n\n+ 创建\n\n  ```js\n  1.字面量创建\n  var arr = []\n  2.简洁\n  var arr2 = new Array()\n  3.\n  var arr3 = new Array(3) //规定长度\n  ```\n\n+ 下标\n\n  ```js\n  1.获取下标为0\n  arr[0]\n  2.赋值\n  arr[0] = 值\n  ```\n\n+ 数组长度\n\n  ```js\n  arr.length\n  ```\n\n\n## 冒泡排序\n\n> 原理：两个相邻的元素比较大小，当前者大于后者则，两者互换位置\n\n```js\nvar arr = [2,1,4,3]\n\n//遍历数组，数组长度减1就是要交互的次数\nfor(let i =0;i<arr.length-1;i++){\n    //根据外层的for循环，逐渐减少内层循环次数，因为每次循环都会将最大值放到最后\n    for(let j=0;j<arr.length-1-i;j++){\n        \n        //设置一个开关，\n        var on = true;\n        if(arr[i]>arr[i+1]){\n            var a;\n            a = arr[i]\n            arr[i] = arr[i+1]\n            arr[i+1] = a\n            on = false\n        }\n       // 当排序不在换位置时终止多余的排序\n        if(on) break;\n        \n    }\n}\nconsole.log(arr)\n\n\nvar arr = data.options\n      for (let i = 0; i < arr.length - 1; i++) {\n        for (let j = 0; j < arr.length - 1 - i; j++) {\n          if (arr[j].code.charCodeAt() > arr[j + 1].code.charCodeAt()) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n          }\n        }\n      }\nconsole.log(arr)\n\n```\n\n","slug":"笔记/ocean/03-javascript基础总结/03-数组和冒泡排序/03-笔记","published":1,"updated":"2023-03-01T07:07:08.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qce001cawafh3ft4sd2","content":"<h1 id=\"03-js基础\"><a href=\"#03-js基础\" class=\"headerlink\" title=\"03-js基础\"></a>03-js基础</h1><p>##循环结构</p>\n<p>###while循环</p>\n<ul>\n<li>当条件为true时，则开启无限月读模式，为flase时不执行。</li>\n</ul>\n<p>###do-while循环</p>\n<ul>\n<li>先执行循环体后在进行判断，所以至少执行一次。</li>\n</ul>\n<p>###for循环</p>\n<ul>\n<li><p>语法：</p>\n<pre><code class=\"javascript\">for(var i = 0;i&lt;=10;i++)&#123;  &#125;\n</code></pre>\n</li>\n<li><p>初始化表达式只执行一次，然后执行条件表达式，如果条件表达式返回结果为false则结束循环，最后执行自增</p>\n</li>\n</ul>\n<h2 id=\"break和continue\"><a href=\"#break和continue\" class=\"headerlink\" title=\"break和continue\"></a>break和continue</h2><ul>\n<li>break : 中止循环</li>\n<li>continue: 中止本次循环</li>\n</ul>\n<p>##数组</p>\n<ul>\n<li><p>概念</p>\n<blockquote>\n<p>管理大量数据，有位置，顺序，下标，索引</p>\n</blockquote>\n</li>\n<li><p>创建</p>\n<pre><code class=\"js\">1.字面量创建\nvar arr = []\n2.简洁\nvar arr2 = new Array()\n3.\nvar arr3 = new Array(3) //规定长度\n</code></pre>\n</li>\n<li><p>下标</p>\n<pre><code class=\"js\">1.获取下标为0\narr[0]\n2.赋值\narr[0] = 值\n</code></pre>\n</li>\n<li><p>数组长度</p>\n<pre><code class=\"js\">arr.length\n</code></pre>\n</li>\n</ul>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><blockquote>\n<p>原理：两个相邻的元素比较大小，当前者大于后者则，两者互换位置</p>\n</blockquote>\n<pre><code class=\"js\">var arr = [2,1,4,3]\n\n//遍历数组，数组长度减1就是要交互的次数\nfor(let i =0;i&lt;arr.length-1;i++)&#123;\n    //根据外层的for循环，逐渐减少内层循环次数，因为每次循环都会将最大值放到最后\n    for(let j=0;j&lt;arr.length-1-i;j++)&#123;\n        \n        //设置一个开关，\n        var on = true;\n        if(arr[i]&gt;arr[i+1])&#123;\n            var a;\n            a = arr[i]\n            arr[i] = arr[i+1]\n            arr[i+1] = a\n            on = false\n        &#125;\n       // 当排序不在换位置时终止多余的排序\n        if(on) break;\n        \n    &#125;\n&#125;\nconsole.log(arr)\n\n\nvar arr = data.options\n      for (let i = 0; i &lt; arr.length - 1; i++) &#123;\n        for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123;\n          if (arr[j].code.charCodeAt() &gt; arr[j + 1].code.charCodeAt()) &#123;\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n          &#125;\n        &#125;\n      &#125;\nconsole.log(arr)\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-js基础\"><a href=\"#03-js基础\" class=\"headerlink\" title=\"03-js基础\"></a>03-js基础</h1><p>##循环结构</p>\n<p>###while循环</p>\n<ul>\n<li>当条件为true时，则开启无限月读模式，为flase时不执行。</li>\n</ul>\n<p>###do-while循环</p>\n<ul>\n<li>先执行循环体后在进行判断，所以至少执行一次。</li>\n</ul>\n<p>###for循环</p>\n<ul>\n<li><p>语法：</p>\n<pre><code class=\"javascript\">for(var i = 0;i&lt;=10;i++)&#123;  &#125;\n</code></pre>\n</li>\n<li><p>初始化表达式只执行一次，然后执行条件表达式，如果条件表达式返回结果为false则结束循环，最后执行自增</p>\n</li>\n</ul>\n<h2 id=\"break和continue\"><a href=\"#break和continue\" class=\"headerlink\" title=\"break和continue\"></a>break和continue</h2><ul>\n<li>break : 中止循环</li>\n<li>continue: 中止本次循环</li>\n</ul>\n<p>##数组</p>\n<ul>\n<li><p>概念</p>\n<blockquote>\n<p>管理大量数据，有位置，顺序，下标，索引</p>\n</blockquote>\n</li>\n<li><p>创建</p>\n<pre><code class=\"js\">1.字面量创建\nvar arr = []\n2.简洁\nvar arr2 = new Array()\n3.\nvar arr3 = new Array(3) //规定长度\n</code></pre>\n</li>\n<li><p>下标</p>\n<pre><code class=\"js\">1.获取下标为0\narr[0]\n2.赋值\narr[0] = 值\n</code></pre>\n</li>\n<li><p>数组长度</p>\n<pre><code class=\"js\">arr.length\n</code></pre>\n</li>\n</ul>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><blockquote>\n<p>原理：两个相邻的元素比较大小，当前者大于后者则，两者互换位置</p>\n</blockquote>\n<pre><code class=\"js\">var arr = [2,1,4,3]\n\n//遍历数组，数组长度减1就是要交互的次数\nfor(let i =0;i&lt;arr.length-1;i++)&#123;\n    //根据外层的for循环，逐渐减少内层循环次数，因为每次循环都会将最大值放到最后\n    for(let j=0;j&lt;arr.length-1-i;j++)&#123;\n        \n        //设置一个开关，\n        var on = true;\n        if(arr[i]&gt;arr[i+1])&#123;\n            var a;\n            a = arr[i]\n            arr[i] = arr[i+1]\n            arr[i+1] = a\n            on = false\n        &#125;\n       // 当排序不在换位置时终止多余的排序\n        if(on) break;\n        \n    &#125;\n&#125;\nconsole.log(arr)\n\n\nvar arr = data.options\n      for (let i = 0; i &lt; arr.length - 1; i++) &#123;\n        for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123;\n          if (arr[j].code.charCodeAt() &gt; arr[j + 1].code.charCodeAt()) &#123;\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n          &#125;\n        &#125;\n      &#125;\nconsole.log(arr)\n</code></pre>\n"},{"title":"javascript基础-对象和复杂类型数据","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 05-js\n\n##对象\n\n+ 介绍\n\n  >  对象是属性和方法的集合体。万物皆对象，使用对象描述万物\n\n  \n\n+ 创建对象\n\n  ```js\n  1.字面量创建\n  var obj = {}\n  \n  2.构造函数创建\n  var obj = new object()； //创建\n  \n  ```\n\n+ 添加属性\n\n  ```js\n  1.\n  obj.键名 = 数据 //可以是变量或函数，数组等\n  \n  2.\n  obj[变量名] = 数据\n  \n  \n  3.创建并添加\n  var obj = {\n      name:\"hhh\",\t//定义属性名：属性值\n      age:12\n  }\n  \n  \n  ```\n\n+ 访问\n\n  ```js\n  1.\n  obj.age //访问\n  \n  2.\n  obj[名] \n  ```\n\n  \n\n+ 遍历\n\n  ```js\n  for(let key in obj){ //key代表对象中的每一个键\n      console.log(obj[key]) // 此时的key是变量\n      console.log(obj.key) //这种方法会把key当成字符串\n  }\n  ```\n\n##内置对象\n\n###Math\n\n```js\nvar math = Math.random();  //创建一个0到1的随机数\n\nvar math = math*256;  // math乘以255后，就是0到255\nvar math = Math.floor(math) // 将小树向下取整 1.9 == 1\n    math = Math.round(math) // 将小数四舍五入取整\n\tmath = Math.ceil(math) // 将小数向上取整\n\tmath = Math.abs(math) //转为正数\n\tmath = Math.max(1,20,3,34,5) //求最大值\n\tmath = Math.min(1,20,1,3,4,5) //求最小值\n\n```\n\n###Date\n\n+ 时间戳\n\n  ```js\n  var date = new Date('2025-10-01 00:00:00'); //返回一个指定时间日期\n  \tdate = date.valueOf();  //获取date的时间戳\n  \tdate = date.getTime();  //获取date的时间戳\n  \tdate = 1*date;\t//隐式转换\n  \n  \n  var\ttime = Date.now(); //获取当前时间戳\n  ```\n\n  \n\n##简单与复杂类型\n\n> js数据都是存在内存中的，分别在两个地方存贮，堆和栈\n\n+ 简单的类型会存入栈不会涉及堆\n\n  ```js\n  var a =\t1;\n  var b = a;\n  b = 2;\n  console.log(a,b) //a为1，b为2\n  ```\n\n  \n\n+ 复杂类型的储存会存入栈涉及堆\n\n  ```js\n  var obj1 = { a:1 };\n  var obj2 = obj1; //将obj2的指向改变为obj1的指向的内存地址\n  obj2.a = 2; //因为obj1和obj2的指向的内存地址相同，所以它们读取的是同一个内存上的对象\n  \n  console.log(obj1.a,obj2.a) // 2 2\n  ```\n\n  ","source":"_posts/笔记/ocean/03-javascript基础总结/05-对象和复杂类型数据/05-笔记.md","raw":"---\ntitle: javascript基础-对象和复杂类型数据\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 05-js\n\n##对象\n\n+ 介绍\n\n  >  对象是属性和方法的集合体。万物皆对象，使用对象描述万物\n\n  \n\n+ 创建对象\n\n  ```js\n  1.字面量创建\n  var obj = {}\n  \n  2.构造函数创建\n  var obj = new object()； //创建\n  \n  ```\n\n+ 添加属性\n\n  ```js\n  1.\n  obj.键名 = 数据 //可以是变量或函数，数组等\n  \n  2.\n  obj[变量名] = 数据\n  \n  \n  3.创建并添加\n  var obj = {\n      name:\"hhh\",\t//定义属性名：属性值\n      age:12\n  }\n  \n  \n  ```\n\n+ 访问\n\n  ```js\n  1.\n  obj.age //访问\n  \n  2.\n  obj[名] \n  ```\n\n  \n\n+ 遍历\n\n  ```js\n  for(let key in obj){ //key代表对象中的每一个键\n      console.log(obj[key]) // 此时的key是变量\n      console.log(obj.key) //这种方法会把key当成字符串\n  }\n  ```\n\n##内置对象\n\n###Math\n\n```js\nvar math = Math.random();  //创建一个0到1的随机数\n\nvar math = math*256;  // math乘以255后，就是0到255\nvar math = Math.floor(math) // 将小树向下取整 1.9 == 1\n    math = Math.round(math) // 将小数四舍五入取整\n\tmath = Math.ceil(math) // 将小数向上取整\n\tmath = Math.abs(math) //转为正数\n\tmath = Math.max(1,20,3,34,5) //求最大值\n\tmath = Math.min(1,20,1,3,4,5) //求最小值\n\n```\n\n###Date\n\n+ 时间戳\n\n  ```js\n  var date = new Date('2025-10-01 00:00:00'); //返回一个指定时间日期\n  \tdate = date.valueOf();  //获取date的时间戳\n  \tdate = date.getTime();  //获取date的时间戳\n  \tdate = 1*date;\t//隐式转换\n  \n  \n  var\ttime = Date.now(); //获取当前时间戳\n  ```\n\n  \n\n##简单与复杂类型\n\n> js数据都是存在内存中的，分别在两个地方存贮，堆和栈\n\n+ 简单的类型会存入栈不会涉及堆\n\n  ```js\n  var a =\t1;\n  var b = a;\n  b = 2;\n  console.log(a,b) //a为1，b为2\n  ```\n\n  \n\n+ 复杂类型的储存会存入栈涉及堆\n\n  ```js\n  var obj1 = { a:1 };\n  var obj2 = obj1; //将obj2的指向改变为obj1的指向的内存地址\n  obj2.a = 2; //因为obj1和obj2的指向的内存地址相同，所以它们读取的是同一个内存上的对象\n  \n  console.log(obj1.a,obj2.a) // 2 2\n  ```\n\n  ","slug":"笔记/ocean/03-javascript基础总结/05-对象和复杂类型数据/05-笔记","published":1,"updated":"2023-03-01T07:07:15.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcf001fawaf0d45dtz1","content":"<h1 id=\"05-js\"><a href=\"#05-js\" class=\"headerlink\" title=\"05-js\"></a>05-js</h1><p>##对象</p>\n<ul>\n<li><p>介绍</p>\n<blockquote>\n<p> 对象是属性和方法的集合体。万物皆对象，使用对象描述万物</p>\n</blockquote>\n</li>\n<li><p>创建对象</p>\n<pre><code class=\"js\">1.字面量创建\nvar obj = &#123;&#125;\n\n2.构造函数创建\nvar obj = new object()； //创建\n</code></pre>\n</li>\n<li><p>添加属性</p>\n<pre><code class=\"js\">1.\nobj.键名 = 数据 //可以是变量或函数，数组等\n\n2.\nobj[变量名] = 数据\n\n\n3.创建并添加\nvar obj = &#123;\n    name:&quot;hhh&quot;,    //定义属性名：属性值\n    age:12\n&#125;\n\n</code></pre>\n</li>\n<li><p>访问</p>\n<pre><code class=\"js\">1.\nobj.age //访问\n\n2.\nobj[名] \n</code></pre>\n</li>\n<li><p>遍历</p>\n<pre><code class=\"js\">for(let key in obj)&#123; //key代表对象中的每一个键\n    console.log(obj[key]) // 此时的key是变量\n    console.log(obj.key) //这种方法会把key当成字符串\n&#125;\n</code></pre>\n</li>\n</ul>\n<p>##内置对象</p>\n<p>###Math</p>\n<pre><code class=\"js\">var math = Math.random();  //创建一个0到1的随机数\n\nvar math = math*256;  // math乘以255后，就是0到255\nvar math = Math.floor(math) // 将小树向下取整 1.9 == 1\n    math = Math.round(math) // 将小数四舍五入取整\n    math = Math.ceil(math) // 将小数向上取整\n    math = Math.abs(math) //转为正数\n    math = Math.max(1,20,3,34,5) //求最大值\n    math = Math.min(1,20,1,3,4,5) //求最小值\n</code></pre>\n<p>###Date</p>\n<ul>\n<li><p>时间戳</p>\n<pre><code class=\"js\">var date = new Date(&#39;2025-10-01 00:00:00&#39;); //返回一个指定时间日期\n    date = date.valueOf();  //获取date的时间戳\n    date = date.getTime();  //获取date的时间戳\n    date = 1*date;    //隐式转换\n\n\nvar    time = Date.now(); //获取当前时间戳\n</code></pre>\n</li>\n</ul>\n<p>##简单与复杂类型</p>\n<blockquote>\n<p>js数据都是存在内存中的，分别在两个地方存贮，堆和栈</p>\n</blockquote>\n<ul>\n<li><p>简单的类型会存入栈不会涉及堆</p>\n<pre><code class=\"js\">var a =    1;\nvar b = a;\nb = 2;\nconsole.log(a,b) //a为1，b为2\n</code></pre>\n</li>\n<li><p>复杂类型的储存会存入栈涉及堆</p>\n<pre><code class=\"js\">var obj1 = &#123; a:1 &#125;;\nvar obj2 = obj1; //将obj2的指向改变为obj1的指向的内存地址\nobj2.a = 2; //因为obj1和obj2的指向的内存地址相同，所以它们读取的是同一个内存上的对象\n\nconsole.log(obj1.a,obj2.a) // 2 2\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"05-js\"><a href=\"#05-js\" class=\"headerlink\" title=\"05-js\"></a>05-js</h1><p>##对象</p>\n<ul>\n<li><p>介绍</p>\n<blockquote>\n<p> 对象是属性和方法的集合体。万物皆对象，使用对象描述万物</p>\n</blockquote>\n</li>\n<li><p>创建对象</p>\n<pre><code class=\"js\">1.字面量创建\nvar obj = &#123;&#125;\n\n2.构造函数创建\nvar obj = new object()； //创建\n</code></pre>\n</li>\n<li><p>添加属性</p>\n<pre><code class=\"js\">1.\nobj.键名 = 数据 //可以是变量或函数，数组等\n\n2.\nobj[变量名] = 数据\n\n\n3.创建并添加\nvar obj = &#123;\n    name:&quot;hhh&quot;,    //定义属性名：属性值\n    age:12\n&#125;\n\n</code></pre>\n</li>\n<li><p>访问</p>\n<pre><code class=\"js\">1.\nobj.age //访问\n\n2.\nobj[名] \n</code></pre>\n</li>\n<li><p>遍历</p>\n<pre><code class=\"js\">for(let key in obj)&#123; //key代表对象中的每一个键\n    console.log(obj[key]) // 此时的key是变量\n    console.log(obj.key) //这种方法会把key当成字符串\n&#125;\n</code></pre>\n</li>\n</ul>\n<p>##内置对象</p>\n<p>###Math</p>\n<pre><code class=\"js\">var math = Math.random();  //创建一个0到1的随机数\n\nvar math = math*256;  // math乘以255后，就是0到255\nvar math = Math.floor(math) // 将小树向下取整 1.9 == 1\n    math = Math.round(math) // 将小数四舍五入取整\n    math = Math.ceil(math) // 将小数向上取整\n    math = Math.abs(math) //转为正数\n    math = Math.max(1,20,3,34,5) //求最大值\n    math = Math.min(1,20,1,3,4,5) //求最小值\n</code></pre>\n<p>###Date</p>\n<ul>\n<li><p>时间戳</p>\n<pre><code class=\"js\">var date = new Date(&#39;2025-10-01 00:00:00&#39;); //返回一个指定时间日期\n    date = date.valueOf();  //获取date的时间戳\n    date = date.getTime();  //获取date的时间戳\n    date = 1*date;    //隐式转换\n\n\nvar    time = Date.now(); //获取当前时间戳\n</code></pre>\n</li>\n</ul>\n<p>##简单与复杂类型</p>\n<blockquote>\n<p>js数据都是存在内存中的，分别在两个地方存贮，堆和栈</p>\n</blockquote>\n<ul>\n<li><p>简单的类型会存入栈不会涉及堆</p>\n<pre><code class=\"js\">var a =    1;\nvar b = a;\nb = 2;\nconsole.log(a,b) //a为1，b为2\n</code></pre>\n</li>\n<li><p>复杂类型的储存会存入栈涉及堆</p>\n<pre><code class=\"js\">var obj1 = &#123; a:1 &#125;;\nvar obj2 = obj1; //将obj2的指向改变为obj1的指向的内存地址\nobj2.a = 2; //因为obj1和obj2的指向的内存地址相同，所以它们读取的是同一个内存上的对象\n\nconsole.log(obj1.a,obj2.a) // 2 2\n</code></pre>\n</li>\n</ul>\n"},{"title":"javascript基础-函数和作用域","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 04-js基础\n\n##函数\n\n### 概念\n\n> 函数是将一段需要重复执行的代码使用function封装为块并简化代码。\n\n\n\n\n\n###使用\n\n+ 几种函数\n\n  ```javascript\n  1.普通函数\n  function fun(){ \n  }\n  \n  2.ES6箭头函数\n  ()=>{}\n  \n  3.匿名函数\n  var fun = function(){}\n  \n  4.自调用函数\n  (function(){ //此函数定义后会自动调用\n      coonsole.log(1)\n  })\n  ```\n\n+ 调用\n\n  ```js\n  1.直接使用函数名调用\n  fun()\n  \n  ```\n\n+ 传参\n\n  + 当调用函数时，没有传入实参，那么形参默认为undefined\n\n  ````js\n  function fun(形参1，形参2，形参n..){\n      \n  }\n  ````\n\n+ 返回值\n\n  + 作用：将函数内部的数据return出来\n\n  + 特点\n\n    1. return后续代码就不在执行\n\n    2. return后面没有数据时，返回的是undefined\n\n    3. 无return时，为undefined\n\n       \n\n  ```js\n  function fun(){\n      var a = 10;\n      return a;\n  }\n  \n  var func = fun()\n  \n  console.log(func)\n  ```\n\n\n\n### 函数表达式\n\n> 通常是以变量赋值\n\n```javascript\nvar 函数名 = function(){\n    //函数体\n}\n```\n\n\n\n###arguments\n\n> 当不确定要传入几个形参时，使用arguments，它是函数内部中的变量，一个伪数组,里面存放的是传进来的实参\n\n```javascript\nfunction fun(){\n   console.log(arguments)\n}\t\n```\n\n\n\n\n\n\n\n## 内置对象Date\n\n+ 语法：\n\n  ```javascript\n  var date = new Date() //创建Date()对象,返回的是一个日期对象\n  \n  var year = date.getFullYear(); //年\n  \n  var month = date.getMonth()+1 //月\n  \n  var day = date.getDate() // 日\n  \n  var hour = date.getHours(); //时\n  \n  var minute = date.getMinutes(); //分\n  \n  var second = date.getSeconds(); //秒\n  \n  var millds =  date.getMilliseconds() //毫秒\n  ```\n\n  \n\n##作用域\n\n+ 局部作用域\n\n  在局部作用域下声明的变量，只在局部作用域生效\n\n+ 全局作用域\n\n  全局的变量，能在js部分的任何位置都可以访问。\n\n语法：\n\n```javascript\nfunction fun(){\n    var a = 1;\t//a就是一个局部变量，函数外面不可使用\n    console.log(a) //会输出1\n}\nfun();\nconsole.log(a) //报错\n```\n\n\n\n##预解析\n\n+ 代码每次执行时进入新的作用域，声明的var变量，function函数(){},全部提升到当前作用域的最顶端\n\n+ 预解析不是执行代码，是解析完成后才执行代码\n\n+ 全局作用域：\n\n  ```javascript\n  //抓var,function \n  var a\n  function fn(){\n      console.log(\"函数\")\n  }\n  \n  ---------------------------\n  \n  console.log(a)\t//undefined\n  fn()\t//函数\n  a = 1\n  ```\n\n+ 局部预解析\n\n  ```javascript\n  function fn(){\n      var a;\n      -----------------------\n      console.log(a) //undefined\n      a = 1; \n  }\t\n  ```\n\n  \n\n","source":"_posts/笔记/ocean/03-javascript基础总结/04-函数和作用域/04-笔记.md","raw":"---\ntitle: javascript基础-函数和作用域\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 04-js基础\n\n##函数\n\n### 概念\n\n> 函数是将一段需要重复执行的代码使用function封装为块并简化代码。\n\n\n\n\n\n###使用\n\n+ 几种函数\n\n  ```javascript\n  1.普通函数\n  function fun(){ \n  }\n  \n  2.ES6箭头函数\n  ()=>{}\n  \n  3.匿名函数\n  var fun = function(){}\n  \n  4.自调用函数\n  (function(){ //此函数定义后会自动调用\n      coonsole.log(1)\n  })\n  ```\n\n+ 调用\n\n  ```js\n  1.直接使用函数名调用\n  fun()\n  \n  ```\n\n+ 传参\n\n  + 当调用函数时，没有传入实参，那么形参默认为undefined\n\n  ````js\n  function fun(形参1，形参2，形参n..){\n      \n  }\n  ````\n\n+ 返回值\n\n  + 作用：将函数内部的数据return出来\n\n  + 特点\n\n    1. return后续代码就不在执行\n\n    2. return后面没有数据时，返回的是undefined\n\n    3. 无return时，为undefined\n\n       \n\n  ```js\n  function fun(){\n      var a = 10;\n      return a;\n  }\n  \n  var func = fun()\n  \n  console.log(func)\n  ```\n\n\n\n### 函数表达式\n\n> 通常是以变量赋值\n\n```javascript\nvar 函数名 = function(){\n    //函数体\n}\n```\n\n\n\n###arguments\n\n> 当不确定要传入几个形参时，使用arguments，它是函数内部中的变量，一个伪数组,里面存放的是传进来的实参\n\n```javascript\nfunction fun(){\n   console.log(arguments)\n}\t\n```\n\n\n\n\n\n\n\n## 内置对象Date\n\n+ 语法：\n\n  ```javascript\n  var date = new Date() //创建Date()对象,返回的是一个日期对象\n  \n  var year = date.getFullYear(); //年\n  \n  var month = date.getMonth()+1 //月\n  \n  var day = date.getDate() // 日\n  \n  var hour = date.getHours(); //时\n  \n  var minute = date.getMinutes(); //分\n  \n  var second = date.getSeconds(); //秒\n  \n  var millds =  date.getMilliseconds() //毫秒\n  ```\n\n  \n\n##作用域\n\n+ 局部作用域\n\n  在局部作用域下声明的变量，只在局部作用域生效\n\n+ 全局作用域\n\n  全局的变量，能在js部分的任何位置都可以访问。\n\n语法：\n\n```javascript\nfunction fun(){\n    var a = 1;\t//a就是一个局部变量，函数外面不可使用\n    console.log(a) //会输出1\n}\nfun();\nconsole.log(a) //报错\n```\n\n\n\n##预解析\n\n+ 代码每次执行时进入新的作用域，声明的var变量，function函数(){},全部提升到当前作用域的最顶端\n\n+ 预解析不是执行代码，是解析完成后才执行代码\n\n+ 全局作用域：\n\n  ```javascript\n  //抓var,function \n  var a\n  function fn(){\n      console.log(\"函数\")\n  }\n  \n  ---------------------------\n  \n  console.log(a)\t//undefined\n  fn()\t//函数\n  a = 1\n  ```\n\n+ 局部预解析\n\n  ```javascript\n  function fn(){\n      var a;\n      -----------------------\n      console.log(a) //undefined\n      a = 1; \n  }\t\n  ```\n\n  \n\n","slug":"笔记/ocean/03-javascript基础总结/04-函数和作用域/04-笔记","published":1,"updated":"2023-03-01T07:07:10.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcf001iawafdgsh8b4w","content":"<h1 id=\"04-js基础\"><a href=\"#04-js基础\" class=\"headerlink\" title=\"04-js基础\"></a>04-js基础</h1><p>##函数</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>函数是将一段需要重复执行的代码使用function封装为块并简化代码。</p>\n</blockquote>\n<p>###使用</p>\n<ul>\n<li><p>几种函数</p>\n<pre><code class=\"javascript\">1.普通函数\nfunction fun()&#123; \n&#125;\n\n2.ES6箭头函数\n()=&gt;&#123;&#125;\n\n3.匿名函数\nvar fun = function()&#123;&#125;\n\n4.自调用函数\n(function()&#123; //此函数定义后会自动调用\n    coonsole.log(1)\n&#125;)\n</code></pre>\n</li>\n<li><p>调用</p>\n<pre><code class=\"js\">1.直接使用函数名调用\nfun()\n</code></pre>\n</li>\n<li><p>传参</p>\n<ul>\n<li>当调用函数时，没有传入实参，那么形参默认为undefined</li>\n</ul>\n<pre><code class=\"js\">function fun(形参1，形参2，形参n..)&#123;\n    \n&#125;\n</code></pre>\n</li>\n<li><p>返回值</p>\n<ul>\n<li><p>作用：将函数内部的数据return出来</p>\n</li>\n<li><p>特点</p>\n<ol>\n<li><p>return后续代码就不在执行</p>\n</li>\n<li><p>return后面没有数据时，返回的是undefined</p>\n</li>\n<li><p>无return时，为undefined</p>\n</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">function fun()&#123;\n    var a = 10;\n    return a;\n&#125;\n\nvar func = fun()\n\nconsole.log(func)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h3><blockquote>\n<p>通常是以变量赋值</p>\n</blockquote>\n<pre><code class=\"javascript\">var 函数名 = function()&#123;\n    //函数体\n&#125;\n</code></pre>\n<p>###arguments</p>\n<blockquote>\n<p>当不确定要传入几个形参时，使用arguments，它是函数内部中的变量，一个伪数组,里面存放的是传进来的实参</p>\n</blockquote>\n<pre><code class=\"javascript\">function fun()&#123;\n   console.log(arguments)\n&#125;    \n</code></pre>\n<h2 id=\"内置对象Date\"><a href=\"#内置对象Date\" class=\"headerlink\" title=\"内置对象Date\"></a>内置对象Date</h2><ul>\n<li><p>语法：</p>\n<pre><code class=\"javascript\">var date = new Date() //创建Date()对象,返回的是一个日期对象\n\nvar year = date.getFullYear(); //年\n\nvar month = date.getMonth()+1 //月\n\nvar day = date.getDate() // 日\n\nvar hour = date.getHours(); //时\n\nvar minute = date.getMinutes(); //分\n\nvar second = date.getSeconds(); //秒\n\nvar millds =  date.getMilliseconds() //毫秒\n</code></pre>\n</li>\n</ul>\n<p>##作用域</p>\n<ul>\n<li><p>局部作用域</p>\n<p>在局部作用域下声明的变量，只在局部作用域生效</p>\n</li>\n<li><p>全局作用域</p>\n<p>全局的变量，能在js部分的任何位置都可以访问。</p>\n</li>\n</ul>\n<p>语法：</p>\n<pre><code class=\"javascript\">function fun()&#123;\n    var a = 1;    //a就是一个局部变量，函数外面不可使用\n    console.log(a) //会输出1\n&#125;\nfun();\nconsole.log(a) //报错\n</code></pre>\n<p>##预解析</p>\n<ul>\n<li><p>代码每次执行时进入新的作用域，声明的var变量，function函数(){},全部提升到当前作用域的最顶端</p>\n</li>\n<li><p>预解析不是执行代码，是解析完成后才执行代码</p>\n</li>\n<li><p>全局作用域：</p>\n<pre><code class=\"javascript\">//抓var,function \nvar a\nfunction fn()&#123;\n    console.log(&quot;函数&quot;)\n&#125;\n\n---------------------------\n\nconsole.log(a)    //undefined\nfn()    //函数\na = 1\n</code></pre>\n</li>\n<li><p>局部预解析</p>\n<pre><code class=\"javascript\">function fn()&#123;\n    var a;\n    -----------------------\n    console.log(a) //undefined\n    a = 1; \n&#125;    \n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"04-js基础\"><a href=\"#04-js基础\" class=\"headerlink\" title=\"04-js基础\"></a>04-js基础</h1><p>##函数</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>函数是将一段需要重复执行的代码使用function封装为块并简化代码。</p>\n</blockquote>\n<p>###使用</p>\n<ul>\n<li><p>几种函数</p>\n<pre><code class=\"javascript\">1.普通函数\nfunction fun()&#123; \n&#125;\n\n2.ES6箭头函数\n()=&gt;&#123;&#125;\n\n3.匿名函数\nvar fun = function()&#123;&#125;\n\n4.自调用函数\n(function()&#123; //此函数定义后会自动调用\n    coonsole.log(1)\n&#125;)\n</code></pre>\n</li>\n<li><p>调用</p>\n<pre><code class=\"js\">1.直接使用函数名调用\nfun()\n</code></pre>\n</li>\n<li><p>传参</p>\n<ul>\n<li>当调用函数时，没有传入实参，那么形参默认为undefined</li>\n</ul>\n<pre><code class=\"js\">function fun(形参1，形参2，形参n..)&#123;\n    \n&#125;\n</code></pre>\n</li>\n<li><p>返回值</p>\n<ul>\n<li><p>作用：将函数内部的数据return出来</p>\n</li>\n<li><p>特点</p>\n<ol>\n<li><p>return后续代码就不在执行</p>\n</li>\n<li><p>return后面没有数据时，返回的是undefined</p>\n</li>\n<li><p>无return时，为undefined</p>\n</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">function fun()&#123;\n    var a = 10;\n    return a;\n&#125;\n\nvar func = fun()\n\nconsole.log(func)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h3><blockquote>\n<p>通常是以变量赋值</p>\n</blockquote>\n<pre><code class=\"javascript\">var 函数名 = function()&#123;\n    //函数体\n&#125;\n</code></pre>\n<p>###arguments</p>\n<blockquote>\n<p>当不确定要传入几个形参时，使用arguments，它是函数内部中的变量，一个伪数组,里面存放的是传进来的实参</p>\n</blockquote>\n<pre><code class=\"javascript\">function fun()&#123;\n   console.log(arguments)\n&#125;    \n</code></pre>\n<h2 id=\"内置对象Date\"><a href=\"#内置对象Date\" class=\"headerlink\" title=\"内置对象Date\"></a>内置对象Date</h2><ul>\n<li><p>语法：</p>\n<pre><code class=\"javascript\">var date = new Date() //创建Date()对象,返回的是一个日期对象\n\nvar year = date.getFullYear(); //年\n\nvar month = date.getMonth()+1 //月\n\nvar day = date.getDate() // 日\n\nvar hour = date.getHours(); //时\n\nvar minute = date.getMinutes(); //分\n\nvar second = date.getSeconds(); //秒\n\nvar millds =  date.getMilliseconds() //毫秒\n</code></pre>\n</li>\n</ul>\n<p>##作用域</p>\n<ul>\n<li><p>局部作用域</p>\n<p>在局部作用域下声明的变量，只在局部作用域生效</p>\n</li>\n<li><p>全局作用域</p>\n<p>全局的变量，能在js部分的任何位置都可以访问。</p>\n</li>\n</ul>\n<p>语法：</p>\n<pre><code class=\"javascript\">function fun()&#123;\n    var a = 1;    //a就是一个局部变量，函数外面不可使用\n    console.log(a) //会输出1\n&#125;\nfun();\nconsole.log(a) //报错\n</code></pre>\n<p>##预解析</p>\n<ul>\n<li><p>代码每次执行时进入新的作用域，声明的var变量，function函数(){},全部提升到当前作用域的最顶端</p>\n</li>\n<li><p>预解析不是执行代码，是解析完成后才执行代码</p>\n</li>\n<li><p>全局作用域：</p>\n<pre><code class=\"javascript\">//抓var,function \nvar a\nfunction fn()&#123;\n    console.log(&quot;函数&quot;)\n&#125;\n\n---------------------------\n\nconsole.log(a)    //undefined\nfn()    //函数\na = 1\n</code></pre>\n</li>\n<li><p>局部预解析</p>\n<pre><code class=\"javascript\">function fn()&#123;\n    var a;\n    -----------------------\n    console.log(a) //undefined\n    a = 1; \n&#125;    \n</code></pre>\n</li>\n</ul>\n"},{"title":"javascript基础-操作符和流程控制","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 02-js基础\n\n## 操作符\n\n+ 基础操作符\n\n  ```js\n  +，-，*，/，%，++，--\n  \n  var a = 10 + ++a\n  ```\n\n  - ++a和a++的区别\n    + ++a是先自增在运算，a++是先运算在自增，--同理\n\n+ 比较运算符\n\n  ```js\n  < ，> ， >= <= , == , ===,!==,!===\n  ```\n\n  + == 和 === 的区别\n    + ==不区分数据类型，===区分数据类型，！==同理\n\n+ 逻辑操作符\n\n  ```\n  && , || , !\n  ```\n\n+ 赋值运算符\n\n  ```js\n  += , -= , *= , /= , %=\n  ```\n\n+ 优先级\n\n  ```js\n  1. 第一优先级： ()\n  2. 第二优先级： ++ -- !\n  3. 第三优先级： *  /  %\n  4. 第四优先级： +  -\n  5. 第五优先级： >   >=   <   <=\n  6. 第六优先级： ==   !=    ===    !==  \n  7. 第七优先级： &&\n  8. 第八优先级： || \n  9. 第九优先级： = += -= *= /= %=  \n  ```\n\n## 流程控制\n\n+ 表达式\n\n  > 特点：在js代码中，只要可以返回一个结果的，都可以称为一个表达式\n\n  + 可以 直接在控制台敲\n\n  \n\n+ 结构\n\n  - 顺序结构：从上到下执行的代码就是顺序结构，**程序默认就是由上到下顺序执行的**；\n  - 分支结构：**不同的情况下，走不同的分支；**\n  - 循环结构：**重复**做一件事情，其作用就是用来重复执行代码的；\n\n+ 分支结构\n\n  ```js\n  1. if(){}else if(){}else{}\n     \n  2.switch(){\n           case 1:  代码  break;\n           default: \n         }\n  3.\n  ```\n\n+ 三元表达式\n\n  ```js\n  // 表达式1 ? 表达式2 : 表达式3;\n  ```\n\n  ","source":"_posts/笔记/ocean/03-javascript基础总结/02-操作符和流程控制/02-笔记.md","raw":"---\ntitle: javascript基础-操作符和流程控制\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 02-js基础\n\n## 操作符\n\n+ 基础操作符\n\n  ```js\n  +，-，*，/，%，++，--\n  \n  var a = 10 + ++a\n  ```\n\n  - ++a和a++的区别\n    + ++a是先自增在运算，a++是先运算在自增，--同理\n\n+ 比较运算符\n\n  ```js\n  < ，> ， >= <= , == , ===,!==,!===\n  ```\n\n  + == 和 === 的区别\n    + ==不区分数据类型，===区分数据类型，！==同理\n\n+ 逻辑操作符\n\n  ```\n  && , || , !\n  ```\n\n+ 赋值运算符\n\n  ```js\n  += , -= , *= , /= , %=\n  ```\n\n+ 优先级\n\n  ```js\n  1. 第一优先级： ()\n  2. 第二优先级： ++ -- !\n  3. 第三优先级： *  /  %\n  4. 第四优先级： +  -\n  5. 第五优先级： >   >=   <   <=\n  6. 第六优先级： ==   !=    ===    !==  \n  7. 第七优先级： &&\n  8. 第八优先级： || \n  9. 第九优先级： = += -= *= /= %=  \n  ```\n\n## 流程控制\n\n+ 表达式\n\n  > 特点：在js代码中，只要可以返回一个结果的，都可以称为一个表达式\n\n  + 可以 直接在控制台敲\n\n  \n\n+ 结构\n\n  - 顺序结构：从上到下执行的代码就是顺序结构，**程序默认就是由上到下顺序执行的**；\n  - 分支结构：**不同的情况下，走不同的分支；**\n  - 循环结构：**重复**做一件事情，其作用就是用来重复执行代码的；\n\n+ 分支结构\n\n  ```js\n  1. if(){}else if(){}else{}\n     \n  2.switch(){\n           case 1:  代码  break;\n           default: \n         }\n  3.\n  ```\n\n+ 三元表达式\n\n  ```js\n  // 表达式1 ? 表达式2 : 表达式3;\n  ```\n\n  ","slug":"笔记/ocean/03-javascript基础总结/02-操作符和流程控制/02-笔记","published":1,"updated":"2023-03-01T07:07:03.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcg001lawafh32a7uol","content":"<h1 id=\"02-js基础\"><a href=\"#02-js基础\" class=\"headerlink\" title=\"02-js基础\"></a>02-js基础</h1><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ul>\n<li><p>基础操作符</p>\n<pre><code class=\"js\">+，-，*，/，%，++，--\n\nvar a = 10 + ++a\n</code></pre>\n<ul>\n<li>++a和a++的区别<ul>\n<li>++a是先自增在运算，a++是先运算在自增，–同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>比较运算符</p>\n<pre><code class=\"js\">&lt; ，&gt; ， &gt;= &lt;= , == , ===,!==,!===\n</code></pre>\n<ul>\n<li>== 和 === 的区别<ul>\n<li>==不区分数据类型，===区分数据类型，！==同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑操作符</p>\n<pre><code>&amp;&amp; , || , !\n</code></pre>\n</li>\n<li><p>赋值运算符</p>\n<pre><code class=\"js\">+= , -= , *= , /= , %=\n</code></pre>\n</li>\n<li><p>优先级</p>\n<pre><code class=\"js\">1. 第一优先级： ()\n2. 第二优先级： ++ -- !\n3. 第三优先级： *  /  %\n4. 第四优先级： +  -\n5. 第五优先级： &gt;   &gt;=   &lt;   &lt;=\n6. 第六优先级： ==   !=    ===    !==  \n7. 第七优先级： &amp;&amp;\n8. 第八优先级： || \n9. 第九优先级： = += -= *= /= %=  \n</code></pre>\n</li>\n</ul>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><ul>\n<li><p>表达式</p>\n<blockquote>\n<p>特点：在js代码中，只要可以返回一个结果的，都可以称为一个表达式</p>\n</blockquote>\n<ul>\n<li>可以 直接在控制台敲</li>\n</ul>\n</li>\n<li><p>结构</p>\n<ul>\n<li>顺序结构：从上到下执行的代码就是顺序结构，<strong>程序默认就是由上到下顺序执行的</strong>；</li>\n<li>分支结构：<strong>不同的情况下，走不同的分支；</strong></li>\n<li>循环结构：<strong>重复</strong>做一件事情，其作用就是用来重复执行代码的；</li>\n</ul>\n</li>\n<li><p>分支结构</p>\n<pre><code class=\"js\">1. if()&#123;&#125;else if()&#123;&#125;else&#123;&#125;\n   \n2.switch()&#123;\n         case 1:  代码  break;\n         default: \n       &#125;\n3.\n</code></pre>\n</li>\n<li><p>三元表达式</p>\n<pre><code class=\"js\">// 表达式1 ? 表达式2 : 表达式3;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-js基础\"><a href=\"#02-js基础\" class=\"headerlink\" title=\"02-js基础\"></a>02-js基础</h1><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ul>\n<li><p>基础操作符</p>\n<pre><code class=\"js\">+，-，*，/，%，++，--\n\nvar a = 10 + ++a\n</code></pre>\n<ul>\n<li>++a和a++的区别<ul>\n<li>++a是先自增在运算，a++是先运算在自增，–同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>比较运算符</p>\n<pre><code class=\"js\">&lt; ，&gt; ， &gt;= &lt;= , == , ===,!==,!===\n</code></pre>\n<ul>\n<li>== 和 === 的区别<ul>\n<li>==不区分数据类型，===区分数据类型，！==同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑操作符</p>\n<pre><code>&amp;&amp; , || , !\n</code></pre>\n</li>\n<li><p>赋值运算符</p>\n<pre><code class=\"js\">+= , -= , *= , /= , %=\n</code></pre>\n</li>\n<li><p>优先级</p>\n<pre><code class=\"js\">1. 第一优先级： ()\n2. 第二优先级： ++ -- !\n3. 第三优先级： *  /  %\n4. 第四优先级： +  -\n5. 第五优先级： &gt;   &gt;=   &lt;   &lt;=\n6. 第六优先级： ==   !=    ===    !==  \n7. 第七优先级： &amp;&amp;\n8. 第八优先级： || \n9. 第九优先级： = += -= *= /= %=  \n</code></pre>\n</li>\n</ul>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><ul>\n<li><p>表达式</p>\n<blockquote>\n<p>特点：在js代码中，只要可以返回一个结果的，都可以称为一个表达式</p>\n</blockquote>\n<ul>\n<li>可以 直接在控制台敲</li>\n</ul>\n</li>\n<li><p>结构</p>\n<ul>\n<li>顺序结构：从上到下执行的代码就是顺序结构，<strong>程序默认就是由上到下顺序执行的</strong>；</li>\n<li>分支结构：<strong>不同的情况下，走不同的分支；</strong></li>\n<li>循环结构：<strong>重复</strong>做一件事情，其作用就是用来重复执行代码的；</li>\n</ul>\n</li>\n<li><p>分支结构</p>\n<pre><code class=\"js\">1. if()&#123;&#125;else if()&#123;&#125;else&#123;&#125;\n   \n2.switch()&#123;\n         case 1:  代码  break;\n         default: \n       &#125;\n3.\n</code></pre>\n</li>\n<li><p>三元表达式</p>\n<pre><code class=\"js\">// 表达式1 ? 表达式2 : 表达式3;\n</code></pre>\n</li>\n</ul>\n"},{"title":"什么是html","date":"2016-08-06T06:22:48.000Z","_content":"\n\n# 01-html\n\n## 什么是html\n\n> HTML是指超文本标记语言(Hyper Text Markup Language)，它不是编程语言，而是一种标记网页的 语言，标记语言是一套标签\n\n+ 网页\n  + 网页是网站中的一页，通常为html格式，通过浏览器阅读\n\n\n\n####1.浏览器内核\n\n作用：把代码解析为网页给用户看。\n\n####2.web标准\n\nW3C(万维网联盟)：浏览器不同，他们显示页面或者排版就有差异，所以需要一套标准来约束代码。\n\n+ 构成：结构(structure),本体，html\n\n  ​\t 表现(Presentation)，主要指外观的装饰，CSS\n\n  ​\t 行为(Behavior)，主要指网页模型的定义和交互的编写，javascript.\n\n\n\n\n\n## 标签\n\n\n\n####语法规范\n\n1. 由<>包围的关键词。\n2. 有双标签和单标签\n3. 第一个标签是开始标签，第二个是结束标签\n\n###标签关系\n\n+ 双标签：并列关系和包含关系。\n\n\n\n### 基本标签\n\n```html\n1.html\n\n2.body\n\n3.head\n\n4.title\n```\n\n### 语义化标签\n\n+ 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。\n\n+ 常用的语义化标签\n\n  ```html\n  1.标题\n  从大到小\n  <h1></h1>\n  <h2></h2>\n  <h3></h3>\n  <h4></h4>\n  <h5></h5>\n  <h6></h6>\n  \n  2.段落\n  <p></p>\n  \n  3.换行\n  <br/>\n  \n  4.文本\n  strong,b 加粗\n  em,i 倾斜\n  del,s 删除\n  ins,u\t下划线\n  \n  5.图片\n  <img src=\"\" >\n  ```\n\n### 链接标签\n\n+ 链接分类\n  1. 外部链接\n  2. 内部链接\n  3. 空链接\n  4. 下载链接\n  5. 锚点链接\n\n```html\n<a href=\"路径\" target=\"窗口的弹出方式\"></a>\n```\n\n\n\n\n\n## 路径\n\n```\n/ 下一级\n../上一级\n```\n\n+ 相对路径\n\n  以文件本身所在位置参考\n\n+ 绝对路径\n\n  通常是以盘符开始的路径\n\n\n\n## 注释\n\n```\n<!--   这里是注释    -->\n\n```\n\n\n\n##常用特殊字符\n\n```html\n空格 &nbsp;\n\n小于号 &lt;\n\n大于号 &gt;\n\n和号 &amp;\n\n人民币\t&yen;\n\n版权\t&copy;\n\n注册商标\t&reg;\n\n摄氏度\t&deg;\n\n正负号\t&plusmn;\n\n乘号\t&times;\n\n除号\t&divide;\n\n平方2\t&sup2;\n\n立方3\t&sup3;\n```\n\n\n\n","source":"_posts/笔记/ocean/01-html总结/01-什么是html/01-笔记.md","raw":"---\ntitle: 什么是html\ndate: 2016-08-06 14:22:48\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n---\n\n\n# 01-html\n\n## 什么是html\n\n> HTML是指超文本标记语言(Hyper Text Markup Language)，它不是编程语言，而是一种标记网页的 语言，标记语言是一套标签\n\n+ 网页\n  + 网页是网站中的一页，通常为html格式，通过浏览器阅读\n\n\n\n####1.浏览器内核\n\n作用：把代码解析为网页给用户看。\n\n####2.web标准\n\nW3C(万维网联盟)：浏览器不同，他们显示页面或者排版就有差异，所以需要一套标准来约束代码。\n\n+ 构成：结构(structure),本体，html\n\n  ​\t 表现(Presentation)，主要指外观的装饰，CSS\n\n  ​\t 行为(Behavior)，主要指网页模型的定义和交互的编写，javascript.\n\n\n\n\n\n## 标签\n\n\n\n####语法规范\n\n1. 由<>包围的关键词。\n2. 有双标签和单标签\n3. 第一个标签是开始标签，第二个是结束标签\n\n###标签关系\n\n+ 双标签：并列关系和包含关系。\n\n\n\n### 基本标签\n\n```html\n1.html\n\n2.body\n\n3.head\n\n4.title\n```\n\n### 语义化标签\n\n+ 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。\n\n+ 常用的语义化标签\n\n  ```html\n  1.标题\n  从大到小\n  <h1></h1>\n  <h2></h2>\n  <h3></h3>\n  <h4></h4>\n  <h5></h5>\n  <h6></h6>\n  \n  2.段落\n  <p></p>\n  \n  3.换行\n  <br/>\n  \n  4.文本\n  strong,b 加粗\n  em,i 倾斜\n  del,s 删除\n  ins,u\t下划线\n  \n  5.图片\n  <img src=\"\" >\n  ```\n\n### 链接标签\n\n+ 链接分类\n  1. 外部链接\n  2. 内部链接\n  3. 空链接\n  4. 下载链接\n  5. 锚点链接\n\n```html\n<a href=\"路径\" target=\"窗口的弹出方式\"></a>\n```\n\n\n\n\n\n## 路径\n\n```\n/ 下一级\n../上一级\n```\n\n+ 相对路径\n\n  以文件本身所在位置参考\n\n+ 绝对路径\n\n  通常是以盘符开始的路径\n\n\n\n## 注释\n\n```\n<!--   这里是注释    -->\n\n```\n\n\n\n##常用特殊字符\n\n```html\n空格 &nbsp;\n\n小于号 &lt;\n\n大于号 &gt;\n\n和号 &amp;\n\n人民币\t&yen;\n\n版权\t&copy;\n\n注册商标\t&reg;\n\n摄氏度\t&deg;\n\n正负号\t&plusmn;\n\n乘号\t&times;\n\n除号\t&divide;\n\n平方2\t&sup2;\n\n立方3\t&sup3;\n```\n\n\n\n","slug":"笔记/ocean/01-html总结/01-什么是html/01-笔记","published":1,"updated":"2023-03-01T07:06:53.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qch001nawafcntt3vfo","content":"<h1 id=\"01-html\"><a href=\"#01-html\" class=\"headerlink\" title=\"01-html\"></a>01-html</h1><h2 id=\"什么是html\"><a href=\"#什么是html\" class=\"headerlink\" title=\"什么是html\"></a>什么是html</h2><blockquote>\n<p>HTML是指超文本标记语言(Hyper Text Markup Language)，它不是编程语言，而是一种标记网页的 语言，标记语言是一套标签</p>\n</blockquote>\n<ul>\n<li>网页<ul>\n<li>网页是网站中的一页，通常为html格式，通过浏览器阅读</li>\n</ul>\n</li>\n</ul>\n<p>####1.浏览器内核</p>\n<p>作用：把代码解析为网页给用户看。</p>\n<p>####2.web标准</p>\n<p>W3C(万维网联盟)：浏览器不同，他们显示页面或者排版就有差异，所以需要一套标准来约束代码。</p>\n<ul>\n<li><p>构成：结构(structure),本体，html</p>\n<p>​     表现(Presentation)，主要指外观的装饰，CSS</p>\n<p>​     行为(Behavior)，主要指网页模型的定义和交互的编写，javascript.</p>\n</li>\n</ul>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>####语法规范</p>\n<ol>\n<li>由&lt;&gt;包围的关键词。</li>\n<li>有双标签和单标签</li>\n<li>第一个标签是开始标签，第二个是结束标签</li>\n</ol>\n<p>###标签关系</p>\n<ul>\n<li>双标签：并列关系和包含关系。</li>\n</ul>\n<h3 id=\"基本标签\"><a href=\"#基本标签\" class=\"headerlink\" title=\"基本标签\"></a>基本标签</h3><pre><code class=\"html\">1.html\n\n2.body\n\n3.head\n\n4.title\n</code></pre>\n<h3 id=\"语义化标签\"><a href=\"#语义化标签\" class=\"headerlink\" title=\"语义化标签\"></a>语义化标签</h3><ul>\n<li><p>根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。</p>\n</li>\n<li><p>常用的语义化标签</p>\n<pre><code class=\"html\">1.标题\n从大到小\n&lt;h1&gt;&lt;/h1&gt;\n&lt;h2&gt;&lt;/h2&gt;\n&lt;h3&gt;&lt;/h3&gt;\n&lt;h4&gt;&lt;/h4&gt;\n&lt;h5&gt;&lt;/h5&gt;\n&lt;h6&gt;&lt;/h6&gt;\n\n2.段落\n&lt;p&gt;&lt;/p&gt;\n\n3.换行\n&lt;br/&gt;\n\n4.文本\nstrong,b 加粗\nem,i 倾斜\ndel,s 删除\nins,u    下划线\n\n5.图片\n&lt;img src=&quot;&quot; &gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"链接标签\"><a href=\"#链接标签\" class=\"headerlink\" title=\"链接标签\"></a>链接标签</h3><ul>\n<li>链接分类<ol>\n<li>外部链接</li>\n<li>内部链接</li>\n<li>空链接</li>\n<li>下载链接</li>\n<li>锚点链接</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;a href=&quot;路径&quot; target=&quot;窗口的弹出方式&quot;&gt;&lt;/a&gt;\n</code></pre>\n<h2 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h2><pre><code>/ 下一级\n../上一级\n</code></pre>\n<ul>\n<li><p>相对路径</p>\n<p>以文件本身所在位置参考</p>\n</li>\n<li><p>绝对路径</p>\n<p>通常是以盘符开始的路径</p>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code>&lt;!--   这里是注释    --&gt;\n</code></pre>\n<p>##常用特殊字符</p>\n<pre><code class=\"html\">空格 &amp;nbsp;\n\n小于号 &amp;lt;\n\n大于号 &amp;gt;\n\n和号 &amp;amp;\n\n人民币    &amp;yen;\n\n版权    &amp;copy;\n\n注册商标    &amp;reg;\n\n摄氏度    &amp;deg;\n\n正负号    &amp;plusmn;\n\n乘号    &amp;times;\n\n除号    &amp;divide;\n\n平方2    &amp;sup2;\n\n立方3    &amp;sup3;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-html\"><a href=\"#01-html\" class=\"headerlink\" title=\"01-html\"></a>01-html</h1><h2 id=\"什么是html\"><a href=\"#什么是html\" class=\"headerlink\" title=\"什么是html\"></a>什么是html</h2><blockquote>\n<p>HTML是指超文本标记语言(Hyper Text Markup Language)，它不是编程语言，而是一种标记网页的 语言，标记语言是一套标签</p>\n</blockquote>\n<ul>\n<li>网页<ul>\n<li>网页是网站中的一页，通常为html格式，通过浏览器阅读</li>\n</ul>\n</li>\n</ul>\n<p>####1.浏览器内核</p>\n<p>作用：把代码解析为网页给用户看。</p>\n<p>####2.web标准</p>\n<p>W3C(万维网联盟)：浏览器不同，他们显示页面或者排版就有差异，所以需要一套标准来约束代码。</p>\n<ul>\n<li><p>构成：结构(structure),本体，html</p>\n<p>​     表现(Presentation)，主要指外观的装饰，CSS</p>\n<p>​     行为(Behavior)，主要指网页模型的定义和交互的编写，javascript.</p>\n</li>\n</ul>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>####语法规范</p>\n<ol>\n<li>由&lt;&gt;包围的关键词。</li>\n<li>有双标签和单标签</li>\n<li>第一个标签是开始标签，第二个是结束标签</li>\n</ol>\n<p>###标签关系</p>\n<ul>\n<li>双标签：并列关系和包含关系。</li>\n</ul>\n<h3 id=\"基本标签\"><a href=\"#基本标签\" class=\"headerlink\" title=\"基本标签\"></a>基本标签</h3><pre><code class=\"html\">1.html\n\n2.body\n\n3.head\n\n4.title\n</code></pre>\n<h3 id=\"语义化标签\"><a href=\"#语义化标签\" class=\"headerlink\" title=\"语义化标签\"></a>语义化标签</h3><ul>\n<li><p>根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。</p>\n</li>\n<li><p>常用的语义化标签</p>\n<pre><code class=\"html\">1.标题\n从大到小\n&lt;h1&gt;&lt;/h1&gt;\n&lt;h2&gt;&lt;/h2&gt;\n&lt;h3&gt;&lt;/h3&gt;\n&lt;h4&gt;&lt;/h4&gt;\n&lt;h5&gt;&lt;/h5&gt;\n&lt;h6&gt;&lt;/h6&gt;\n\n2.段落\n&lt;p&gt;&lt;/p&gt;\n\n3.换行\n&lt;br/&gt;\n\n4.文本\nstrong,b 加粗\nem,i 倾斜\ndel,s 删除\nins,u    下划线\n\n5.图片\n&lt;img src=&quot;&quot; &gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"链接标签\"><a href=\"#链接标签\" class=\"headerlink\" title=\"链接标签\"></a>链接标签</h3><ul>\n<li>链接分类<ol>\n<li>外部链接</li>\n<li>内部链接</li>\n<li>空链接</li>\n<li>下载链接</li>\n<li>锚点链接</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;a href=&quot;路径&quot; target=&quot;窗口的弹出方式&quot;&gt;&lt;/a&gt;\n</code></pre>\n<h2 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h2><pre><code>/ 下一级\n../上一级\n</code></pre>\n<ul>\n<li><p>相对路径</p>\n<p>以文件本身所在位置参考</p>\n</li>\n<li><p>绝对路径</p>\n<p>通常是以盘符开始的路径</p>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code>&lt;!--   这里是注释    --&gt;\n</code></pre>\n<p>##常用特殊字符</p>\n<pre><code class=\"html\">空格 &amp;nbsp;\n\n小于号 &amp;lt;\n\n大于号 &amp;gt;\n\n和号 &amp;amp;\n\n人民币    &amp;yen;\n\n版权    &amp;copy;\n\n注册商标    &amp;reg;\n\n摄氏度    &amp;deg;\n\n正负号    &amp;plusmn;\n\n乘号    &amp;times;\n\n除号    &amp;divide;\n\n平方2    &amp;sup2;\n\n立方3    &amp;sup3;\n</code></pre>\n"},{"title":"javascript基础-数组,字符串方法","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 06-js基础\n\n## 数组\n\n### 方法\n\n+ 添加\n\n  ```js\n  arr.push(4) //给数组后面添加一个或多个元素\n  arr.unshift(0) //从数组的最前面添加一个或多个元素，返回的是原数组改变后的长度\n  ```\n\n+ 删除\n\n  ```js\n  arr.pop() //从数组后面删除最后一个元素，返回值是被删除的元素 \n  arr.shift() //从数组前面删除一个元素，返回被删除的元素\n  arr.splice(3,1) //从下标为3的位置开始删除1个元素\n  ```\n\n+ 替换\n\n  ```js\n  arr.splice(3,1,4,2)//从下标为3的位置开始删除1个元素，在将4，2添加到数组中，返回值是数组，被删除的所有元素，该方法会改变原始数组。\n  ```\n\n+ 截取\n\n  ```js\n  arr.slice(1,2) //截取数组，从下标为几截取到第几，包左不包右，原数组不会发生改变\n  arr.splice(3,1)\n  ```\n\n  \n\n+ 转字符串\n\n  ```js\n  arr.join('+'); //拆分数组，按指定字符拼接字符串。\n  ```\n\n+ 查询\n\n  ```js\n  arr.indexOf(值) //从位置0开始查找数组中是否有此值，有则返回下标，无返回-1\n  arr.lastIndexOf(值) // 从末尾查找\n  ```\n\n+ 判断\n\n  ```js\n  arr.some(function(item){ return i>5 }) //数组的某一个值满足条件就返回true\n  arr.every(function(item){ return i>5 }) //数组的每一个值满足条件才返回true\n  arr.findIndex(function(item){ return item>=20 }) //返回数组中第一个满足条件的元素的索引\n  arr.find(function(ele,index){ return item>=20 }) //返回数组中第一个满足条件的元素的值\n  ```\n\n+ 排序\n\n  ```js\n  arr.sort() //从小到大排,比较的ASCLL码值，会改变原数组\n  \n  也可以传一个函数\n  function compare(val1,val2){\n      if(val1<val2){\n          return 1;\n      }else{\n          return 0;\n      }\n  }\n  \n  arr.sort(compare)\n  ```\n\n+ 反转\n\n  ```js\n  arr.reverse() //反转数组项的顺序，原数组随之改变\n  ```\n\n+ 数组去重\n\n  ````js\n  new Set(Array.from(arr))\n  \n  filter((item,index) =>{\n      return arr.indexOf(item) === index\n  })\n  \n  \n  function unique(arr){\n      return arr.reduce((per,cur)=>{\n          per.includes(cur)? per : [...per,cur],[]\n      })\n  }\n  ````\n\n+ 遍历\n\n  ```js\n  1.\n  arr.forEach(function(item,index,arr){\n      item // 值\n      index //下标，索引\n      arr //数组本身\n  })// 无返回值\n  \n  2.\n  var arr2 = arr.filter(function(item,index,arr){\n      item //数组的每一个元素\n      index //数组元素的下标\n      arr //数组本身\n      return item >= 5\n  })//返回值是新数组，相当于过滤器\n  \n  3.\n  var arr2 = arr.map(function(item,index,arr){\n      item //数组的每一个元素\n      index //数组元素的下标\n      arr //数组本身\n      return item*5\n  })//返回值是新数组，相当将原始数组的值操作后重新返回\n  arr.map(String) //可以快速将数组里的值转为字符串\n  arr.map(Number) //可以快速将数组里的值转为数字\n  \n  4.\n  arr.reduce(function(prev,cur,index,array){ //从数组开始，遍历到最后\n      prev //上一个值\n      cur//当前值\n      return prev+cur\n  },0)//从下标为几的位置开始遍历\n  \n  arr.reduceRight(function(prev,cur,index,array){})//从数组末尾遍历到第一项\n  ```\n\n+ 拼接\n\n  ```js\n  var arr = [1,2,3]\n  var arr2 = [4,5,6];\n  var newArr =  concat(arr,arr2)  //将多个数组或数据拼接，返回拼的新数组，不改变原数组\n  ```\n\n  \n\n## 字符串方法\n\n+ 转数组\n\n  ```js\n  var newarr = str.split(',') //将字符串用逗号拆分开，拼接为数组\n  ```\n\n+ 替换\n\n  ```js\n  str.replace('b',a) //将匹配到的第一个字符串替换为a\n  str.replace(/b/g,a) //将匹配到的所有字符串替换为a\n  str.replace(正则，function(vak){ val 为值 })\n  ```\n\n+ 查询\n\n  ```js\n  str.indexOf(str) //查询第一个出现的字符，有则返回字符串下标，无则返回-1\n  str.lastIndexOf(str) //查询指定字符最后出现的位置，无则返回-1\n  str.charAt(index)  //找到指定下标的那个字符，返回值是那个字符,如果下标不存在返回空字符串\n  ```\n\n+ 截取\n\n  ```js\n  str.substring(1,4) //截取两个指定下标之间的字符，返回的是新的字符串\n  str.substr(1，5) //从下标为几的位置，截取几个字符\n  ```\n\n+ 去空格\n\n  ```js\n  str.trim() //去头尾空格\n  ```\n\n+ 转大小写\n\n  ```js\n  str.toLowerCase() //转小写，返回一个新的字符串\n  str.toUpperCase() //转大写，返回一个新的字符串\n  ```\n\n  \n\n作业：解析地址栏www.bilibili.com?name=hhh&age=45","source":"_posts/笔记/ocean/03-javascript基础总结/06-数组和字符串方法/06-笔记.md","raw":"---\ntitle: javascript基础-数组,字符串方法\ndate: 2017-02-06 12:01:23\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 06-js基础\n\n## 数组\n\n### 方法\n\n+ 添加\n\n  ```js\n  arr.push(4) //给数组后面添加一个或多个元素\n  arr.unshift(0) //从数组的最前面添加一个或多个元素，返回的是原数组改变后的长度\n  ```\n\n+ 删除\n\n  ```js\n  arr.pop() //从数组后面删除最后一个元素，返回值是被删除的元素 \n  arr.shift() //从数组前面删除一个元素，返回被删除的元素\n  arr.splice(3,1) //从下标为3的位置开始删除1个元素\n  ```\n\n+ 替换\n\n  ```js\n  arr.splice(3,1,4,2)//从下标为3的位置开始删除1个元素，在将4，2添加到数组中，返回值是数组，被删除的所有元素，该方法会改变原始数组。\n  ```\n\n+ 截取\n\n  ```js\n  arr.slice(1,2) //截取数组，从下标为几截取到第几，包左不包右，原数组不会发生改变\n  arr.splice(3,1)\n  ```\n\n  \n\n+ 转字符串\n\n  ```js\n  arr.join('+'); //拆分数组，按指定字符拼接字符串。\n  ```\n\n+ 查询\n\n  ```js\n  arr.indexOf(值) //从位置0开始查找数组中是否有此值，有则返回下标，无返回-1\n  arr.lastIndexOf(值) // 从末尾查找\n  ```\n\n+ 判断\n\n  ```js\n  arr.some(function(item){ return i>5 }) //数组的某一个值满足条件就返回true\n  arr.every(function(item){ return i>5 }) //数组的每一个值满足条件才返回true\n  arr.findIndex(function(item){ return item>=20 }) //返回数组中第一个满足条件的元素的索引\n  arr.find(function(ele,index){ return item>=20 }) //返回数组中第一个满足条件的元素的值\n  ```\n\n+ 排序\n\n  ```js\n  arr.sort() //从小到大排,比较的ASCLL码值，会改变原数组\n  \n  也可以传一个函数\n  function compare(val1,val2){\n      if(val1<val2){\n          return 1;\n      }else{\n          return 0;\n      }\n  }\n  \n  arr.sort(compare)\n  ```\n\n+ 反转\n\n  ```js\n  arr.reverse() //反转数组项的顺序，原数组随之改变\n  ```\n\n+ 数组去重\n\n  ````js\n  new Set(Array.from(arr))\n  \n  filter((item,index) =>{\n      return arr.indexOf(item) === index\n  })\n  \n  \n  function unique(arr){\n      return arr.reduce((per,cur)=>{\n          per.includes(cur)? per : [...per,cur],[]\n      })\n  }\n  ````\n\n+ 遍历\n\n  ```js\n  1.\n  arr.forEach(function(item,index,arr){\n      item // 值\n      index //下标，索引\n      arr //数组本身\n  })// 无返回值\n  \n  2.\n  var arr2 = arr.filter(function(item,index,arr){\n      item //数组的每一个元素\n      index //数组元素的下标\n      arr //数组本身\n      return item >= 5\n  })//返回值是新数组，相当于过滤器\n  \n  3.\n  var arr2 = arr.map(function(item,index,arr){\n      item //数组的每一个元素\n      index //数组元素的下标\n      arr //数组本身\n      return item*5\n  })//返回值是新数组，相当将原始数组的值操作后重新返回\n  arr.map(String) //可以快速将数组里的值转为字符串\n  arr.map(Number) //可以快速将数组里的值转为数字\n  \n  4.\n  arr.reduce(function(prev,cur,index,array){ //从数组开始，遍历到最后\n      prev //上一个值\n      cur//当前值\n      return prev+cur\n  },0)//从下标为几的位置开始遍历\n  \n  arr.reduceRight(function(prev,cur,index,array){})//从数组末尾遍历到第一项\n  ```\n\n+ 拼接\n\n  ```js\n  var arr = [1,2,3]\n  var arr2 = [4,5,6];\n  var newArr =  concat(arr,arr2)  //将多个数组或数据拼接，返回拼的新数组，不改变原数组\n  ```\n\n  \n\n## 字符串方法\n\n+ 转数组\n\n  ```js\n  var newarr = str.split(',') //将字符串用逗号拆分开，拼接为数组\n  ```\n\n+ 替换\n\n  ```js\n  str.replace('b',a) //将匹配到的第一个字符串替换为a\n  str.replace(/b/g,a) //将匹配到的所有字符串替换为a\n  str.replace(正则，function(vak){ val 为值 })\n  ```\n\n+ 查询\n\n  ```js\n  str.indexOf(str) //查询第一个出现的字符，有则返回字符串下标，无则返回-1\n  str.lastIndexOf(str) //查询指定字符最后出现的位置，无则返回-1\n  str.charAt(index)  //找到指定下标的那个字符，返回值是那个字符,如果下标不存在返回空字符串\n  ```\n\n+ 截取\n\n  ```js\n  str.substring(1,4) //截取两个指定下标之间的字符，返回的是新的字符串\n  str.substr(1，5) //从下标为几的位置，截取几个字符\n  ```\n\n+ 去空格\n\n  ```js\n  str.trim() //去头尾空格\n  ```\n\n+ 转大小写\n\n  ```js\n  str.toLowerCase() //转小写，返回一个新的字符串\n  str.toUpperCase() //转大写，返回一个新的字符串\n  ```\n\n  \n\n作业：解析地址栏www.bilibili.com?name=hhh&age=45","slug":"笔记/ocean/03-javascript基础总结/06-数组和字符串方法/06-笔记","published":1,"updated":"2023-03-01T07:07:24.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qci001qawafb5yk4lz1","content":"<h1 id=\"06-js基础\"><a href=\"#06-js基础\" class=\"headerlink\" title=\"06-js基础\"></a>06-js基础</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><p>添加</p>\n<pre><code class=\"js\">arr.push(4) //给数组后面添加一个或多个元素\narr.unshift(0) //从数组的最前面添加一个或多个元素，返回的是原数组改变后的长度\n</code></pre>\n</li>\n<li><p>删除</p>\n<pre><code class=\"js\">arr.pop() //从数组后面删除最后一个元素，返回值是被删除的元素 \narr.shift() //从数组前面删除一个元素，返回被删除的元素\narr.splice(3,1) //从下标为3的位置开始删除1个元素\n</code></pre>\n</li>\n<li><p>替换</p>\n<pre><code class=\"js\">arr.splice(3,1,4,2)//从下标为3的位置开始删除1个元素，在将4，2添加到数组中，返回值是数组，被删除的所有元素，该方法会改变原始数组。\n</code></pre>\n</li>\n<li><p>截取</p>\n<pre><code class=\"js\">arr.slice(1,2) //截取数组，从下标为几截取到第几，包左不包右，原数组不会发生改变\narr.splice(3,1)\n</code></pre>\n</li>\n<li><p>转字符串</p>\n<pre><code class=\"js\">arr.join(&#39;+&#39;); //拆分数组，按指定字符拼接字符串。\n</code></pre>\n</li>\n<li><p>查询</p>\n<pre><code class=\"js\">arr.indexOf(值) //从位置0开始查找数组中是否有此值，有则返回下标，无返回-1\narr.lastIndexOf(值) // 从末尾查找\n</code></pre>\n</li>\n<li><p>判断</p>\n<pre><code class=\"js\">arr.some(function(item)&#123; return i&gt;5 &#125;) //数组的某一个值满足条件就返回true\narr.every(function(item)&#123; return i&gt;5 &#125;) //数组的每一个值满足条件才返回true\narr.findIndex(function(item)&#123; return item&gt;=20 &#125;) //返回数组中第一个满足条件的元素的索引\narr.find(function(ele,index)&#123; return item&gt;=20 &#125;) //返回数组中第一个满足条件的元素的值\n</code></pre>\n</li>\n<li><p>排序</p>\n<pre><code class=\"js\">arr.sort() //从小到大排,比较的ASCLL码值，会改变原数组\n\n也可以传一个函数\nfunction compare(val1,val2)&#123;\n    if(val1&lt;val2)&#123;\n        return 1;\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n\narr.sort(compare)\n</code></pre>\n</li>\n<li><p>反转</p>\n<pre><code class=\"js\">arr.reverse() //反转数组项的顺序，原数组随之改变\n</code></pre>\n</li>\n<li><p>数组去重</p>\n<pre><code class=\"js\">new Set(Array.from(arr))\n\nfilter((item,index) =&gt;&#123;\n    return arr.indexOf(item) === index\n&#125;)\n\n\nfunction unique(arr)&#123;\n    return arr.reduce((per,cur)=&gt;&#123;\n        per.includes(cur)? per : [...per,cur],[]\n    &#125;)\n&#125;\n</code></pre>\n</li>\n<li><p>遍历</p>\n<pre><code class=\"js\">1.\narr.forEach(function(item,index,arr)&#123;\n    item // 值\n    index //下标，索引\n    arr //数组本身\n&#125;)// 无返回值\n\n2.\nvar arr2 = arr.filter(function(item,index,arr)&#123;\n    item //数组的每一个元素\n    index //数组元素的下标\n    arr //数组本身\n    return item &gt;= 5\n&#125;)//返回值是新数组，相当于过滤器\n\n3.\nvar arr2 = arr.map(function(item,index,arr)&#123;\n    item //数组的每一个元素\n    index //数组元素的下标\n    arr //数组本身\n    return item*5\n&#125;)//返回值是新数组，相当将原始数组的值操作后重新返回\narr.map(String) //可以快速将数组里的值转为字符串\narr.map(Number) //可以快速将数组里的值转为数字\n\n4.\narr.reduce(function(prev,cur,index,array)&#123; //从数组开始，遍历到最后\n    prev //上一个值\n    cur//当前值\n    return prev+cur\n&#125;,0)//从下标为几的位置开始遍历\n\narr.reduceRight(function(prev,cur,index,array)&#123;&#125;)//从数组末尾遍历到第一项\n</code></pre>\n</li>\n<li><p>拼接</p>\n<pre><code class=\"js\">var arr = [1,2,3]\nvar arr2 = [4,5,6];\nvar newArr =  concat(arr,arr2)  //将多个数组或数据拼接，返回拼的新数组，不改变原数组\n</code></pre>\n</li>\n</ul>\n<h2 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a>字符串方法</h2><ul>\n<li><p>转数组</p>\n<pre><code class=\"js\">var newarr = str.split(&#39;,&#39;) //将字符串用逗号拆分开，拼接为数组\n</code></pre>\n</li>\n<li><p>替换</p>\n<pre><code class=\"js\">str.replace(&#39;b&#39;,a) //将匹配到的第一个字符串替换为a\nstr.replace(/b/g,a) //将匹配到的所有字符串替换为a\nstr.replace(正则，function(vak)&#123; val 为值 &#125;)\n</code></pre>\n</li>\n<li><p>查询</p>\n<pre><code class=\"js\">str.indexOf(str) //查询第一个出现的字符，有则返回字符串下标，无则返回-1\nstr.lastIndexOf(str) //查询指定字符最后出现的位置，无则返回-1\nstr.charAt(index)  //找到指定下标的那个字符，返回值是那个字符,如果下标不存在返回空字符串\n</code></pre>\n</li>\n<li><p>截取</p>\n<pre><code class=\"js\">str.substring(1,4) //截取两个指定下标之间的字符，返回的是新的字符串\nstr.substr(1，5) //从下标为几的位置，截取几个字符\n</code></pre>\n</li>\n<li><p>去空格</p>\n<pre><code class=\"js\">str.trim() //去头尾空格\n</code></pre>\n</li>\n<li><p>转大小写</p>\n<pre><code class=\"js\">str.toLowerCase() //转小写，返回一个新的字符串\nstr.toUpperCase() //转大写，返回一个新的字符串\n</code></pre>\n</li>\n</ul>\n<p>作业：解析地址栏<a href=\"http://www.bilibili.com/?name=hhh&amp;age=45\">www.bilibili.com?name=hhh&amp;age=45</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"06-js基础\"><a href=\"#06-js基础\" class=\"headerlink\" title=\"06-js基础\"></a>06-js基础</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><p>添加</p>\n<pre><code class=\"js\">arr.push(4) //给数组后面添加一个或多个元素\narr.unshift(0) //从数组的最前面添加一个或多个元素，返回的是原数组改变后的长度\n</code></pre>\n</li>\n<li><p>删除</p>\n<pre><code class=\"js\">arr.pop() //从数组后面删除最后一个元素，返回值是被删除的元素 \narr.shift() //从数组前面删除一个元素，返回被删除的元素\narr.splice(3,1) //从下标为3的位置开始删除1个元素\n</code></pre>\n</li>\n<li><p>替换</p>\n<pre><code class=\"js\">arr.splice(3,1,4,2)//从下标为3的位置开始删除1个元素，在将4，2添加到数组中，返回值是数组，被删除的所有元素，该方法会改变原始数组。\n</code></pre>\n</li>\n<li><p>截取</p>\n<pre><code class=\"js\">arr.slice(1,2) //截取数组，从下标为几截取到第几，包左不包右，原数组不会发生改变\narr.splice(3,1)\n</code></pre>\n</li>\n<li><p>转字符串</p>\n<pre><code class=\"js\">arr.join(&#39;+&#39;); //拆分数组，按指定字符拼接字符串。\n</code></pre>\n</li>\n<li><p>查询</p>\n<pre><code class=\"js\">arr.indexOf(值) //从位置0开始查找数组中是否有此值，有则返回下标，无返回-1\narr.lastIndexOf(值) // 从末尾查找\n</code></pre>\n</li>\n<li><p>判断</p>\n<pre><code class=\"js\">arr.some(function(item)&#123; return i&gt;5 &#125;) //数组的某一个值满足条件就返回true\narr.every(function(item)&#123; return i&gt;5 &#125;) //数组的每一个值满足条件才返回true\narr.findIndex(function(item)&#123; return item&gt;=20 &#125;) //返回数组中第一个满足条件的元素的索引\narr.find(function(ele,index)&#123; return item&gt;=20 &#125;) //返回数组中第一个满足条件的元素的值\n</code></pre>\n</li>\n<li><p>排序</p>\n<pre><code class=\"js\">arr.sort() //从小到大排,比较的ASCLL码值，会改变原数组\n\n也可以传一个函数\nfunction compare(val1,val2)&#123;\n    if(val1&lt;val2)&#123;\n        return 1;\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n\narr.sort(compare)\n</code></pre>\n</li>\n<li><p>反转</p>\n<pre><code class=\"js\">arr.reverse() //反转数组项的顺序，原数组随之改变\n</code></pre>\n</li>\n<li><p>数组去重</p>\n<pre><code class=\"js\">new Set(Array.from(arr))\n\nfilter((item,index) =&gt;&#123;\n    return arr.indexOf(item) === index\n&#125;)\n\n\nfunction unique(arr)&#123;\n    return arr.reduce((per,cur)=&gt;&#123;\n        per.includes(cur)? per : [...per,cur],[]\n    &#125;)\n&#125;\n</code></pre>\n</li>\n<li><p>遍历</p>\n<pre><code class=\"js\">1.\narr.forEach(function(item,index,arr)&#123;\n    item // 值\n    index //下标，索引\n    arr //数组本身\n&#125;)// 无返回值\n\n2.\nvar arr2 = arr.filter(function(item,index,arr)&#123;\n    item //数组的每一个元素\n    index //数组元素的下标\n    arr //数组本身\n    return item &gt;= 5\n&#125;)//返回值是新数组，相当于过滤器\n\n3.\nvar arr2 = arr.map(function(item,index,arr)&#123;\n    item //数组的每一个元素\n    index //数组元素的下标\n    arr //数组本身\n    return item*5\n&#125;)//返回值是新数组，相当将原始数组的值操作后重新返回\narr.map(String) //可以快速将数组里的值转为字符串\narr.map(Number) //可以快速将数组里的值转为数字\n\n4.\narr.reduce(function(prev,cur,index,array)&#123; //从数组开始，遍历到最后\n    prev //上一个值\n    cur//当前值\n    return prev+cur\n&#125;,0)//从下标为几的位置开始遍历\n\narr.reduceRight(function(prev,cur,index,array)&#123;&#125;)//从数组末尾遍历到第一项\n</code></pre>\n</li>\n<li><p>拼接</p>\n<pre><code class=\"js\">var arr = [1,2,3]\nvar arr2 = [4,5,6];\nvar newArr =  concat(arr,arr2)  //将多个数组或数据拼接，返回拼的新数组，不改变原数组\n</code></pre>\n</li>\n</ul>\n<h2 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a>字符串方法</h2><ul>\n<li><p>转数组</p>\n<pre><code class=\"js\">var newarr = str.split(&#39;,&#39;) //将字符串用逗号拆分开，拼接为数组\n</code></pre>\n</li>\n<li><p>替换</p>\n<pre><code class=\"js\">str.replace(&#39;b&#39;,a) //将匹配到的第一个字符串替换为a\nstr.replace(/b/g,a) //将匹配到的所有字符串替换为a\nstr.replace(正则，function(vak)&#123; val 为值 &#125;)\n</code></pre>\n</li>\n<li><p>查询</p>\n<pre><code class=\"js\">str.indexOf(str) //查询第一个出现的字符，有则返回字符串下标，无则返回-1\nstr.lastIndexOf(str) //查询指定字符最后出现的位置，无则返回-1\nstr.charAt(index)  //找到指定下标的那个字符，返回值是那个字符,如果下标不存在返回空字符串\n</code></pre>\n</li>\n<li><p>截取</p>\n<pre><code class=\"js\">str.substring(1,4) //截取两个指定下标之间的字符，返回的是新的字符串\nstr.substr(1，5) //从下标为几的位置，截取几个字符\n</code></pre>\n</li>\n<li><p>去空格</p>\n<pre><code class=\"js\">str.trim() //去头尾空格\n</code></pre>\n</li>\n<li><p>转大小写</p>\n<pre><code class=\"js\">str.toLowerCase() //转小写，返回一个新的字符串\nstr.toUpperCase() //转大写，返回一个新的字符串\n</code></pre>\n</li>\n</ul>\n<p>作业：解析地址栏<a href=\"http://www.bilibili.com/?name=hhh&amp;age=45\">www.bilibili.com?name=hhh&amp;age=45</a></p>\n"},{"title":"html表格","date":"2016-08-06T06:22:48.000Z","_content":"\n\n# 02-HTML\n\n\n\n## 表格\n\n+ 作用\n\n  > 表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理\n\n+ 使用\n\n  ```html\n  <table>\n      <tr>\n      \t<td></td>\n      </tr>\n  </table>\n  ```\n\n+ 属性\n\n  |   属性名    |      属性值       |                  描述                   |\n  | :---------: | :---------------: | :-------------------------------------: |\n  |    align    | left,center,right |           规定表格的对齐方式            |\n  |   border    |       1或\"\"       | 规定表格单元是否拥有边框，默认为\"\",没有 |\n  | cellpadding |      像素值       | 规定单元边沿与其内容之间的空白，默认为1 |\n  | cellspacing |      像素值       |     规定单元格之间的空白，默认2像素     |\n  |    width    |  像素值或百分比   |             规定表格的亮度              |\n\n+ 结构标签\n\n  ```html\n  <thead>头部\n  \t<tr></tr>\n  </thead>\n  \n  <tbody>主题</tbody>\n  ```\n\n+ 单元格合并\n\n  **跨行合并**：rowspan=\"合并单元格的个数\"     \n\n  ​\t最上侧单元格为目标单元格, 写合并代码\n\n   **跨列合并**：colspan=\"合并单元格的个数\"\n\n  ​\t最左侧单元格为目标单元格, 写合并代码\n\n\n\n## 列表\n\n+ 作用\n\n  > 表格是用来显示数据的，那么列表就是用来布局的。 \n  > 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。\n  > 根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。\n\n  1. 无序\n\n     ```html\n     <ul>\n         <li></li>\n     </ul>\n     \n     \n     1. 无序列表的各个列表项之间没有顺序级别之分，是并列的。\n     2. <ul></ul> 中只能嵌套 <li></li>，直接在 <ul></ul> 标签中输入其他标签或者文字的做法是不被允许的。\n     3. <li> 与 </li> 之间相当于一个容器，可以容纳所有元素。\n     4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。\n     \n     ```\n\n  2. 有序\n\n     ```html\n     <ol>\n         <li></li>\n     </ol>\n     \n     1. <ol></ol>中只能嵌套<li></li>，直接在<ol></ol>标签中输入其他标签或者文字的做法是不被允许的。\n     2. <li> 与 </li>之间相当于一个容器，可以容纳所有元素。\n     3. 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。\n     ```\n\n  3. 自定义列表\n\n     ```html\n     <dl>\n     \t<dt>标题</dt>\n         <dd>内容</dd>\n         <dd>内容</dd>\n     </dl>\n     ```\n\n\n\n## 表单\n\n+ 作用\n\n  > 使用表单目的是为了收集用户信息。\n  > 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。\n\n+ 组成\n\n  + 一个完整的表单通常由3个部分构成\n\n    1. 表单域\n\n       ```html\n       在html标签中，使用<form>定义表单域，以实现用户信息的收集和传递\t\n           \n           <form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\">\n               会把它范围内的表单元素信息提交给服务器.\n           </form>\n       ```\n\n    2. 表单控件\n\n       ```html\n        <input> 标签用于收集用户信息。\n       \n       <input type=\"控件名\" >\n       button,checkbox,file,hidden,image,radio,password,reset,submit,text\n       除了type还有其它属性\n       \n       name,value,checked,maxlength等\n       ```\n\n    3. 提示信息\n\n+ label标签\n\n  + 用于绑定一个表单元素, 当点击<label> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.\n\n  ```html\n  <label for=\"sex\">男</label>\n  <input type=\"radio\" name=\"sex\"  id=\"sex\" />\n  核心： <label> 标签的 for 属性应当与相关元素的 id 属性相同。\n  ```\n\n+ select表单元素\n\n  + 使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<select>标签控件定义下拉列表。\n\n  ```html\n  语法： \n  <select>\n     <option>选项1</option>\n     <option>选项2</option>\n     <option>选项3</option>\n   </select>\n  ```\n\n+ textarea表单元素\n\n  + 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <textarea> 标签。\n\n  ```html\n  语法：\n  \t<textarea rows=\"3\" cols=\"20\">   文本内容 </textarea>\n  ```\n\n  ","source":"_posts/笔记/ocean/01-html总结/02-表格和表单/02-笔记.md","raw":"---\ntitle: html表格\ndate: 2016-08-06 14:22:48\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n---\n\n\n# 02-HTML\n\n\n\n## 表格\n\n+ 作用\n\n  > 表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理\n\n+ 使用\n\n  ```html\n  <table>\n      <tr>\n      \t<td></td>\n      </tr>\n  </table>\n  ```\n\n+ 属性\n\n  |   属性名    |      属性值       |                  描述                   |\n  | :---------: | :---------------: | :-------------------------------------: |\n  |    align    | left,center,right |           规定表格的对齐方式            |\n  |   border    |       1或\"\"       | 规定表格单元是否拥有边框，默认为\"\",没有 |\n  | cellpadding |      像素值       | 规定单元边沿与其内容之间的空白，默认为1 |\n  | cellspacing |      像素值       |     规定单元格之间的空白，默认2像素     |\n  |    width    |  像素值或百分比   |             规定表格的亮度              |\n\n+ 结构标签\n\n  ```html\n  <thead>头部\n  \t<tr></tr>\n  </thead>\n  \n  <tbody>主题</tbody>\n  ```\n\n+ 单元格合并\n\n  **跨行合并**：rowspan=\"合并单元格的个数\"     \n\n  ​\t最上侧单元格为目标单元格, 写合并代码\n\n   **跨列合并**：colspan=\"合并单元格的个数\"\n\n  ​\t最左侧单元格为目标单元格, 写合并代码\n\n\n\n## 列表\n\n+ 作用\n\n  > 表格是用来显示数据的，那么列表就是用来布局的。 \n  > 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。\n  > 根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。\n\n  1. 无序\n\n     ```html\n     <ul>\n         <li></li>\n     </ul>\n     \n     \n     1. 无序列表的各个列表项之间没有顺序级别之分，是并列的。\n     2. <ul></ul> 中只能嵌套 <li></li>，直接在 <ul></ul> 标签中输入其他标签或者文字的做法是不被允许的。\n     3. <li> 与 </li> 之间相当于一个容器，可以容纳所有元素。\n     4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。\n     \n     ```\n\n  2. 有序\n\n     ```html\n     <ol>\n         <li></li>\n     </ol>\n     \n     1. <ol></ol>中只能嵌套<li></li>，直接在<ol></ol>标签中输入其他标签或者文字的做法是不被允许的。\n     2. <li> 与 </li>之间相当于一个容器，可以容纳所有元素。\n     3. 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。\n     ```\n\n  3. 自定义列表\n\n     ```html\n     <dl>\n     \t<dt>标题</dt>\n         <dd>内容</dd>\n         <dd>内容</dd>\n     </dl>\n     ```\n\n\n\n## 表单\n\n+ 作用\n\n  > 使用表单目的是为了收集用户信息。\n  > 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。\n\n+ 组成\n\n  + 一个完整的表单通常由3个部分构成\n\n    1. 表单域\n\n       ```html\n       在html标签中，使用<form>定义表单域，以实现用户信息的收集和传递\t\n           \n           <form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\">\n               会把它范围内的表单元素信息提交给服务器.\n           </form>\n       ```\n\n    2. 表单控件\n\n       ```html\n        <input> 标签用于收集用户信息。\n       \n       <input type=\"控件名\" >\n       button,checkbox,file,hidden,image,radio,password,reset,submit,text\n       除了type还有其它属性\n       \n       name,value,checked,maxlength等\n       ```\n\n    3. 提示信息\n\n+ label标签\n\n  + 用于绑定一个表单元素, 当点击<label> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.\n\n  ```html\n  <label for=\"sex\">男</label>\n  <input type=\"radio\" name=\"sex\"  id=\"sex\" />\n  核心： <label> 标签的 for 属性应当与相关元素的 id 属性相同。\n  ```\n\n+ select表单元素\n\n  + 使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<select>标签控件定义下拉列表。\n\n  ```html\n  语法： \n  <select>\n     <option>选项1</option>\n     <option>选项2</option>\n     <option>选项3</option>\n   </select>\n  ```\n\n+ textarea表单元素\n\n  + 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <textarea> 标签。\n\n  ```html\n  语法：\n  \t<textarea rows=\"3\" cols=\"20\">   文本内容 </textarea>\n  ```\n\n  ","slug":"笔记/ocean/01-html总结/02-表格和表单/02-笔记","published":1,"updated":"2023-03-01T07:06:55.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcj001sawaf4p8m61sn","content":"<h1 id=\"02-HTML\"><a href=\"#02-HTML\" class=\"headerlink\" title=\"02-HTML\"></a>02-HTML</h1><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理</p>\n</blockquote>\n</li>\n<li><p>使用</p>\n<pre><code class=\"html\">&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>\n</li>\n<li><p>属性</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">属性值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">align</td>\n<td align=\"center\">left,center,right</td>\n<td align=\"center\">规定表格的对齐方式</td>\n</tr>\n<tr>\n<td align=\"center\">border</td>\n<td align=\"center\">1或””</td>\n<td align=\"center\">规定表格单元是否拥有边框，默认为””,没有</td>\n</tr>\n<tr>\n<td align=\"center\">cellpadding</td>\n<td align=\"center\">像素值</td>\n<td align=\"center\">规定单元边沿与其内容之间的空白，默认为1</td>\n</tr>\n<tr>\n<td align=\"center\">cellspacing</td>\n<td align=\"center\">像素值</td>\n<td align=\"center\">规定单元格之间的空白，默认2像素</td>\n</tr>\n<tr>\n<td align=\"center\">width</td>\n<td align=\"center\">像素值或百分比</td>\n<td align=\"center\">规定表格的亮度</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>结构标签</p>\n<pre><code class=\"html\">&lt;thead&gt;头部\n    &lt;tr&gt;&lt;/tr&gt;\n&lt;/thead&gt;\n\n&lt;tbody&gt;主题&lt;/tbody&gt;\n</code></pre>\n</li>\n<li><p>单元格合并</p>\n<p><strong>跨行合并</strong>：rowspan=”合并单元格的个数”     </p>\n<p>​    最上侧单元格为目标单元格, 写合并代码</p>\n<p> <strong>跨列合并</strong>：colspan=”合并单元格的个数”</p>\n<p>​    最左侧单元格为目标单元格, 写合并代码</p>\n</li>\n</ul>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>表格是用来显示数据的，那么列表就是用来布局的。<br>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。<br>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p>\n</blockquote>\n<ol>\n<li><p>无序</p>\n<pre><code class=\"html\">&lt;ul&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n\n1. 无序列表的各个列表项之间没有顺序级别之分，是并列的。\n2. &lt;ul&gt;&lt;/ul&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的。\n3. &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。\n4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre>\n</li>\n<li><p>有序</p>\n<pre><code class=\"html\">&lt;ol&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n1. &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。\n2. &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。\n3. 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre>\n</li>\n<li><p>自定义列表</p>\n<pre><code class=\"html\">&lt;dl&gt;\n    &lt;dt&gt;标题&lt;/dt&gt;\n    &lt;dd&gt;内容&lt;/dd&gt;\n    &lt;dd&gt;内容&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>使用表单目的是为了收集用户信息。<br>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p>\n</blockquote>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>一个完整的表单通常由3个部分构成</p>\n<ol>\n<li><p>表单域</p>\n<pre><code class=\"html\">在html标签中，使用&lt;form&gt;定义表单域，以实现用户信息的收集和传递    \n    \n    &lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;&gt;\n        会把它范围内的表单元素信息提交给服务器.\n    &lt;/form&gt;\n</code></pre>\n</li>\n<li><p>表单控件</p>\n<pre><code class=\"html\"> &lt;input&gt; 标签用于收集用户信息。\n\n&lt;input type=&quot;控件名&quot; &gt;\nbutton,checkbox,file,hidden,image,radio,password,reset,submit,text\n除了type还有其它属性\n\nname,value,checked,maxlength等\n</code></pre>\n</li>\n<li><p>提示信息</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>label标签</p>\n<ul>\n<li>用于绑定一个表单元素, 当点击<label> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.</li>\n</ul>\n<pre><code class=\"html\">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot; /&gt;\n核心： &lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。\n</code></pre>\n</li>\n<li><p>select表单元素</p>\n<ul>\n<li>使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<select>标签控件定义下拉列表。</li>\n</ul>\n<pre><code class=\"html\">语法： \n&lt;select&gt;\n   &lt;option&gt;选项1&lt;/option&gt;\n   &lt;option&gt;选项2&lt;/option&gt;\n   &lt;option&gt;选项3&lt;/option&gt;\n &lt;/select&gt;\n</code></pre>\n</li>\n<li><p>textarea表单元素</p>\n<ul>\n<li>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <textarea> 标签。</li>\n</ul>\n<pre><code class=\"html\">语法：\n    &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt;   文本内容 &lt;/textarea&gt;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-HTML\"><a href=\"#02-HTML\" class=\"headerlink\" title=\"02-HTML\"></a>02-HTML</h1><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理</p>\n</blockquote>\n</li>\n<li><p>使用</p>\n<pre><code class=\"html\">&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>\n</li>\n<li><p>属性</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">属性值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">align</td>\n<td align=\"center\">left,center,right</td>\n<td align=\"center\">规定表格的对齐方式</td>\n</tr>\n<tr>\n<td align=\"center\">border</td>\n<td align=\"center\">1或””</td>\n<td align=\"center\">规定表格单元是否拥有边框，默认为””,没有</td>\n</tr>\n<tr>\n<td align=\"center\">cellpadding</td>\n<td align=\"center\">像素值</td>\n<td align=\"center\">规定单元边沿与其内容之间的空白，默认为1</td>\n</tr>\n<tr>\n<td align=\"center\">cellspacing</td>\n<td align=\"center\">像素值</td>\n<td align=\"center\">规定单元格之间的空白，默认2像素</td>\n</tr>\n<tr>\n<td align=\"center\">width</td>\n<td align=\"center\">像素值或百分比</td>\n<td align=\"center\">规定表格的亮度</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>结构标签</p>\n<pre><code class=\"html\">&lt;thead&gt;头部\n    &lt;tr&gt;&lt;/tr&gt;\n&lt;/thead&gt;\n\n&lt;tbody&gt;主题&lt;/tbody&gt;\n</code></pre>\n</li>\n<li><p>单元格合并</p>\n<p><strong>跨行合并</strong>：rowspan=”合并单元格的个数”     </p>\n<p>​    最上侧单元格为目标单元格, 写合并代码</p>\n<p> <strong>跨列合并</strong>：colspan=”合并单元格的个数”</p>\n<p>​    最左侧单元格为目标单元格, 写合并代码</p>\n</li>\n</ul>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>表格是用来显示数据的，那么列表就是用来布局的。<br>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。<br>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p>\n</blockquote>\n<ol>\n<li><p>无序</p>\n<pre><code class=\"html\">&lt;ul&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n\n1. 无序列表的各个列表项之间没有顺序级别之分，是并列的。\n2. &lt;ul&gt;&lt;/ul&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的。\n3. &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。\n4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre>\n</li>\n<li><p>有序</p>\n<pre><code class=\"html\">&lt;ol&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n1. &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。\n2. &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。\n3. 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。\n</code></pre>\n</li>\n<li><p>自定义列表</p>\n<pre><code class=\"html\">&lt;dl&gt;\n    &lt;dt&gt;标题&lt;/dt&gt;\n    &lt;dd&gt;内容&lt;/dd&gt;\n    &lt;dd&gt;内容&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><ul>\n<li><p>作用</p>\n<blockquote>\n<p>使用表单目的是为了收集用户信息。<br>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p>\n</blockquote>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>一个完整的表单通常由3个部分构成</p>\n<ol>\n<li><p>表单域</p>\n<pre><code class=\"html\">在html标签中，使用&lt;form&gt;定义表单域，以实现用户信息的收集和传递    \n    \n    &lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;&gt;\n        会把它范围内的表单元素信息提交给服务器.\n    &lt;/form&gt;\n</code></pre>\n</li>\n<li><p>表单控件</p>\n<pre><code class=\"html\"> &lt;input&gt; 标签用于收集用户信息。\n\n&lt;input type=&quot;控件名&quot; &gt;\nbutton,checkbox,file,hidden,image,radio,password,reset,submit,text\n除了type还有其它属性\n\nname,value,checked,maxlength等\n</code></pre>\n</li>\n<li><p>提示信息</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>label标签</p>\n<ul>\n<li>用于绑定一个表单元素, 当点击<label> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.</li>\n</ul>\n<pre><code class=\"html\">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot; /&gt;\n核心： &lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。\n</code></pre>\n</li>\n<li><p>select表单元素</p>\n<ul>\n<li>使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<select>标签控件定义下拉列表。</li>\n</ul>\n<pre><code class=\"html\">语法： \n&lt;select&gt;\n   &lt;option&gt;选项1&lt;/option&gt;\n   &lt;option&gt;选项2&lt;/option&gt;\n   &lt;option&gt;选项3&lt;/option&gt;\n &lt;/select&gt;\n</code></pre>\n</li>\n<li><p>textarea表单元素</p>\n<ul>\n<li>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <textarea> 标签。</li>\n</ul>\n<pre><code class=\"html\">语法：\n    &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt;   文本内容 &lt;/textarea&gt;\n</code></pre>\n</li>\n</ul>\n"},{"title":"javascriptDom基础-存储","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 03-js Web API\n\n## dom方法\n\n```js\ndom.parentNode() // 获取父级DOM节点；\ndom.removeChild(子DOm节点) //删除指定子dom节点\ndom.children() //获取所有的子元素DOm节点，返回伪数组，当做数组用\ndom.previousElementSibling() //获取上一个紧挨的兄弟元素\n\n\n\n\nvar dom = document.createElement('标签名') //创建一个dom节点（没有添加到html）\ndom.innerHTML = \"<sapn></span>\" //改变dom里的内容，可以识别HTML结构字符串\ndom.innerText = \"<sapn></span>\" //改变dom里的内容，纯文本，不可识别HTML结构字符串\ndom.appendChild(li)  //将名为li的dom节点添加到dom中\ndom.insertBefore(li,span) //将名为li的dom节点,插入到span前面\n\n\n\n\n\ndom.onkeydown = function(e){//监听键盘事件\n    console.log(e.keyCode) //获取按下那个键的code值\n    //Enter:回车码值为13 \n    //ctrl:e.ctrlKey等于true时，说明按下了true\n    //判断回车和ctrl同时按时执行\n    if(e.keyCode == 13 && e.ctrlKey){}\n}\n\n\n//调用onclick点击函数\ndom.onclick(); //这样可以调用点击事件里面的代码\ndom.click(); //和上面一样，相当于在执行一次\n```\n\n## 本地化\n\n+ local:本地；Storage:储存，相当于浏览器自带的U盘\n\n```js\n//添加\nlocalStorage.setItem(键，值) \n//键：数据名，字符串\n//值：要存的数据，要求放入字符串，如果不是字符串，会做隐式转化。如果再存同样的键名的话，会覆盖掉以前的值。\n\n\n//查询\nlocalStorage.getItem(键) \n//键：将键名值取出来\n//返回值:获取一个没有的信息的话，返回null\n\n\n//删除\nlocalStorage.removeItem(键) //删除这个键\nlocalStorage.clear() //清除所有键\n```\n\n## josn\n\n+ 概念\n\n  > json(JavaScript Object Notation)是一种与开发语言无关的，轻量级的数据存储格式，起源于javascript,后来每门语言都有处理json的API.\n\n  ```js\n  //json示例\n  \n  //一个主键对应一个值\n  {\n      \"name\":\"zs\",\n      \"age\":12\n          \n  }\n  \n  //一条数据是一个对象\n  [\n      {\"name\":\"zs\",\"age\":20},\n      {\"name\":\"zs\",\"age\":20},\n      {\"name\":\"zs\",\"age\":20},\n  ]\n  //...\n  ```\n\n+ 方法\n\n  ```js\n  JSON.stringify(arr) //参数是复杂数据类型，返回的是JSON格式字符串\n  JSON.parse(res) //参数JSON格式的字符串，返回解析后的数组，对象\n  ```\n\n  \n\n","source":"_posts/笔记/ocean/04-javascript_webapi/03-localStorage/03-笔记.md","raw":"---\ntitle: javascriptDom基础-存储\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 03-js Web API\n\n## dom方法\n\n```js\ndom.parentNode() // 获取父级DOM节点；\ndom.removeChild(子DOm节点) //删除指定子dom节点\ndom.children() //获取所有的子元素DOm节点，返回伪数组，当做数组用\ndom.previousElementSibling() //获取上一个紧挨的兄弟元素\n\n\n\n\nvar dom = document.createElement('标签名') //创建一个dom节点（没有添加到html）\ndom.innerHTML = \"<sapn></span>\" //改变dom里的内容，可以识别HTML结构字符串\ndom.innerText = \"<sapn></span>\" //改变dom里的内容，纯文本，不可识别HTML结构字符串\ndom.appendChild(li)  //将名为li的dom节点添加到dom中\ndom.insertBefore(li,span) //将名为li的dom节点,插入到span前面\n\n\n\n\n\ndom.onkeydown = function(e){//监听键盘事件\n    console.log(e.keyCode) //获取按下那个键的code值\n    //Enter:回车码值为13 \n    //ctrl:e.ctrlKey等于true时，说明按下了true\n    //判断回车和ctrl同时按时执行\n    if(e.keyCode == 13 && e.ctrlKey){}\n}\n\n\n//调用onclick点击函数\ndom.onclick(); //这样可以调用点击事件里面的代码\ndom.click(); //和上面一样，相当于在执行一次\n```\n\n## 本地化\n\n+ local:本地；Storage:储存，相当于浏览器自带的U盘\n\n```js\n//添加\nlocalStorage.setItem(键，值) \n//键：数据名，字符串\n//值：要存的数据，要求放入字符串，如果不是字符串，会做隐式转化。如果再存同样的键名的话，会覆盖掉以前的值。\n\n\n//查询\nlocalStorage.getItem(键) \n//键：将键名值取出来\n//返回值:获取一个没有的信息的话，返回null\n\n\n//删除\nlocalStorage.removeItem(键) //删除这个键\nlocalStorage.clear() //清除所有键\n```\n\n## josn\n\n+ 概念\n\n  > json(JavaScript Object Notation)是一种与开发语言无关的，轻量级的数据存储格式，起源于javascript,后来每门语言都有处理json的API.\n\n  ```js\n  //json示例\n  \n  //一个主键对应一个值\n  {\n      \"name\":\"zs\",\n      \"age\":12\n          \n  }\n  \n  //一条数据是一个对象\n  [\n      {\"name\":\"zs\",\"age\":20},\n      {\"name\":\"zs\",\"age\":20},\n      {\"name\":\"zs\",\"age\":20},\n  ]\n  //...\n  ```\n\n+ 方法\n\n  ```js\n  JSON.stringify(arr) //参数是复杂数据类型，返回的是JSON格式字符串\n  JSON.parse(res) //参数JSON格式的字符串，返回解析后的数组，对象\n  ```\n\n  \n\n","slug":"笔记/ocean/04-javascript_webapi/03-localStorage/03-笔记","published":1,"updated":"2023-03-01T06:54:36.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qck001xawaffrve39lh","content":"<h1 id=\"03-js-Web-API\"><a href=\"#03-js-Web-API\" class=\"headerlink\" title=\"03-js Web API\"></a>03-js Web API</h1><h2 id=\"dom方法\"><a href=\"#dom方法\" class=\"headerlink\" title=\"dom方法\"></a>dom方法</h2><pre><code class=\"js\">dom.parentNode() // 获取父级DOM节点；\ndom.removeChild(子DOm节点) //删除指定子dom节点\ndom.children() //获取所有的子元素DOm节点，返回伪数组，当做数组用\ndom.previousElementSibling() //获取上一个紧挨的兄弟元素\n\n\n\n\nvar dom = document.createElement(&#39;标签名&#39;) //创建一个dom节点（没有添加到html）\ndom.innerHTML = &quot;&lt;sapn&gt;&lt;/span&gt;&quot; //改变dom里的内容，可以识别HTML结构字符串\ndom.innerText = &quot;&lt;sapn&gt;&lt;/span&gt;&quot; //改变dom里的内容，纯文本，不可识别HTML结构字符串\ndom.appendChild(li)  //将名为li的dom节点添加到dom中\ndom.insertBefore(li,span) //将名为li的dom节点,插入到span前面\n\n\n\n\n\ndom.onkeydown = function(e)&#123;//监听键盘事件\n    console.log(e.keyCode) //获取按下那个键的code值\n    //Enter:回车码值为13 \n    //ctrl:e.ctrlKey等于true时，说明按下了true\n    //判断回车和ctrl同时按时执行\n    if(e.keyCode == 13 &amp;&amp; e.ctrlKey)&#123;&#125;\n&#125;\n\n\n//调用onclick点击函数\ndom.onclick(); //这样可以调用点击事件里面的代码\ndom.click(); //和上面一样，相当于在执行一次\n</code></pre>\n<h2 id=\"本地化\"><a href=\"#本地化\" class=\"headerlink\" title=\"本地化\"></a>本地化</h2><ul>\n<li>local:本地；Storage:储存，相当于浏览器自带的U盘</li>\n</ul>\n<pre><code class=\"js\">//添加\nlocalStorage.setItem(键，值) \n//键：数据名，字符串\n//值：要存的数据，要求放入字符串，如果不是字符串，会做隐式转化。如果再存同样的键名的话，会覆盖掉以前的值。\n\n\n//查询\nlocalStorage.getItem(键) \n//键：将键名值取出来\n//返回值:获取一个没有的信息的话，返回null\n\n\n//删除\nlocalStorage.removeItem(键) //删除这个键\nlocalStorage.clear() //清除所有键\n</code></pre>\n<h2 id=\"josn\"><a href=\"#josn\" class=\"headerlink\" title=\"josn\"></a>josn</h2><ul>\n<li><p>概念</p>\n<blockquote>\n<p>json(JavaScript Object Notation)是一种与开发语言无关的，轻量级的数据存储格式，起源于javascript,后来每门语言都有处理json的API.</p>\n</blockquote>\n<pre><code class=\"js\">//json示例\n\n//一个主键对应一个值\n&#123;\n    &quot;name&quot;:&quot;zs&quot;,\n    &quot;age&quot;:12\n        \n&#125;\n\n//一条数据是一个对象\n[\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n]\n//...\n</code></pre>\n</li>\n<li><p>方法</p>\n<pre><code class=\"js\">JSON.stringify(arr) //参数是复杂数据类型，返回的是JSON格式字符串\nJSON.parse(res) //参数JSON格式的字符串，返回解析后的数组，对象\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-js-Web-API\"><a href=\"#03-js-Web-API\" class=\"headerlink\" title=\"03-js Web API\"></a>03-js Web API</h1><h2 id=\"dom方法\"><a href=\"#dom方法\" class=\"headerlink\" title=\"dom方法\"></a>dom方法</h2><pre><code class=\"js\">dom.parentNode() // 获取父级DOM节点；\ndom.removeChild(子DOm节点) //删除指定子dom节点\ndom.children() //获取所有的子元素DOm节点，返回伪数组，当做数组用\ndom.previousElementSibling() //获取上一个紧挨的兄弟元素\n\n\n\n\nvar dom = document.createElement(&#39;标签名&#39;) //创建一个dom节点（没有添加到html）\ndom.innerHTML = &quot;&lt;sapn&gt;&lt;/span&gt;&quot; //改变dom里的内容，可以识别HTML结构字符串\ndom.innerText = &quot;&lt;sapn&gt;&lt;/span&gt;&quot; //改变dom里的内容，纯文本，不可识别HTML结构字符串\ndom.appendChild(li)  //将名为li的dom节点添加到dom中\ndom.insertBefore(li,span) //将名为li的dom节点,插入到span前面\n\n\n\n\n\ndom.onkeydown = function(e)&#123;//监听键盘事件\n    console.log(e.keyCode) //获取按下那个键的code值\n    //Enter:回车码值为13 \n    //ctrl:e.ctrlKey等于true时，说明按下了true\n    //判断回车和ctrl同时按时执行\n    if(e.keyCode == 13 &amp;&amp; e.ctrlKey)&#123;&#125;\n&#125;\n\n\n//调用onclick点击函数\ndom.onclick(); //这样可以调用点击事件里面的代码\ndom.click(); //和上面一样，相当于在执行一次\n</code></pre>\n<h2 id=\"本地化\"><a href=\"#本地化\" class=\"headerlink\" title=\"本地化\"></a>本地化</h2><ul>\n<li>local:本地；Storage:储存，相当于浏览器自带的U盘</li>\n</ul>\n<pre><code class=\"js\">//添加\nlocalStorage.setItem(键，值) \n//键：数据名，字符串\n//值：要存的数据，要求放入字符串，如果不是字符串，会做隐式转化。如果再存同样的键名的话，会覆盖掉以前的值。\n\n\n//查询\nlocalStorage.getItem(键) \n//键：将键名值取出来\n//返回值:获取一个没有的信息的话，返回null\n\n\n//删除\nlocalStorage.removeItem(键) //删除这个键\nlocalStorage.clear() //清除所有键\n</code></pre>\n<h2 id=\"josn\"><a href=\"#josn\" class=\"headerlink\" title=\"josn\"></a>josn</h2><ul>\n<li><p>概念</p>\n<blockquote>\n<p>json(JavaScript Object Notation)是一种与开发语言无关的，轻量级的数据存储格式，起源于javascript,后来每门语言都有处理json的API.</p>\n</blockquote>\n<pre><code class=\"js\">//json示例\n\n//一个主键对应一个值\n&#123;\n    &quot;name&quot;:&quot;zs&quot;,\n    &quot;age&quot;:12\n        \n&#125;\n\n//一条数据是一个对象\n[\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n    &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;,\n]\n//...\n</code></pre>\n</li>\n<li><p>方法</p>\n<pre><code class=\"js\">JSON.stringify(arr) //参数是复杂数据类型，返回的是JSON格式字符串\nJSON.parse(res) //参数JSON格式的字符串，返回解析后的数组，对象\n</code></pre>\n</li>\n</ul>\n"},{"title":"canvas基础使用","date":"2016-08-06T06:22:48.000Z","_content":"\n# Canvas（画布）\n\n+ 使用\n\n  ```js\n  //1.获取画布\n  var cas = document.querySelector('canvas)\n                                   \n  //2.获取画笔\n  var ctx = cas.getContetxt('2d');\n  \n  //3.用画笔向画布上画图\n  ctx.moveTo(100,100)  //设置画笔的起始点，x,y轴\n  ctx.lineTo(300,100) //设置画笔的结束点\n  ctx.stroke() //对绘制到画布的路径进行描边\n  ctx.rect(100,100,100,100) //前两个参数为坐标，后两个为宽高\n  \n  //4.向画布中绘制一张图片\n  var img = new Image()\n  img.src = '路径'\n  img.onload = function(){\n  \tctx.drawImage(img,0,0,100,100,0,0,100,100) //\n  }\n  var bas64data = cas.toDataURL() //生成一个bas64地图片地址\n  ```\n\n  \n\n","source":"_posts/笔记/ocean/01-html总结/canvas画布/canvas.md","raw":"---\ntitle: canvas基础使用\ndate: 2016-08-06 14:22:48\n\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n---\n\n# Canvas（画布）\n\n+ 使用\n\n  ```js\n  //1.获取画布\n  var cas = document.querySelector('canvas)\n                                   \n  //2.获取画笔\n  var ctx = cas.getContetxt('2d');\n  \n  //3.用画笔向画布上画图\n  ctx.moveTo(100,100)  //设置画笔的起始点，x,y轴\n  ctx.lineTo(300,100) //设置画笔的结束点\n  ctx.stroke() //对绘制到画布的路径进行描边\n  ctx.rect(100,100,100,100) //前两个参数为坐标，后两个为宽高\n  \n  //4.向画布中绘制一张图片\n  var img = new Image()\n  img.src = '路径'\n  img.onload = function(){\n  \tctx.drawImage(img,0,0,100,100,0,0,100,100) //\n  }\n  var bas64data = cas.toDataURL() //生成一个bas64地图片地址\n  ```\n\n  \n\n","slug":"笔记/ocean/01-html总结/canvas画布/canvas","published":1,"updated":"2023-03-01T07:06:58.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcl001zawaf8q869gjx","content":"<h1 id=\"Canvas（画布）\"><a href=\"#Canvas（画布）\" class=\"headerlink\" title=\"Canvas（画布）\"></a>Canvas（画布）</h1><ul>\n<li><p>使用</p>\n<pre><code class=\"js\">//1.获取画布\nvar cas = document.querySelector(&#39;canvas)\n                                 \n//2.获取画笔\nvar ctx = cas.getContetxt(&#39;2d&#39;);\n\n//3.用画笔向画布上画图\nctx.moveTo(100,100)  //设置画笔的起始点，x,y轴\nctx.lineTo(300,100) //设置画笔的结束点\nctx.stroke() //对绘制到画布的路径进行描边\nctx.rect(100,100,100,100) //前两个参数为坐标，后两个为宽高\n\n//4.向画布中绘制一张图片\nvar img = new Image()\nimg.src = &#39;路径&#39;\nimg.onload = function()&#123;\n    ctx.drawImage(img,0,0,100,100,0,0,100,100) //\n&#125;\nvar bas64data = cas.toDataURL() //生成一个bas64地图片地址\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Canvas（画布）\"><a href=\"#Canvas（画布）\" class=\"headerlink\" title=\"Canvas（画布）\"></a>Canvas（画布）</h1><ul>\n<li><p>使用</p>\n<pre><code class=\"js\">//1.获取画布\nvar cas = document.querySelector(&#39;canvas)\n                                 \n//2.获取画笔\nvar ctx = cas.getContetxt(&#39;2d&#39;);\n\n//3.用画笔向画布上画图\nctx.moveTo(100,100)  //设置画笔的起始点，x,y轴\nctx.lineTo(300,100) //设置画笔的结束点\nctx.stroke() //对绘制到画布的路径进行描边\nctx.rect(100,100,100,100) //前两个参数为坐标，后两个为宽高\n\n//4.向画布中绘制一张图片\nvar img = new Image()\nimg.src = &#39;路径&#39;\nimg.onload = function()&#123;\n    ctx.drawImage(img,0,0,100,100,0,0,100,100) //\n&#125;\nvar bas64data = cas.toDataURL() //生成一个bas64地图片地址\n</code></pre>\n</li>\n</ul>\n"},{"title":"javascriptDom基础-事件委托和冒泡","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 02-js Web API\n\n## 表单属性\n\n```js\n.checked //获取复选框checked的值\n.selected //获取下拉框selected\n.disabled //获取按钮disabled\n```\n\n## 获取属性\n\n```js\n.getAttribute(\"属性名\") //获取DOM元素上的属性值\n.setAttribute(\"属性名\",\"属性值\") //添加一个新的属性名\n```\n\n## 事件\n\n+ 注册事件\n\n  ```js\n  // 给dom元素注册监听事件\n  dom.addEventListener(\"事件名不加on\",function(){\n  }) \n  \n  *//当使用on给同一个dom节点绑定先同的事件，会造成覆盖，而addEventListener可以给同一个dom节点注册多个监听事件，不会覆盖\n  ```\n\n+ 事件机制\n\n  + 事件发生时的三个阶段\n\n    1. 捕获：从跟节点到目标节点的过程\n    2. 到达目标：找到了要触发的节点\n    3. 冒泡：从触发节点到根节点。\n\n  + 事件冒泡\n\n    > 原理：当子元素和父元素都注册了同样的事件时，当触发子元素事件时，由于事件默认实在冒泡阶段执行的，冒泡经过父元素时，父元素的事件也会被触发\n\n    + 解决\n\n      ```js\n      //给子元素添加阻止冒泡方法，使其不会向父元素冒泡，从而不执行父元素的冒泡阶段\n      dom.addEventListener(\"事件名不加on\",function(){\n          e.stopPropagation(); //阻止冒泡\n      }，true) //设置为true的时候，捕获时执行\n      ```\n\n+ 事件委托\n\n  + 原理：利用了事件冒泡机制，只指定一个事件处理程序，管理某一类型的所有事件。\n\n  > 场景：当父元素下面有很多的子DOM节点，都要注册同一个事件并且随时都会新加入一些DOM子节点，此时如果给每一个子dom节点都注册事件，不仅会造成性能不佳，还会导致新的子dom节点绑定不上事件，这时需要事件委托。\n\n  ```js\n  father.addEventListener(\"click\",e=>{\n      e.target; // 指向触发事件监听的对象，谁触发了就是谁\n      e.currentTarget//指向添加监听事件的对象,也就是谁绑定的事件指的就是谁\n  })\n  \n  //在事件中，this始终等于currentTarget\n  ```\n\n  \n\n","source":"_posts/笔记/ocean/04-javascript_webapi/02-事件委托和冒泡/02-笔记.md","raw":"---\ntitle: javascriptDom基础-事件委托和冒泡\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 02-js Web API\n\n## 表单属性\n\n```js\n.checked //获取复选框checked的值\n.selected //获取下拉框selected\n.disabled //获取按钮disabled\n```\n\n## 获取属性\n\n```js\n.getAttribute(\"属性名\") //获取DOM元素上的属性值\n.setAttribute(\"属性名\",\"属性值\") //添加一个新的属性名\n```\n\n## 事件\n\n+ 注册事件\n\n  ```js\n  // 给dom元素注册监听事件\n  dom.addEventListener(\"事件名不加on\",function(){\n  }) \n  \n  *//当使用on给同一个dom节点绑定先同的事件，会造成覆盖，而addEventListener可以给同一个dom节点注册多个监听事件，不会覆盖\n  ```\n\n+ 事件机制\n\n  + 事件发生时的三个阶段\n\n    1. 捕获：从跟节点到目标节点的过程\n    2. 到达目标：找到了要触发的节点\n    3. 冒泡：从触发节点到根节点。\n\n  + 事件冒泡\n\n    > 原理：当子元素和父元素都注册了同样的事件时，当触发子元素事件时，由于事件默认实在冒泡阶段执行的，冒泡经过父元素时，父元素的事件也会被触发\n\n    + 解决\n\n      ```js\n      //给子元素添加阻止冒泡方法，使其不会向父元素冒泡，从而不执行父元素的冒泡阶段\n      dom.addEventListener(\"事件名不加on\",function(){\n          e.stopPropagation(); //阻止冒泡\n      }，true) //设置为true的时候，捕获时执行\n      ```\n\n+ 事件委托\n\n  + 原理：利用了事件冒泡机制，只指定一个事件处理程序，管理某一类型的所有事件。\n\n  > 场景：当父元素下面有很多的子DOM节点，都要注册同一个事件并且随时都会新加入一些DOM子节点，此时如果给每一个子dom节点都注册事件，不仅会造成性能不佳，还会导致新的子dom节点绑定不上事件，这时需要事件委托。\n\n  ```js\n  father.addEventListener(\"click\",e=>{\n      e.target; // 指向触发事件监听的对象，谁触发了就是谁\n      e.currentTarget//指向添加监听事件的对象,也就是谁绑定的事件指的就是谁\n  })\n  \n  //在事件中，this始终等于currentTarget\n  ```\n\n  \n\n","slug":"笔记/ocean/04-javascript_webapi/02-事件委托和冒泡/02-笔记","published":1,"updated":"2023-03-01T06:54:18.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcn0023awaf62gxekik","content":"<h1 id=\"02-js-Web-API\"><a href=\"#02-js-Web-API\" class=\"headerlink\" title=\"02-js Web API\"></a>02-js Web API</h1><h2 id=\"表单属性\"><a href=\"#表单属性\" class=\"headerlink\" title=\"表单属性\"></a>表单属性</h2><pre><code class=\"js\">.checked //获取复选框checked的值\n.selected //获取下拉框selected\n.disabled //获取按钮disabled\n</code></pre>\n<h2 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h2><pre><code class=\"js\">.getAttribute(&quot;属性名&quot;) //获取DOM元素上的属性值\n.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;) //添加一个新的属性名\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li><p>注册事件</p>\n<pre><code class=\"js\">// 给dom元素注册监听事件\ndom.addEventListener(&quot;事件名不加on&quot;,function()&#123;\n&#125;) \n\n*//当使用on给同一个dom节点绑定先同的事件，会造成覆盖，而addEventListener可以给同一个dom节点注册多个监听事件，不会覆盖\n</code></pre>\n</li>\n<li><p>事件机制</p>\n<ul>\n<li><p>事件发生时的三个阶段</p>\n<ol>\n<li>捕获：从跟节点到目标节点的过程</li>\n<li>到达目标：找到了要触发的节点</li>\n<li>冒泡：从触发节点到根节点。</li>\n</ol>\n</li>\n<li><p>事件冒泡</p>\n<blockquote>\n<p>原理：当子元素和父元素都注册了同样的事件时，当触发子元素事件时，由于事件默认实在冒泡阶段执行的，冒泡经过父元素时，父元素的事件也会被触发</p>\n</blockquote>\n<ul>\n<li><p>解决</p>\n<pre><code class=\"js\">//给子元素添加阻止冒泡方法，使其不会向父元素冒泡，从而不执行父元素的冒泡阶段\ndom.addEventListener(&quot;事件名不加on&quot;,function()&#123;\n    e.stopPropagation(); //阻止冒泡\n&#125;，true) //设置为true的时候，捕获时执行\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>事件委托</p>\n<ul>\n<li>原理：利用了事件冒泡机制，只指定一个事件处理程序，管理某一类型的所有事件。</li>\n</ul>\n<blockquote>\n<p>场景：当父元素下面有很多的子DOM节点，都要注册同一个事件并且随时都会新加入一些DOM子节点，此时如果给每一个子dom节点都注册事件，不仅会造成性能不佳，还会导致新的子dom节点绑定不上事件，这时需要事件委托。</p>\n</blockquote>\n<pre><code class=\"js\">father.addEventListener(&quot;click&quot;,e=&gt;&#123;\n    e.target; // 指向触发事件监听的对象，谁触发了就是谁\n    e.currentTarget//指向添加监听事件的对象,也就是谁绑定的事件指的就是谁\n&#125;)\n\n//在事件中，this始终等于currentTarget\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-js-Web-API\"><a href=\"#02-js-Web-API\" class=\"headerlink\" title=\"02-js Web API\"></a>02-js Web API</h1><h2 id=\"表单属性\"><a href=\"#表单属性\" class=\"headerlink\" title=\"表单属性\"></a>表单属性</h2><pre><code class=\"js\">.checked //获取复选框checked的值\n.selected //获取下拉框selected\n.disabled //获取按钮disabled\n</code></pre>\n<h2 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h2><pre><code class=\"js\">.getAttribute(&quot;属性名&quot;) //获取DOM元素上的属性值\n.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;) //添加一个新的属性名\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li><p>注册事件</p>\n<pre><code class=\"js\">// 给dom元素注册监听事件\ndom.addEventListener(&quot;事件名不加on&quot;,function()&#123;\n&#125;) \n\n*//当使用on给同一个dom节点绑定先同的事件，会造成覆盖，而addEventListener可以给同一个dom节点注册多个监听事件，不会覆盖\n</code></pre>\n</li>\n<li><p>事件机制</p>\n<ul>\n<li><p>事件发生时的三个阶段</p>\n<ol>\n<li>捕获：从跟节点到目标节点的过程</li>\n<li>到达目标：找到了要触发的节点</li>\n<li>冒泡：从触发节点到根节点。</li>\n</ol>\n</li>\n<li><p>事件冒泡</p>\n<blockquote>\n<p>原理：当子元素和父元素都注册了同样的事件时，当触发子元素事件时，由于事件默认实在冒泡阶段执行的，冒泡经过父元素时，父元素的事件也会被触发</p>\n</blockquote>\n<ul>\n<li><p>解决</p>\n<pre><code class=\"js\">//给子元素添加阻止冒泡方法，使其不会向父元素冒泡，从而不执行父元素的冒泡阶段\ndom.addEventListener(&quot;事件名不加on&quot;,function()&#123;\n    e.stopPropagation(); //阻止冒泡\n&#125;，true) //设置为true的时候，捕获时执行\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>事件委托</p>\n<ul>\n<li>原理：利用了事件冒泡机制，只指定一个事件处理程序，管理某一类型的所有事件。</li>\n</ul>\n<blockquote>\n<p>场景：当父元素下面有很多的子DOM节点，都要注册同一个事件并且随时都会新加入一些DOM子节点，此时如果给每一个子dom节点都注册事件，不仅会造成性能不佳，还会导致新的子dom节点绑定不上事件，这时需要事件委托。</p>\n</blockquote>\n<pre><code class=\"js\">father.addEventListener(&quot;click&quot;,e=&gt;&#123;\n    e.target; // 指向触发事件监听的对象，谁触发了就是谁\n    e.currentTarget//指向添加监听事件的对象,也就是谁绑定的事件指的就是谁\n&#125;)\n\n//在事件中，this始终等于currentTarget\n</code></pre>\n</li>\n</ul>\n"},{"title":"javascriptDom基础-定时器","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 04-js WebAPI\n\n##BOM定时器\n\n```js\nsetTimeout(function(){},1000) //延时1s执行\nclearTimeout(定时器名称)  //清除定时器\n\nsetInterval(function(){},1000) //每隔1s执行一次\nclearInterval(定时器名称)     //清除定时器\n```\n\n## 事件\n\n```js\nonload //页面加载完成后执行，可以把scriot写在body前面\nonmouseover // 鼠标移入事件\nonmoseout // 鼠标移除事件\n\ndom.addEventListener(\"transitionend\",function(){}) //过度结束执行\ndom.addEventListener(\"animationend\",function(){}) //动画结束执行\n```\n\n\n\n## window下的属性方法\n\n```js\n//所有全局生命的变量和函数，都是window下属性和方法\nvar abc = 1\nconsole.log(windows.abc) //1\n\n//不使用var声明的话，都是隐式全局变量，不推荐\nabc = 1;  //这种变量没有提升\n\n\nlocation // windows下的属性\nlocation.href // 获取本次页面的地址，可以修改\n```\n\n\n\n##本地存储\n\n+ localStrorage:大小有5m或更多，是存储到本地的永久数据，除非用户主动删除，不会主动给服务器发送数据。\n\n+ sessionStorage：存储大小5m,本地存储，当前窗口关闭后数据销毁，\n\n+ cookie：存储大小只有4k，它有一个过期时间，过期后数据自动销毁，再次之前即使关闭浏览器他也会存在，同时coolie会在每一次通信过程中传送服务端，\n\n##tab切换\n\n```\n使用鼠标移入移出事件,移除所有li的class,让当前的元素添加上class，在将自定义属性获取到赋值给img\n```\n\n\n\n\n\n","source":"_posts/笔记/ocean/04-javascript_webapi/04-BOM定时器/04-笔记.md","raw":"---\ntitle: javascriptDom基础-定时器\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 04-js WebAPI\n\n##BOM定时器\n\n```js\nsetTimeout(function(){},1000) //延时1s执行\nclearTimeout(定时器名称)  //清除定时器\n\nsetInterval(function(){},1000) //每隔1s执行一次\nclearInterval(定时器名称)     //清除定时器\n```\n\n## 事件\n\n```js\nonload //页面加载完成后执行，可以把scriot写在body前面\nonmouseover // 鼠标移入事件\nonmoseout // 鼠标移除事件\n\ndom.addEventListener(\"transitionend\",function(){}) //过度结束执行\ndom.addEventListener(\"animationend\",function(){}) //动画结束执行\n```\n\n\n\n## window下的属性方法\n\n```js\n//所有全局生命的变量和函数，都是window下属性和方法\nvar abc = 1\nconsole.log(windows.abc) //1\n\n//不使用var声明的话，都是隐式全局变量，不推荐\nabc = 1;  //这种变量没有提升\n\n\nlocation // windows下的属性\nlocation.href // 获取本次页面的地址，可以修改\n```\n\n\n\n##本地存储\n\n+ localStrorage:大小有5m或更多，是存储到本地的永久数据，除非用户主动删除，不会主动给服务器发送数据。\n\n+ sessionStorage：存储大小5m,本地存储，当前窗口关闭后数据销毁，\n\n+ cookie：存储大小只有4k，它有一个过期时间，过期后数据自动销毁，再次之前即使关闭浏览器他也会存在，同时coolie会在每一次通信过程中传送服务端，\n\n##tab切换\n\n```\n使用鼠标移入移出事件,移除所有li的class,让当前的元素添加上class，在将自定义属性获取到赋值给img\n```\n\n\n\n\n\n","slug":"笔记/ocean/04-javascript_webapi/04-BOM定时器/04-笔记","published":1,"updated":"2023-03-01T06:55:13.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcn0025awaffa2x9ewz","content":"<h1 id=\"04-js-WebAPI\"><a href=\"#04-js-WebAPI\" class=\"headerlink\" title=\"04-js WebAPI\"></a>04-js WebAPI</h1><p>##BOM定时器</p>\n<pre><code class=\"js\">setTimeout(function()&#123;&#125;,1000) //延时1s执行\nclearTimeout(定时器名称)  //清除定时器\n\nsetInterval(function()&#123;&#125;,1000) //每隔1s执行一次\nclearInterval(定时器名称)     //清除定时器\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><pre><code class=\"js\">onload //页面加载完成后执行，可以把scriot写在body前面\nonmouseover // 鼠标移入事件\nonmoseout // 鼠标移除事件\n\ndom.addEventListener(&quot;transitionend&quot;,function()&#123;&#125;) //过度结束执行\ndom.addEventListener(&quot;animationend&quot;,function()&#123;&#125;) //动画结束执行\n</code></pre>\n<h2 id=\"window下的属性方法\"><a href=\"#window下的属性方法\" class=\"headerlink\" title=\"window下的属性方法\"></a>window下的属性方法</h2><pre><code class=\"js\">//所有全局生命的变量和函数，都是window下属性和方法\nvar abc = 1\nconsole.log(windows.abc) //1\n\n//不使用var声明的话，都是隐式全局变量，不推荐\nabc = 1;  //这种变量没有提升\n\n\nlocation // windows下的属性\nlocation.href // 获取本次页面的地址，可以修改\n</code></pre>\n<p>##本地存储</p>\n<ul>\n<li><p>localStrorage:大小有5m或更多，是存储到本地的永久数据，除非用户主动删除，不会主动给服务器发送数据。</p>\n</li>\n<li><p>sessionStorage：存储大小5m,本地存储，当前窗口关闭后数据销毁，</p>\n</li>\n<li><p>cookie：存储大小只有4k，它有一个过期时间，过期后数据自动销毁，再次之前即使关闭浏览器他也会存在，同时coolie会在每一次通信过程中传送服务端，</p>\n</li>\n</ul>\n<p>##tab切换</p>\n<pre><code>使用鼠标移入移出事件,移除所有li的class,让当前的元素添加上class，在将自定义属性获取到赋值给img\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"04-js-WebAPI\"><a href=\"#04-js-WebAPI\" class=\"headerlink\" title=\"04-js WebAPI\"></a>04-js WebAPI</h1><p>##BOM定时器</p>\n<pre><code class=\"js\">setTimeout(function()&#123;&#125;,1000) //延时1s执行\nclearTimeout(定时器名称)  //清除定时器\n\nsetInterval(function()&#123;&#125;,1000) //每隔1s执行一次\nclearInterval(定时器名称)     //清除定时器\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><pre><code class=\"js\">onload //页面加载完成后执行，可以把scriot写在body前面\nonmouseover // 鼠标移入事件\nonmoseout // 鼠标移除事件\n\ndom.addEventListener(&quot;transitionend&quot;,function()&#123;&#125;) //过度结束执行\ndom.addEventListener(&quot;animationend&quot;,function()&#123;&#125;) //动画结束执行\n</code></pre>\n<h2 id=\"window下的属性方法\"><a href=\"#window下的属性方法\" class=\"headerlink\" title=\"window下的属性方法\"></a>window下的属性方法</h2><pre><code class=\"js\">//所有全局生命的变量和函数，都是window下属性和方法\nvar abc = 1\nconsole.log(windows.abc) //1\n\n//不使用var声明的话，都是隐式全局变量，不推荐\nabc = 1;  //这种变量没有提升\n\n\nlocation // windows下的属性\nlocation.href // 获取本次页面的地址，可以修改\n</code></pre>\n<p>##本地存储</p>\n<ul>\n<li><p>localStrorage:大小有5m或更多，是存储到本地的永久数据，除非用户主动删除，不会主动给服务器发送数据。</p>\n</li>\n<li><p>sessionStorage：存储大小5m,本地存储，当前窗口关闭后数据销毁，</p>\n</li>\n<li><p>cookie：存储大小只有4k，它有一个过期时间，过期后数据自动销毁，再次之前即使关闭浏览器他也会存在，同时coolie会在每一次通信过程中传送服务端，</p>\n</li>\n</ul>\n<p>##tab切换</p>\n<pre><code>使用鼠标移入移出事件,移除所有li的class,让当前的元素添加上class，在将自定义属性获取到赋值给img\n</code></pre>\n"},{"title":"javascriptDom基础-dom方法","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 01-js Web API\n\n## 概念\n\n+ 介绍\n\n  > Web API是浏览器提供的一套操作浏览器和页面元素的API（DOM和BOM）,比如让浏览器弹出提示框，元素显示隐藏等功能。\n\n+ DOM\n\n  > DOM：document object model 文档对象模型，是W3C推荐的处理HTML的标准编程接口，可通过DOM接口改变页面的结构样式等。\n\n  1. DOM树，又称文档树模型，将文档映射为树形结构，通过节点对象对其处理，处理的结果可加入到当前页面\n\n     + 文档：一个页面就是一个文档，DOM中使用document表示\n\n     + 节点：网页中的所有内容，在文档树中都是节点（标签，属性，文本，注释等），使用node表示\n     + 标签节点：网页中所有的标签，通常称为元素节点，简称元素，使用element表示\n\n  - BOM：borwser object model  浏览器对象模型，描述了与浏览器进行交互的方法和接口，不同浏览器效果不同，window是BOM的，非js对象\n\n## DOM节点\n\n###查找\n\n```js\nvar id = document.getElementById(\"id\")\t//id获取\nvar tag = document.getElementByTagName(\"标签\"); //标签名获取\nvar name = document.getElmenentsByName(\"name\") //name获取\nvar class = document.getElementByClassName(\"类\");\t//class获取\nvar css = document.querySelector('css选择器') //选择器获取单个\nvar css = document.querySelectorAll('css选择器') //选择器获取多个\n```\n\n### 创建\n\n```js\nvar tagName = document.createElement('tagname') //创建一个dom节点\nconst text = document.createTextNode('text')//创建一个文本\nconst annotation = document.createComment('annotation') //创建一个注释\nconst fragment = document.createDocumentFragment() //创建一个片段\n```\n\n### 添加\n\n```js\ndom.appendChlid(tagname) //将tag插入到指定的父tag最后一个子Node\n```\n\n### 移除\n\n```js\ndom.removeChild(tagname) //要删除的tag \n```\n\n### 替换\n\n```js\ndom.replaceChild(NewTagname,tagname) //第一个是新标签，第二是要替换的tag\n```\n\n### 插入\n\n```js\ndom.insertBefore(NewTagname,tagname) //第一个参数为新标签，第二个为指定插入到那个标签的前一个位置\n```\n\n\n\n\n\n## 样式操作\n\n```js\nDOM.style //获取CSS样式\nDOM.style.width = \"100px\" //设置CSS样式值（行内样式）\n```\n\n## 类名操作\n\n```js\na.classList.add(\"类名\") //添加类名，重复类名只添加一次\na.classList.remove(\"类名\") //移除类名\na.classList.toggle(\"类名\") //切换类名，有就删，无则添加\n\na.className // 获取标签内class设置值，返回的是字符串\na.className = \"class\" //直接修改class,多个类名会被覆盖，设置类名尽量使用add()\n```\n\n## 事件\n\n```js\nDOM.onclick = function(){}//点击\nDOM.onfocus = function(){}//焦点\nDOM.onblur = function(){}//失去焦点\n```\n\n## 自定义属性操作\n\n```js\n<div data-xxx=\"1\"> //设置\ndiv.dataset //获取\n```\n\n","source":"_posts/笔记/ocean/04-javascript_webapi/01-获取DOM节点/01-note.md","raw":"---\ntitle: javascriptDom基础-dom方法\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 01-js Web API\n\n## 概念\n\n+ 介绍\n\n  > Web API是浏览器提供的一套操作浏览器和页面元素的API（DOM和BOM）,比如让浏览器弹出提示框，元素显示隐藏等功能。\n\n+ DOM\n\n  > DOM：document object model 文档对象模型，是W3C推荐的处理HTML的标准编程接口，可通过DOM接口改变页面的结构样式等。\n\n  1. DOM树，又称文档树模型，将文档映射为树形结构，通过节点对象对其处理，处理的结果可加入到当前页面\n\n     + 文档：一个页面就是一个文档，DOM中使用document表示\n\n     + 节点：网页中的所有内容，在文档树中都是节点（标签，属性，文本，注释等），使用node表示\n     + 标签节点：网页中所有的标签，通常称为元素节点，简称元素，使用element表示\n\n  - BOM：borwser object model  浏览器对象模型，描述了与浏览器进行交互的方法和接口，不同浏览器效果不同，window是BOM的，非js对象\n\n## DOM节点\n\n###查找\n\n```js\nvar id = document.getElementById(\"id\")\t//id获取\nvar tag = document.getElementByTagName(\"标签\"); //标签名获取\nvar name = document.getElmenentsByName(\"name\") //name获取\nvar class = document.getElementByClassName(\"类\");\t//class获取\nvar css = document.querySelector('css选择器') //选择器获取单个\nvar css = document.querySelectorAll('css选择器') //选择器获取多个\n```\n\n### 创建\n\n```js\nvar tagName = document.createElement('tagname') //创建一个dom节点\nconst text = document.createTextNode('text')//创建一个文本\nconst annotation = document.createComment('annotation') //创建一个注释\nconst fragment = document.createDocumentFragment() //创建一个片段\n```\n\n### 添加\n\n```js\ndom.appendChlid(tagname) //将tag插入到指定的父tag最后一个子Node\n```\n\n### 移除\n\n```js\ndom.removeChild(tagname) //要删除的tag \n```\n\n### 替换\n\n```js\ndom.replaceChild(NewTagname,tagname) //第一个是新标签，第二是要替换的tag\n```\n\n### 插入\n\n```js\ndom.insertBefore(NewTagname,tagname) //第一个参数为新标签，第二个为指定插入到那个标签的前一个位置\n```\n\n\n\n\n\n## 样式操作\n\n```js\nDOM.style //获取CSS样式\nDOM.style.width = \"100px\" //设置CSS样式值（行内样式）\n```\n\n## 类名操作\n\n```js\na.classList.add(\"类名\") //添加类名，重复类名只添加一次\na.classList.remove(\"类名\") //移除类名\na.classList.toggle(\"类名\") //切换类名，有就删，无则添加\n\na.className // 获取标签内class设置值，返回的是字符串\na.className = \"class\" //直接修改class,多个类名会被覆盖，设置类名尽量使用add()\n```\n\n## 事件\n\n```js\nDOM.onclick = function(){}//点击\nDOM.onfocus = function(){}//焦点\nDOM.onblur = function(){}//失去焦点\n```\n\n## 自定义属性操作\n\n```js\n<div data-xxx=\"1\"> //设置\ndiv.dataset //获取\n```\n\n","slug":"笔记/ocean/04-javascript_webapi/01-获取DOM节点/01-note","published":1,"updated":"2023-03-01T06:53:54.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qco0029awaf3cgu7o10","content":"<h1 id=\"01-js-Web-API\"><a href=\"#01-js-Web-API\" class=\"headerlink\" title=\"01-js Web API\"></a>01-js Web API</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li><p>介绍</p>\n<blockquote>\n<p>Web API是浏览器提供的一套操作浏览器和页面元素的API（DOM和BOM）,比如让浏览器弹出提示框，元素显示隐藏等功能。</p>\n</blockquote>\n</li>\n<li><p>DOM</p>\n<blockquote>\n<p>DOM：document object model 文档对象模型，是W3C推荐的处理HTML的标准编程接口，可通过DOM接口改变页面的结构样式等。</p>\n</blockquote>\n<ol>\n<li><p>DOM树，又称文档树模型，将文档映射为树形结构，通过节点对象对其处理，处理的结果可加入到当前页面</p>\n<ul>\n<li><p>文档：一个页面就是一个文档，DOM中使用document表示</p>\n</li>\n<li><p>节点：网页中的所有内容，在文档树中都是节点（标签，属性，文本，注释等），使用node表示</p>\n</li>\n<li><p>标签节点：网页中所有的标签，通常称为元素节点，简称元素，使用element表示</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>BOM：borwser object model  浏览器对象模型，描述了与浏览器进行交互的方法和接口，不同浏览器效果不同，window是BOM的，非js对象</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h2><p>###查找</p>\n<pre><code class=\"js\">var id = document.getElementById(&quot;id&quot;)    //id获取\nvar tag = document.getElementByTagName(&quot;标签&quot;); //标签名获取\nvar name = document.getElmenentsByName(&quot;name&quot;) //name获取\nvar class = document.getElementByClassName(&quot;类&quot;);    //class获取\nvar css = document.querySelector(&#39;css选择器&#39;) //选择器获取单个\nvar css = document.querySelectorAll(&#39;css选择器&#39;) //选择器获取多个\n</code></pre>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><pre><code class=\"js\">var tagName = document.createElement(&#39;tagname&#39;) //创建一个dom节点\nconst text = document.createTextNode(&#39;text&#39;)//创建一个文本\nconst annotation = document.createComment(&#39;annotation&#39;) //创建一个注释\nconst fragment = document.createDocumentFragment() //创建一个片段\n</code></pre>\n<h3 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h3><pre><code class=\"js\">dom.appendChlid(tagname) //将tag插入到指定的父tag最后一个子Node\n</code></pre>\n<h3 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h3><pre><code class=\"js\">dom.removeChild(tagname) //要删除的tag \n</code></pre>\n<h3 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h3><pre><code class=\"js\">dom.replaceChild(NewTagname,tagname) //第一个是新标签，第二是要替换的tag\n</code></pre>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><pre><code class=\"js\">dom.insertBefore(NewTagname,tagname) //第一个参数为新标签，第二个为指定插入到那个标签的前一个位置\n</code></pre>\n<h2 id=\"样式操作\"><a href=\"#样式操作\" class=\"headerlink\" title=\"样式操作\"></a>样式操作</h2><pre><code class=\"js\">DOM.style //获取CSS样式\nDOM.style.width = &quot;100px&quot; //设置CSS样式值（行内样式）\n</code></pre>\n<h2 id=\"类名操作\"><a href=\"#类名操作\" class=\"headerlink\" title=\"类名操作\"></a>类名操作</h2><pre><code class=\"js\">a.classList.add(&quot;类名&quot;) //添加类名，重复类名只添加一次\na.classList.remove(&quot;类名&quot;) //移除类名\na.classList.toggle(&quot;类名&quot;) //切换类名，有就删，无则添加\n\na.className // 获取标签内class设置值，返回的是字符串\na.className = &quot;class&quot; //直接修改class,多个类名会被覆盖，设置类名尽量使用add()\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><pre><code class=\"js\">DOM.onclick = function()&#123;&#125;//点击\nDOM.onfocus = function()&#123;&#125;//焦点\nDOM.onblur = function()&#123;&#125;//失去焦点\n</code></pre>\n<h2 id=\"自定义属性操作\"><a href=\"#自定义属性操作\" class=\"headerlink\" title=\"自定义属性操作\"></a>自定义属性操作</h2><pre><code class=\"js\">&lt;div data-xxx=&quot;1&quot;&gt; //设置\ndiv.dataset //获取\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-js-Web-API\"><a href=\"#01-js-Web-API\" class=\"headerlink\" title=\"01-js Web API\"></a>01-js Web API</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li><p>介绍</p>\n<blockquote>\n<p>Web API是浏览器提供的一套操作浏览器和页面元素的API（DOM和BOM）,比如让浏览器弹出提示框，元素显示隐藏等功能。</p>\n</blockquote>\n</li>\n<li><p>DOM</p>\n<blockquote>\n<p>DOM：document object model 文档对象模型，是W3C推荐的处理HTML的标准编程接口，可通过DOM接口改变页面的结构样式等。</p>\n</blockquote>\n<ol>\n<li><p>DOM树，又称文档树模型，将文档映射为树形结构，通过节点对象对其处理，处理的结果可加入到当前页面</p>\n<ul>\n<li><p>文档：一个页面就是一个文档，DOM中使用document表示</p>\n</li>\n<li><p>节点：网页中的所有内容，在文档树中都是节点（标签，属性，文本，注释等），使用node表示</p>\n</li>\n<li><p>标签节点：网页中所有的标签，通常称为元素节点，简称元素，使用element表示</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>BOM：borwser object model  浏览器对象模型，描述了与浏览器进行交互的方法和接口，不同浏览器效果不同，window是BOM的，非js对象</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h2><p>###查找</p>\n<pre><code class=\"js\">var id = document.getElementById(&quot;id&quot;)    //id获取\nvar tag = document.getElementByTagName(&quot;标签&quot;); //标签名获取\nvar name = document.getElmenentsByName(&quot;name&quot;) //name获取\nvar class = document.getElementByClassName(&quot;类&quot;);    //class获取\nvar css = document.querySelector(&#39;css选择器&#39;) //选择器获取单个\nvar css = document.querySelectorAll(&#39;css选择器&#39;) //选择器获取多个\n</code></pre>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><pre><code class=\"js\">var tagName = document.createElement(&#39;tagname&#39;) //创建一个dom节点\nconst text = document.createTextNode(&#39;text&#39;)//创建一个文本\nconst annotation = document.createComment(&#39;annotation&#39;) //创建一个注释\nconst fragment = document.createDocumentFragment() //创建一个片段\n</code></pre>\n<h3 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h3><pre><code class=\"js\">dom.appendChlid(tagname) //将tag插入到指定的父tag最后一个子Node\n</code></pre>\n<h3 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h3><pre><code class=\"js\">dom.removeChild(tagname) //要删除的tag \n</code></pre>\n<h3 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h3><pre><code class=\"js\">dom.replaceChild(NewTagname,tagname) //第一个是新标签，第二是要替换的tag\n</code></pre>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><pre><code class=\"js\">dom.insertBefore(NewTagname,tagname) //第一个参数为新标签，第二个为指定插入到那个标签的前一个位置\n</code></pre>\n<h2 id=\"样式操作\"><a href=\"#样式操作\" class=\"headerlink\" title=\"样式操作\"></a>样式操作</h2><pre><code class=\"js\">DOM.style //获取CSS样式\nDOM.style.width = &quot;100px&quot; //设置CSS样式值（行内样式）\n</code></pre>\n<h2 id=\"类名操作\"><a href=\"#类名操作\" class=\"headerlink\" title=\"类名操作\"></a>类名操作</h2><pre><code class=\"js\">a.classList.add(&quot;类名&quot;) //添加类名，重复类名只添加一次\na.classList.remove(&quot;类名&quot;) //移除类名\na.classList.toggle(&quot;类名&quot;) //切换类名，有就删，无则添加\n\na.className // 获取标签内class设置值，返回的是字符串\na.className = &quot;class&quot; //直接修改class,多个类名会被覆盖，设置类名尽量使用add()\n</code></pre>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><pre><code class=\"js\">DOM.onclick = function()&#123;&#125;//点击\nDOM.onfocus = function()&#123;&#125;//焦点\nDOM.onblur = function()&#123;&#125;//失去焦点\n</code></pre>\n<h2 id=\"自定义属性操作\"><a href=\"#自定义属性操作\" class=\"headerlink\" title=\"自定义属性操作\"></a>自定义属性操作</h2><pre><code class=\"js\">&lt;div data-xxx=&quot;1&quot;&gt; //设置\ndiv.dataset //获取\n</code></pre>\n"},{"title":"javascript高级-原型","date":"2017-02-06T04:01:23.000Z","_content":"\n\n\n# 原型对象\n\n## 面向对象\n\n### 什么是面向对象？\n\n> 是一种编程思想，采用抽象化构造函数和实例化对象就是面向对象，就是用对象的方式描述一件事物\n\n## 什么是原型？\n\n> js中是通过原型实现继承的，js所有的东西都可以看做是对象，原型也是一个对象，可以通过原型实现对象的属性继承，其主要作用就是为了实现继承和扩展对象。\n\n ## 什么是原型对象?\n\n> 每个函数都有一个prototype属性，这个属性指向函数的原型对象。原型对象中有一个constructor属性，它指向函数本身。\n\n```js\n比如有一个函数\nfunction a(){ }\t//根据规则为函数a创建一个prototype\na.prototype //a函数中的prototype的指向就是它的原型对象\na.prototype.constructor === a //而原型对象中自动获得一个constructor属性，constructor的指向就是a函数本身\na.prototype.toString //toString是原型对象中没有的，它是从object继承而来的\n```\n\n## 为什么要使用prototype？\n\n> 使用 prototype 原型添加的方法，解决了数据共享，内存浪费，代码重复执行，问题，节省了内存空间.\n\n\n\n## 什么是__proto__？\n\n>  这是 js 中每个对象原型都有的属性，它指向的是prototype,所以它也会指向该对象的原型对象\n\n```js\na.prototype.__proto__ ===  Object.prototype //true\na的原型对象是由构造函数Object生成的，他们之间通过__proto__存在关系.\n\n原型对象是构造函数Object生成的，而object也是一个函数，所以 Object.prototype 指向Object的原型对象.\n```\n\n## 什么是原型链?\n\n```js\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n```\n\n\n\n```js\n--扩展\n 普通数据类型是直接存在内存的栈中，而复杂数据类型只会把内存地址存在栈中，真正的数据会存在栈中的那个地址指向的堆中。    \n```\n\n##构造函数\n\n+ 构造函数实例化步骤\n  1. 在内存堆中新建一个空对象\n  2. 将新对象的__proto__指向构造函数的prototype\n  3. 将构造函数的this指向新对象，执行构造函数中语句，对新对象this初始化\n  4. 有返回值且为引用值，则返回引用值，为原始数据则返回新对象，未设置返回值则返回新对象\n\n```js\n//首字母大写\nfunction Star(name,age){\n    //this代表未来某一次实例化对象\n    this.name = name \n    this.age = age\n    this.sing = function(){\n        console.log(\"共同属性\")\n    }\n}\n\n//实例化：使用构造函数创建出一个对象\nvar w1= new Star('小白',18);\nvar w2= new Star('小黑',19);\n\n//功能：方法调用，本质是函数，也是个复杂数据类型\n//共同的属性\n\np1.sing == s2.sing    //false\n//推断：在内存中 p1.sing 和 p2.sing 在堆上开启了两个不同的内存\n```\n\n##prototype\n\nprototype属性，这个属性指向函数的原型对象。 \n\n每一个构造函数都有一个prototype\n\n实例化对象都有prototype,比如数组,自定义实例化的对象\n\n```js\n//解决，内存浪费问题\nStar.prototype.sing = function(){\n    console.log(\"我会唱歌\")\n}\n\np1.sing == p2.sing // true,它两存到了同一块空间\n```\n\n##_\\_proto\\_\\_\n\n实例化对象上 __proto__属性名:值是一个对象\n\n```js\n//p1.__proto__ 和 Star.prototyle，一样\np1.__proto__ == Star.prototype //true\n\n\n\n//以下两种方法都可获取sing().\np1.sing()\t//原型链的查找规则。\np1.__proto__.sing() \n```\n\n## this指向\n\n```js\n//this谁调用就☞谁\n\n//1.\nfunction fn(){\n    console.log(this)\t//这里是windows\n}\nfn();\n\n\n//2.\nfunction Star(){\n \tthis.name = \"hh\"\n    this.age = 13\n    console.log(this) //指的是未来实例化对象\n}\n\n```\n\n##查看类型\n\n```js\n参数1 instanceof  参数2 //参数1的类型是否为参数2,返回值是布尔值\n//针对构造函数，看实例化对象的类型是否为instanceof后面的参数\n\n```\n\n##做一个基础的封装\n\n```js\n//1.设置一个函数\nfunction Myfun(){\n    //--获取DOM元素，放入this\n}\n\n//2.方法放在原型对象里\nMyfun.propotype.rClick = function(){\n    \n}\n```\n\n","source":"_posts/笔记/ocean/05-javascript高级总结/01-原型/01-note.md","raw":"---\ntitle: javascript高级-原型\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n\n# 原型对象\n\n## 面向对象\n\n### 什么是面向对象？\n\n> 是一种编程思想，采用抽象化构造函数和实例化对象就是面向对象，就是用对象的方式描述一件事物\n\n## 什么是原型？\n\n> js中是通过原型实现继承的，js所有的东西都可以看做是对象，原型也是一个对象，可以通过原型实现对象的属性继承，其主要作用就是为了实现继承和扩展对象。\n\n ## 什么是原型对象?\n\n> 每个函数都有一个prototype属性，这个属性指向函数的原型对象。原型对象中有一个constructor属性，它指向函数本身。\n\n```js\n比如有一个函数\nfunction a(){ }\t//根据规则为函数a创建一个prototype\na.prototype //a函数中的prototype的指向就是它的原型对象\na.prototype.constructor === a //而原型对象中自动获得一个constructor属性，constructor的指向就是a函数本身\na.prototype.toString //toString是原型对象中没有的，它是从object继承而来的\n```\n\n## 为什么要使用prototype？\n\n> 使用 prototype 原型添加的方法，解决了数据共享，内存浪费，代码重复执行，问题，节省了内存空间.\n\n\n\n## 什么是__proto__？\n\n>  这是 js 中每个对象原型都有的属性，它指向的是prototype,所以它也会指向该对象的原型对象\n\n```js\na.prototype.__proto__ ===  Object.prototype //true\na的原型对象是由构造函数Object生成的，他们之间通过__proto__存在关系.\n\n原型对象是构造函数Object生成的，而object也是一个函数，所以 Object.prototype 指向Object的原型对象.\n```\n\n## 什么是原型链?\n\n```js\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n```\n\n\n\n```js\n--扩展\n 普通数据类型是直接存在内存的栈中，而复杂数据类型只会把内存地址存在栈中，真正的数据会存在栈中的那个地址指向的堆中。    \n```\n\n##构造函数\n\n+ 构造函数实例化步骤\n  1. 在内存堆中新建一个空对象\n  2. 将新对象的__proto__指向构造函数的prototype\n  3. 将构造函数的this指向新对象，执行构造函数中语句，对新对象this初始化\n  4. 有返回值且为引用值，则返回引用值，为原始数据则返回新对象，未设置返回值则返回新对象\n\n```js\n//首字母大写\nfunction Star(name,age){\n    //this代表未来某一次实例化对象\n    this.name = name \n    this.age = age\n    this.sing = function(){\n        console.log(\"共同属性\")\n    }\n}\n\n//实例化：使用构造函数创建出一个对象\nvar w1= new Star('小白',18);\nvar w2= new Star('小黑',19);\n\n//功能：方法调用，本质是函数，也是个复杂数据类型\n//共同的属性\n\np1.sing == s2.sing    //false\n//推断：在内存中 p1.sing 和 p2.sing 在堆上开启了两个不同的内存\n```\n\n##prototype\n\nprototype属性，这个属性指向函数的原型对象。 \n\n每一个构造函数都有一个prototype\n\n实例化对象都有prototype,比如数组,自定义实例化的对象\n\n```js\n//解决，内存浪费问题\nStar.prototype.sing = function(){\n    console.log(\"我会唱歌\")\n}\n\np1.sing == p2.sing // true,它两存到了同一块空间\n```\n\n##_\\_proto\\_\\_\n\n实例化对象上 __proto__属性名:值是一个对象\n\n```js\n//p1.__proto__ 和 Star.prototyle，一样\np1.__proto__ == Star.prototype //true\n\n\n\n//以下两种方法都可获取sing().\np1.sing()\t//原型链的查找规则。\np1.__proto__.sing() \n```\n\n## this指向\n\n```js\n//this谁调用就☞谁\n\n//1.\nfunction fn(){\n    console.log(this)\t//这里是windows\n}\nfn();\n\n\n//2.\nfunction Star(){\n \tthis.name = \"hh\"\n    this.age = 13\n    console.log(this) //指的是未来实例化对象\n}\n\n```\n\n##查看类型\n\n```js\n参数1 instanceof  参数2 //参数1的类型是否为参数2,返回值是布尔值\n//针对构造函数，看实例化对象的类型是否为instanceof后面的参数\n\n```\n\n##做一个基础的封装\n\n```js\n//1.设置一个函数\nfunction Myfun(){\n    //--获取DOM元素，放入this\n}\n\n//2.方法放在原型对象里\nMyfun.propotype.rClick = function(){\n    \n}\n```\n\n","slug":"笔记/ocean/05-javascript高级总结/01-原型/01-note","published":1,"updated":"2023-03-01T06:56:36.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcp002cawaf6i7h7c97","content":"<h1 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h1><h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"什么是面向对象？\"><a href=\"#什么是面向对象？\" class=\"headerlink\" title=\"什么是面向对象？\"></a>什么是面向对象？</h3><blockquote>\n<p>是一种编程思想，采用抽象化构造函数和实例化对象就是面向对象，就是用对象的方式描述一件事物</p>\n</blockquote>\n<h2 id=\"什么是原型？\"><a href=\"#什么是原型？\" class=\"headerlink\" title=\"什么是原型？\"></a>什么是原型？</h2><blockquote>\n<p>js中是通过原型实现继承的，js所有的东西都可以看做是对象，原型也是一个对象，可以通过原型实现对象的属性继承，其主要作用就是为了实现继承和扩展对象。</p>\n</blockquote>\n<h2 id=\"什么是原型对象\"><a href=\"#什么是原型对象\" class=\"headerlink\" title=\"什么是原型对象?\"></a>什么是原型对象?</h2><blockquote>\n<p>每个函数都有一个prototype属性，这个属性指向函数的原型对象。原型对象中有一个constructor属性，它指向函数本身。</p>\n</blockquote>\n<pre><code class=\"js\">比如有一个函数\nfunction a()&#123; &#125;    //根据规则为函数a创建一个prototype\na.prototype //a函数中的prototype的指向就是它的原型对象\na.prototype.constructor === a //而原型对象中自动获得一个constructor属性，constructor的指向就是a函数本身\na.prototype.toString //toString是原型对象中没有的，它是从object继承而来的\n</code></pre>\n<h2 id=\"为什么要使用prototype？\"><a href=\"#为什么要使用prototype？\" class=\"headerlink\" title=\"为什么要使用prototype？\"></a>为什么要使用prototype？</h2><blockquote>\n<p>使用 prototype 原型添加的方法，解决了数据共享，内存浪费，代码重复执行，问题，节省了内存空间.</p>\n</blockquote>\n<h2 id=\"什么是-proto-？\"><a href=\"#什么是-proto-？\" class=\"headerlink\" title=\"什么是__proto__？\"></a>什么是__proto__？</h2><blockquote>\n<p> 这是 js 中每个对象原型都有的属性，它指向的是prototype,所以它也会指向该对象的原型对象</p>\n</blockquote>\n<pre><code class=\"js\">a.prototype.__proto__ ===  Object.prototype //true\na的原型对象是由构造函数Object生成的，他们之间通过__proto__存在关系.\n\n原型对象是构造函数Object生成的，而object也是一个函数，所以 Object.prototype 指向Object的原型对象.\n</code></pre>\n<h2 id=\"什么是原型链\"><a href=\"#什么是原型链\" class=\"headerlink\" title=\"什么是原型链?\"></a>什么是原型链?</h2><pre><code class=\"js\">当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n</code></pre>\n<pre><code class=\"js\">--扩展\n 普通数据类型是直接存在内存的栈中，而复杂数据类型只会把内存地址存在栈中，真正的数据会存在栈中的那个地址指向的堆中。    \n</code></pre>\n<p>##构造函数</p>\n<ul>\n<li>构造函数实例化步骤<ol>\n<li>在内存堆中新建一个空对象</li>\n<li>将新对象的__proto__指向构造函数的prototype</li>\n<li>将构造函数的this指向新对象，执行构造函数中语句，对新对象this初始化</li>\n<li>有返回值且为引用值，则返回引用值，为原始数据则返回新对象，未设置返回值则返回新对象</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">//首字母大写\nfunction Star(name,age)&#123;\n    //this代表未来某一次实例化对象\n    this.name = name \n    this.age = age\n    this.sing = function()&#123;\n        console.log(&quot;共同属性&quot;)\n    &#125;\n&#125;\n\n//实例化：使用构造函数创建出一个对象\nvar w1= new Star(&#39;小白&#39;,18);\nvar w2= new Star(&#39;小黑&#39;,19);\n\n//功能：方法调用，本质是函数，也是个复杂数据类型\n//共同的属性\n\np1.sing == s2.sing    //false\n//推断：在内存中 p1.sing 和 p2.sing 在堆上开启了两个不同的内存\n</code></pre>\n<p>##prototype</p>\n<p>prototype属性，这个属性指向函数的原型对象。 </p>\n<p>每一个构造函数都有一个prototype</p>\n<p>实例化对象都有prototype,比如数组,自定义实例化的对象</p>\n<pre><code class=\"js\">//解决，内存浪费问题\nStar.prototype.sing = function()&#123;\n    console.log(&quot;我会唱歌&quot;)\n&#125;\n\np1.sing == p2.sing // true,它两存到了同一块空间\n</code></pre>\n<p>##__proto__</p>\n<p>实例化对象上 __proto__属性名:值是一个对象</p>\n<pre><code class=\"js\">//p1.__proto__ 和 Star.prototyle，一样\np1.__proto__ == Star.prototype //true\n\n\n\n//以下两种方法都可获取sing().\np1.sing()    //原型链的查找规则。\np1.__proto__.sing() \n</code></pre>\n<h2 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h2><pre><code class=\"js\">//this谁调用就☞谁\n\n//1.\nfunction fn()&#123;\n    console.log(this)    //这里是windows\n&#125;\nfn();\n\n\n//2.\nfunction Star()&#123;\n     this.name = &quot;hh&quot;\n    this.age = 13\n    console.log(this) //指的是未来实例化对象\n&#125;\n</code></pre>\n<p>##查看类型</p>\n<pre><code class=\"js\">参数1 instanceof  参数2 //参数1的类型是否为参数2,返回值是布尔值\n//针对构造函数，看实例化对象的类型是否为instanceof后面的参数\n</code></pre>\n<p>##做一个基础的封装</p>\n<pre><code class=\"js\">//1.设置一个函数\nfunction Myfun()&#123;\n    //--获取DOM元素，放入this\n&#125;\n\n//2.方法放在原型对象里\nMyfun.propotype.rClick = function()&#123;\n    \n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h1><h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"什么是面向对象？\"><a href=\"#什么是面向对象？\" class=\"headerlink\" title=\"什么是面向对象？\"></a>什么是面向对象？</h3><blockquote>\n<p>是一种编程思想，采用抽象化构造函数和实例化对象就是面向对象，就是用对象的方式描述一件事物</p>\n</blockquote>\n<h2 id=\"什么是原型？\"><a href=\"#什么是原型？\" class=\"headerlink\" title=\"什么是原型？\"></a>什么是原型？</h2><blockquote>\n<p>js中是通过原型实现继承的，js所有的东西都可以看做是对象，原型也是一个对象，可以通过原型实现对象的属性继承，其主要作用就是为了实现继承和扩展对象。</p>\n</blockquote>\n<h2 id=\"什么是原型对象\"><a href=\"#什么是原型对象\" class=\"headerlink\" title=\"什么是原型对象?\"></a>什么是原型对象?</h2><blockquote>\n<p>每个函数都有一个prototype属性，这个属性指向函数的原型对象。原型对象中有一个constructor属性，它指向函数本身。</p>\n</blockquote>\n<pre><code class=\"js\">比如有一个函数\nfunction a()&#123; &#125;    //根据规则为函数a创建一个prototype\na.prototype //a函数中的prototype的指向就是它的原型对象\na.prototype.constructor === a //而原型对象中自动获得一个constructor属性，constructor的指向就是a函数本身\na.prototype.toString //toString是原型对象中没有的，它是从object继承而来的\n</code></pre>\n<h2 id=\"为什么要使用prototype？\"><a href=\"#为什么要使用prototype？\" class=\"headerlink\" title=\"为什么要使用prototype？\"></a>为什么要使用prototype？</h2><blockquote>\n<p>使用 prototype 原型添加的方法，解决了数据共享，内存浪费，代码重复执行，问题，节省了内存空间.</p>\n</blockquote>\n<h2 id=\"什么是-proto-？\"><a href=\"#什么是-proto-？\" class=\"headerlink\" title=\"什么是__proto__？\"></a>什么是__proto__？</h2><blockquote>\n<p> 这是 js 中每个对象原型都有的属性，它指向的是prototype,所以它也会指向该对象的原型对象</p>\n</blockquote>\n<pre><code class=\"js\">a.prototype.__proto__ ===  Object.prototype //true\na的原型对象是由构造函数Object生成的，他们之间通过__proto__存在关系.\n\n原型对象是构造函数Object生成的，而object也是一个函数，所以 Object.prototype 指向Object的原型对象.\n</code></pre>\n<h2 id=\"什么是原型链\"><a href=\"#什么是原型链\" class=\"headerlink\" title=\"什么是原型链?\"></a>什么是原型链?</h2><pre><code class=\"js\">当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n</code></pre>\n<pre><code class=\"js\">--扩展\n 普通数据类型是直接存在内存的栈中，而复杂数据类型只会把内存地址存在栈中，真正的数据会存在栈中的那个地址指向的堆中。    \n</code></pre>\n<p>##构造函数</p>\n<ul>\n<li>构造函数实例化步骤<ol>\n<li>在内存堆中新建一个空对象</li>\n<li>将新对象的__proto__指向构造函数的prototype</li>\n<li>将构造函数的this指向新对象，执行构造函数中语句，对新对象this初始化</li>\n<li>有返回值且为引用值，则返回引用值，为原始数据则返回新对象，未设置返回值则返回新对象</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">//首字母大写\nfunction Star(name,age)&#123;\n    //this代表未来某一次实例化对象\n    this.name = name \n    this.age = age\n    this.sing = function()&#123;\n        console.log(&quot;共同属性&quot;)\n    &#125;\n&#125;\n\n//实例化：使用构造函数创建出一个对象\nvar w1= new Star(&#39;小白&#39;,18);\nvar w2= new Star(&#39;小黑&#39;,19);\n\n//功能：方法调用，本质是函数，也是个复杂数据类型\n//共同的属性\n\np1.sing == s2.sing    //false\n//推断：在内存中 p1.sing 和 p2.sing 在堆上开启了两个不同的内存\n</code></pre>\n<p>##prototype</p>\n<p>prototype属性，这个属性指向函数的原型对象。 </p>\n<p>每一个构造函数都有一个prototype</p>\n<p>实例化对象都有prototype,比如数组,自定义实例化的对象</p>\n<pre><code class=\"js\">//解决，内存浪费问题\nStar.prototype.sing = function()&#123;\n    console.log(&quot;我会唱歌&quot;)\n&#125;\n\np1.sing == p2.sing // true,它两存到了同一块空间\n</code></pre>\n<p>##__proto__</p>\n<p>实例化对象上 __proto__属性名:值是一个对象</p>\n<pre><code class=\"js\">//p1.__proto__ 和 Star.prototyle，一样\np1.__proto__ == Star.prototype //true\n\n\n\n//以下两种方法都可获取sing().\np1.sing()    //原型链的查找规则。\np1.__proto__.sing() \n</code></pre>\n<h2 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h2><pre><code class=\"js\">//this谁调用就☞谁\n\n//1.\nfunction fn()&#123;\n    console.log(this)    //这里是windows\n&#125;\nfn();\n\n\n//2.\nfunction Star()&#123;\n     this.name = &quot;hh&quot;\n    this.age = 13\n    console.log(this) //指的是未来实例化对象\n&#125;\n</code></pre>\n<p>##查看类型</p>\n<pre><code class=\"js\">参数1 instanceof  参数2 //参数1的类型是否为参数2,返回值是布尔值\n//针对构造函数，看实例化对象的类型是否为instanceof后面的参数\n</code></pre>\n<p>##做一个基础的封装</p>\n<pre><code class=\"js\">//1.设置一个函数\nfunction Myfun()&#123;\n    //--获取DOM元素，放入this\n&#125;\n\n//2.方法放在原型对象里\nMyfun.propotype.rClick = function()&#123;\n    \n&#125;\n</code></pre>\n"},{"title":"javascriptDom基础-鼠标事件和event","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 05-js Web API\n\n##鼠标事件\n\n```javascript\nonmousedown //当鼠标点击左键的时候触发\nonmouseup   // 当鼠标的按键松开的时候执行\n\nmouseover\t//鼠标移入元素触发\nonmouseleave //鼠标移除元素触发\n\n\nonmousemove \t// 鼠标移在元素中移动时触发\n\n\n // 以下两个事件都是，鼠标在某个元素身上移动的时候出触发\nmouseover // 会冒泡到子元素\nmouseenter \t// 不会冒泡到子元素\n```\n\n## event\n\n+ 概念\n\n  > event代表事件的状态和信息，比如触发event对象的元素，鼠标的位置及状态，按下的键等等，它的某些属性只对特定的事件有意义\n\n  + event 是标准浏览器传进去的事件参数，事件参数放置在window.event对象中，兼容ie要加上e=e||window.event\n\n```js\nDOM.onmousemove = function(e){//e不止针对移动事件\n    e.clientX\t//以浏览器可视区域的左上角为原点\n    e.clientY\t//\n    e.pageX // 以body左上角为原点\n    e.pageY // \n}\n```\n\n\n\n##盒子位置\n\n```js\nDOM.offsetParent //找到一个有定位的父级，如果上级没有定位，会一直往上找，如果都没有最后找到body\nDOM.offsetLeft //得到的是父级的水平距离\nDOM.offsetTop // 得到的是父级的垂直距离\n\n\nDOM.offsetWidth // 获取宽度，返回num类型padding+content+border\nDOM.offsetHeight // 获取高度，返回num类型\n//style.width 1.只能获取到行内样式 2.获取的只是内容宽度 3.获取到带px\n//offsetWidth不可以设置,只能读取\n\n\nDOM.clientwidth //获取宽度，不带边框\nDOM.clientHeight // 获取高度\n```\n\n##事件解绑\n\n```js\nDOM.on事件类型 = null; //事件解绑 \nDOM.romoveEventListener('事件',事件函数名) //注销事件\n```\n\n\n\n","source":"_posts/笔记/ocean/04-javascript_webapi/05-鼠标事件和event/05-note.md","raw":"---\ntitle: javascriptDom基础-鼠标事件和event\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 05-js Web API\n\n##鼠标事件\n\n```javascript\nonmousedown //当鼠标点击左键的时候触发\nonmouseup   // 当鼠标的按键松开的时候执行\n\nmouseover\t//鼠标移入元素触发\nonmouseleave //鼠标移除元素触发\n\n\nonmousemove \t// 鼠标移在元素中移动时触发\n\n\n // 以下两个事件都是，鼠标在某个元素身上移动的时候出触发\nmouseover // 会冒泡到子元素\nmouseenter \t// 不会冒泡到子元素\n```\n\n## event\n\n+ 概念\n\n  > event代表事件的状态和信息，比如触发event对象的元素，鼠标的位置及状态，按下的键等等，它的某些属性只对特定的事件有意义\n\n  + event 是标准浏览器传进去的事件参数，事件参数放置在window.event对象中，兼容ie要加上e=e||window.event\n\n```js\nDOM.onmousemove = function(e){//e不止针对移动事件\n    e.clientX\t//以浏览器可视区域的左上角为原点\n    e.clientY\t//\n    e.pageX // 以body左上角为原点\n    e.pageY // \n}\n```\n\n\n\n##盒子位置\n\n```js\nDOM.offsetParent //找到一个有定位的父级，如果上级没有定位，会一直往上找，如果都没有最后找到body\nDOM.offsetLeft //得到的是父级的水平距离\nDOM.offsetTop // 得到的是父级的垂直距离\n\n\nDOM.offsetWidth // 获取宽度，返回num类型padding+content+border\nDOM.offsetHeight // 获取高度，返回num类型\n//style.width 1.只能获取到行内样式 2.获取的只是内容宽度 3.获取到带px\n//offsetWidth不可以设置,只能读取\n\n\nDOM.clientwidth //获取宽度，不带边框\nDOM.clientHeight // 获取高度\n```\n\n##事件解绑\n\n```js\nDOM.on事件类型 = null; //事件解绑 \nDOM.romoveEventListener('事件',事件函数名) //注销事件\n```\n\n\n\n","slug":"笔记/ocean/04-javascript_webapi/05-鼠标事件和event/05-note","published":1,"updated":"2023-03-01T06:55:49.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcq002gawafccrod8ht","content":"<h1 id=\"05-js-Web-API\"><a href=\"#05-js-Web-API\" class=\"headerlink\" title=\"05-js Web API\"></a>05-js Web API</h1><p>##鼠标事件</p>\n<pre><code class=\"javascript\">onmousedown //当鼠标点击左键的时候触发\nonmouseup   // 当鼠标的按键松开的时候执行\n\nmouseover    //鼠标移入元素触发\nonmouseleave //鼠标移除元素触发\n\n\nonmousemove     // 鼠标移在元素中移动时触发\n\n\n // 以下两个事件都是，鼠标在某个元素身上移动的时候出触发\nmouseover // 会冒泡到子元素\nmouseenter     // 不会冒泡到子元素\n</code></pre>\n<h2 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h2><ul>\n<li><p>概念</p>\n<blockquote>\n<p>event代表事件的状态和信息，比如触发event对象的元素，鼠标的位置及状态，按下的键等等，它的某些属性只对特定的事件有意义</p>\n</blockquote>\n<ul>\n<li>event 是标准浏览器传进去的事件参数，事件参数放置在window.event对象中，兼容ie要加上e=e||window.event</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">DOM.onmousemove = function(e)&#123;//e不止针对移动事件\n    e.clientX    //以浏览器可视区域的左上角为原点\n    e.clientY    //\n    e.pageX // 以body左上角为原点\n    e.pageY // \n&#125;\n</code></pre>\n<p>##盒子位置</p>\n<pre><code class=\"js\">DOM.offsetParent //找到一个有定位的父级，如果上级没有定位，会一直往上找，如果都没有最后找到body\nDOM.offsetLeft //得到的是父级的水平距离\nDOM.offsetTop // 得到的是父级的垂直距离\n\n\nDOM.offsetWidth // 获取宽度，返回num类型padding+content+border\nDOM.offsetHeight // 获取高度，返回num类型\n//style.width 1.只能获取到行内样式 2.获取的只是内容宽度 3.获取到带px\n//offsetWidth不可以设置,只能读取\n\n\nDOM.clientwidth //获取宽度，不带边框\nDOM.clientHeight // 获取高度\n</code></pre>\n<p>##事件解绑</p>\n<pre><code class=\"js\">DOM.on事件类型 = null; //事件解绑 \nDOM.romoveEventListener(&#39;事件&#39;,事件函数名) //注销事件\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"05-js-Web-API\"><a href=\"#05-js-Web-API\" class=\"headerlink\" title=\"05-js Web API\"></a>05-js Web API</h1><p>##鼠标事件</p>\n<pre><code class=\"javascript\">onmousedown //当鼠标点击左键的时候触发\nonmouseup   // 当鼠标的按键松开的时候执行\n\nmouseover    //鼠标移入元素触发\nonmouseleave //鼠标移除元素触发\n\n\nonmousemove     // 鼠标移在元素中移动时触发\n\n\n // 以下两个事件都是，鼠标在某个元素身上移动的时候出触发\nmouseover // 会冒泡到子元素\nmouseenter     // 不会冒泡到子元素\n</code></pre>\n<h2 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h2><ul>\n<li><p>概念</p>\n<blockquote>\n<p>event代表事件的状态和信息，比如触发event对象的元素，鼠标的位置及状态，按下的键等等，它的某些属性只对特定的事件有意义</p>\n</blockquote>\n<ul>\n<li>event 是标准浏览器传进去的事件参数，事件参数放置在window.event对象中，兼容ie要加上e=e||window.event</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">DOM.onmousemove = function(e)&#123;//e不止针对移动事件\n    e.clientX    //以浏览器可视区域的左上角为原点\n    e.clientY    //\n    e.pageX // 以body左上角为原点\n    e.pageY // \n&#125;\n</code></pre>\n<p>##盒子位置</p>\n<pre><code class=\"js\">DOM.offsetParent //找到一个有定位的父级，如果上级没有定位，会一直往上找，如果都没有最后找到body\nDOM.offsetLeft //得到的是父级的水平距离\nDOM.offsetTop // 得到的是父级的垂直距离\n\n\nDOM.offsetWidth // 获取宽度，返回num类型padding+content+border\nDOM.offsetHeight // 获取高度，返回num类型\n//style.width 1.只能获取到行内样式 2.获取的只是内容宽度 3.获取到带px\n//offsetWidth不可以设置,只能读取\n\n\nDOM.clientwidth //获取宽度，不带边框\nDOM.clientHeight // 获取高度\n</code></pre>\n<p>##事件解绑</p>\n<pre><code class=\"js\">DOM.on事件类型 = null; //事件解绑 \nDOM.romoveEventListener(&#39;事件&#39;,事件函数名) //注销事件\n</code></pre>\n"},{"title":"javascriptDom基础-插件","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 06-js Web API\n\n##dom节点样式设置获取\n\n```js\n//设置\ndom.style\n\n//获取\nwindow.getComputedStyle(div) //获取css样式，不分行内外\n```\n\n##轮播图无缝\n\n```js\n1.给首尾各放一张图片\n2.首补尾，尾补首\n```\n\n##zepto\n\n+ 一个轻量的库，移动端用，jq是pc端的\n\n  \n\n```js\n$('css选择器').width() //获取宽度\n$('css选择器').on('swipeLeft',function(){})//绑定左滑事件\n$('css选择器').css(\"样式名\",\"属性值\") //设置css样式\n```\n\n##Swiper插件\n\n+ 介绍\n\n  轮播图插件\n\n\n\n","source":"_posts/笔记/ocean/04-javascript_webapi/06-插件/06-笔记.md","raw":"---\ntitle: javascriptDom基础-插件\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 06-js Web API\n\n##dom节点样式设置获取\n\n```js\n//设置\ndom.style\n\n//获取\nwindow.getComputedStyle(div) //获取css样式，不分行内外\n```\n\n##轮播图无缝\n\n```js\n1.给首尾各放一张图片\n2.首补尾，尾补首\n```\n\n##zepto\n\n+ 一个轻量的库，移动端用，jq是pc端的\n\n  \n\n```js\n$('css选择器').width() //获取宽度\n$('css选择器').on('swipeLeft',function(){})//绑定左滑事件\n$('css选择器').css(\"样式名\",\"属性值\") //设置css样式\n```\n\n##Swiper插件\n\n+ 介绍\n\n  轮播图插件\n\n\n\n","slug":"笔记/ocean/04-javascript_webapi/06-插件/06-笔记","published":1,"updated":"2023-03-01T06:56:15.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcq002iawaf8ogg71cz","content":"<h1 id=\"06-js-Web-API\"><a href=\"#06-js-Web-API\" class=\"headerlink\" title=\"06-js Web API\"></a>06-js Web API</h1><p>##dom节点样式设置获取</p>\n<pre><code class=\"js\">//设置\ndom.style\n\n//获取\nwindow.getComputedStyle(div) //获取css样式，不分行内外\n</code></pre>\n<p>##轮播图无缝</p>\n<pre><code class=\"js\">1.给首尾各放一张图片\n2.首补尾，尾补首\n</code></pre>\n<p>##zepto</p>\n<ul>\n<li>一个轻量的库，移动端用，jq是pc端的</li>\n</ul>\n<pre><code class=\"js\">$(&#39;css选择器&#39;).width() //获取宽度\n$(&#39;css选择器&#39;).on(&#39;swipeLeft&#39;,function()&#123;&#125;)//绑定左滑事件\n$(&#39;css选择器&#39;).css(&quot;样式名&quot;,&quot;属性值&quot;) //设置css样式\n</code></pre>\n<p>##Swiper插件</p>\n<ul>\n<li><p>介绍</p>\n<p>轮播图插件</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"06-js-Web-API\"><a href=\"#06-js-Web-API\" class=\"headerlink\" title=\"06-js Web API\"></a>06-js Web API</h1><p>##dom节点样式设置获取</p>\n<pre><code class=\"js\">//设置\ndom.style\n\n//获取\nwindow.getComputedStyle(div) //获取css样式，不分行内外\n</code></pre>\n<p>##轮播图无缝</p>\n<pre><code class=\"js\">1.给首尾各放一张图片\n2.首补尾，尾补首\n</code></pre>\n<p>##zepto</p>\n<ul>\n<li>一个轻量的库，移动端用，jq是pc端的</li>\n</ul>\n<pre><code class=\"js\">$(&#39;css选择器&#39;).width() //获取宽度\n$(&#39;css选择器&#39;).on(&#39;swipeLeft&#39;,function()&#123;&#125;)//绑定左滑事件\n$(&#39;css选择器&#39;).css(&quot;样式名&quot;,&quot;属性值&quot;) //设置css样式\n</code></pre>\n<p>##Swiper插件</p>\n<ul>\n<li><p>介绍</p>\n<p>轮播图插件</p>\n</li>\n</ul>\n"},{"title":"javascript高级-函数和闭包","date":"2017-02-06T04:01:23.000Z","_content":"# 03-js高级\n\n\n\n## 函数\n\n+ 作用\n\n  1. 把一段需要重复使用的代码，用function语法抱起来，方便调用，分块和简化代码\n\n+ 创建函数\n\n  ```js\n  //面试题：创造函数有几种方式\n  //1.使用function关键字创建\n  function fn1(){\n  }\n  \n  //2.使用函数表达式\n  var fn2 = function(){\n  }\n  \n  //3.new Function\n  var f = new Function('参数1','参数2',...,函数体){}\n  f(1,2)\n  \n  ```\n\n+ 调用函数\n\n  ```js\n  \n  //函数调用：\n  //1.普通函数调用\n  \tfun1();\t//这里的this指向是windows\n  \n  //2.调用对象上的方法\n  var obj = {\n      fun2:function(){}\n  }\n  \tobj.fun2();\t//这里this指的是obj\n  \n  //3.调用构造函数\n  var per = function(){\n      this.name = \"小白\"\n      this.say = function(){\n  \t\tconsole.log(this.name)\n      }\n  }\n  var p = new per()\n  p.say() //调用构造函数中的函数\n  \n  //4.定时器调用\n  \t setTimeout(function(){},1000) //定时器内部this指的是windows\n  \n  //5.自调用函数\n  (函数体)()   //this指的是window \n  ！函数体();\n  ```\n\n  \n\n## 高阶函数\n\n```js\nfunction fun(a){\n    a()\n}\nfun(function(){\n    console.log(\"hh\")\n}) //fun是高阶函数 ， a为回调函数，\n当一个函数作为另一个函数的实参的时候，并且在其内部调用，就会被称为回调函数，而它的父级就是高阶函数\n如果是在内部return的函数，它就是一个普通函数。\n\n\n```\n\n## 构造函数 ？\n\n```js\n构造函数也是一个普通函数,他们的本质都一样，但是执行顺序不一样\n\n普通函数调用：fun1()\n\t\t执行顺序：\n\t\t1.当出现fun1()时，执行该函数体\n\t\t2.普通函数不加return没有返回值\n构造函数调用: new Fun2()\n\t要使用new关键字来调用,且函数名大写\n\t执行顺序：\n\t\t1.当new Fun2()时，立刻在内存中创建一个新的对象，将this的指向指到该对象\n\t\t2.执行函数中的代码\n\t\t3.执行完后，返回值为新建的这个对象\n```\n\n## 改变this指向方法\n\n```js\nfn.call(obj,1,2) //第一参数是this的指向：指向obj，执行函数，主要用在构造函数的继承\nfn.apply(obj,[1,2])\t//第一参数是this的指向，第二个参数是数组[10，20]，执行函数,主要用在对数组的操作\nfn.bind(obj,1,2) //第一个参数是this的指向，第二个参数逗号分隔，不执行函数，返回值是内部this已经改变后的函数,利用不执行的特性可用来改变函数中的this指向而不执行\n\n\n\n//求数组的最大值\nvar arr = [1,2,3,4,5,6]  //\nMath.max(1,2,3,4,5,6)\t//这种方法只能传入以逗号隔开的数字\nMath.max.apply(Math,arr) //利用apply改变this的指向，并且可传入数组的特性\n```\n\n## 闭包\n\n+ 函数 和 函数内部 能访问到的变量 的 环境，会构成闭包，要出现两个局部作用域\n\n+ 闭包会造成内存泄露。\n\n  ### 什么是内存泄漏\n\n  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n\n\n```js\nfunction a(){\n    var a = 10; \n    function b(){\n        a++\t\n    }\n    b()\n}\na();\n\n//只要闭包，那个变量在内存中就不会被销毁\nfunction fn() {\n    var num = 10;\n    function fun() {\n        num++; //当a++后，会形成闭包，a会永久存在，除非刷新页面或关闭\n        console.log(num);\n    }\n    return fun;\n}\nvar f = fn();\n\nf();  // 11\nf();  // 12\nf();  // 13\n\n```\n\n\n\n","source":"_posts/笔记/ocean/05-javascript高级总结/03-函数和闭包/03-笔记.md","raw":"---\ntitle: javascript高级-函数和闭包\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n# 03-js高级\n\n\n\n## 函数\n\n+ 作用\n\n  1. 把一段需要重复使用的代码，用function语法抱起来，方便调用，分块和简化代码\n\n+ 创建函数\n\n  ```js\n  //面试题：创造函数有几种方式\n  //1.使用function关键字创建\n  function fn1(){\n  }\n  \n  //2.使用函数表达式\n  var fn2 = function(){\n  }\n  \n  //3.new Function\n  var f = new Function('参数1','参数2',...,函数体){}\n  f(1,2)\n  \n  ```\n\n+ 调用函数\n\n  ```js\n  \n  //函数调用：\n  //1.普通函数调用\n  \tfun1();\t//这里的this指向是windows\n  \n  //2.调用对象上的方法\n  var obj = {\n      fun2:function(){}\n  }\n  \tobj.fun2();\t//这里this指的是obj\n  \n  //3.调用构造函数\n  var per = function(){\n      this.name = \"小白\"\n      this.say = function(){\n  \t\tconsole.log(this.name)\n      }\n  }\n  var p = new per()\n  p.say() //调用构造函数中的函数\n  \n  //4.定时器调用\n  \t setTimeout(function(){},1000) //定时器内部this指的是windows\n  \n  //5.自调用函数\n  (函数体)()   //this指的是window \n  ！函数体();\n  ```\n\n  \n\n## 高阶函数\n\n```js\nfunction fun(a){\n    a()\n}\nfun(function(){\n    console.log(\"hh\")\n}) //fun是高阶函数 ， a为回调函数，\n当一个函数作为另一个函数的实参的时候，并且在其内部调用，就会被称为回调函数，而它的父级就是高阶函数\n如果是在内部return的函数，它就是一个普通函数。\n\n\n```\n\n## 构造函数 ？\n\n```js\n构造函数也是一个普通函数,他们的本质都一样，但是执行顺序不一样\n\n普通函数调用：fun1()\n\t\t执行顺序：\n\t\t1.当出现fun1()时，执行该函数体\n\t\t2.普通函数不加return没有返回值\n构造函数调用: new Fun2()\n\t要使用new关键字来调用,且函数名大写\n\t执行顺序：\n\t\t1.当new Fun2()时，立刻在内存中创建一个新的对象，将this的指向指到该对象\n\t\t2.执行函数中的代码\n\t\t3.执行完后，返回值为新建的这个对象\n```\n\n## 改变this指向方法\n\n```js\nfn.call(obj,1,2) //第一参数是this的指向：指向obj，执行函数，主要用在构造函数的继承\nfn.apply(obj,[1,2])\t//第一参数是this的指向，第二个参数是数组[10，20]，执行函数,主要用在对数组的操作\nfn.bind(obj,1,2) //第一个参数是this的指向，第二个参数逗号分隔，不执行函数，返回值是内部this已经改变后的函数,利用不执行的特性可用来改变函数中的this指向而不执行\n\n\n\n//求数组的最大值\nvar arr = [1,2,3,4,5,6]  //\nMath.max(1,2,3,4,5,6)\t//这种方法只能传入以逗号隔开的数字\nMath.max.apply(Math,arr) //利用apply改变this的指向，并且可传入数组的特性\n```\n\n## 闭包\n\n+ 函数 和 函数内部 能访问到的变量 的 环境，会构成闭包，要出现两个局部作用域\n\n+ 闭包会造成内存泄露。\n\n  ### 什么是内存泄漏\n\n  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n\n\n```js\nfunction a(){\n    var a = 10; \n    function b(){\n        a++\t\n    }\n    b()\n}\na();\n\n//只要闭包，那个变量在内存中就不会被销毁\nfunction fn() {\n    var num = 10;\n    function fun() {\n        num++; //当a++后，会形成闭包，a会永久存在，除非刷新页面或关闭\n        console.log(num);\n    }\n    return fun;\n}\nvar f = fn();\n\nf();  // 11\nf();  // 12\nf();  // 13\n\n```\n\n\n\n","slug":"笔记/ocean/05-javascript高级总结/03-函数和闭包/03-笔记","published":1,"updated":"2023-03-01T06:58:56.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcr002lawafgayg2gq2","content":"<h1 id=\"03-js高级\"><a href=\"#03-js高级\" class=\"headerlink\" title=\"03-js高级\"></a>03-js高级</h1><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li><p>作用</p>\n<ol>\n<li>把一段需要重复使用的代码，用function语法抱起来，方便调用，分块和简化代码</li>\n</ol>\n</li>\n<li><p>创建函数</p>\n<pre><code class=\"js\">//面试题：创造函数有几种方式\n//1.使用function关键字创建\nfunction fn1()&#123;\n&#125;\n\n//2.使用函数表达式\nvar fn2 = function()&#123;\n&#125;\n\n//3.new Function\nvar f = new Function(&#39;参数1&#39;,&#39;参数2&#39;,...,函数体)&#123;&#125;\nf(1,2)\n</code></pre>\n</li>\n<li><p>调用函数</p>\n<pre><code class=\"js\">\n//函数调用：\n//1.普通函数调用\n    fun1();    //这里的this指向是windows\n\n//2.调用对象上的方法\nvar obj = &#123;\n    fun2:function()&#123;&#125;\n&#125;\n    obj.fun2();    //这里this指的是obj\n\n//3.调用构造函数\nvar per = function()&#123;\n    this.name = &quot;小白&quot;\n    this.say = function()&#123;\n        console.log(this.name)\n    &#125;\n&#125;\nvar p = new per()\np.say() //调用构造函数中的函数\n\n//4.定时器调用\n     setTimeout(function()&#123;&#125;,1000) //定时器内部this指的是windows\n\n//5.自调用函数\n(函数体)()   //this指的是window \n！函数体();\n</code></pre>\n</li>\n</ul>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><pre><code class=\"js\">function fun(a)&#123;\n    a()\n&#125;\nfun(function()&#123;\n    console.log(&quot;hh&quot;)\n&#125;) //fun是高阶函数 ， a为回调函数，\n当一个函数作为另一个函数的实参的时候，并且在其内部调用，就会被称为回调函数，而它的父级就是高阶函数\n如果是在内部return的函数，它就是一个普通函数。\n\n</code></pre>\n<h2 id=\"构造函数-？\"><a href=\"#构造函数-？\" class=\"headerlink\" title=\"构造函数 ？\"></a>构造函数 ？</h2><pre><code class=\"js\">构造函数也是一个普通函数,他们的本质都一样，但是执行顺序不一样\n\n普通函数调用：fun1()\n        执行顺序：\n        1.当出现fun1()时，执行该函数体\n        2.普通函数不加return没有返回值\n构造函数调用: new Fun2()\n    要使用new关键字来调用,且函数名大写\n    执行顺序：\n        1.当new Fun2()时，立刻在内存中创建一个新的对象，将this的指向指到该对象\n        2.执行函数中的代码\n        3.执行完后，返回值为新建的这个对象\n</code></pre>\n<h2 id=\"改变this指向方法\"><a href=\"#改变this指向方法\" class=\"headerlink\" title=\"改变this指向方法\"></a>改变this指向方法</h2><pre><code class=\"js\">fn.call(obj,1,2) //第一参数是this的指向：指向obj，执行函数，主要用在构造函数的继承\nfn.apply(obj,[1,2])    //第一参数是this的指向，第二个参数是数组[10，20]，执行函数,主要用在对数组的操作\nfn.bind(obj,1,2) //第一个参数是this的指向，第二个参数逗号分隔，不执行函数，返回值是内部this已经改变后的函数,利用不执行的特性可用来改变函数中的this指向而不执行\n\n\n\n//求数组的最大值\nvar arr = [1,2,3,4,5,6]  //\nMath.max(1,2,3,4,5,6)    //这种方法只能传入以逗号隔开的数字\nMath.max.apply(Math,arr) //利用apply改变this的指向，并且可传入数组的特性\n</code></pre>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><ul>\n<li><p>函数 和 函数内部 能访问到的变量 的 环境，会构成闭包，要出现两个局部作用域</p>\n</li>\n<li><p>闭包会造成内存泄露。</p>\n<h3 id=\"什么是内存泄漏\"><a href=\"#什么是内存泄漏\" class=\"headerlink\" title=\"什么是内存泄漏\"></a>什么是内存泄漏</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</p>\n</li>\n</ul>\n<pre><code class=\"js\">function a()&#123;\n    var a = 10; \n    function b()&#123;\n        a++    \n    &#125;\n    b()\n&#125;\na();\n\n//只要闭包，那个变量在内存中就不会被销毁\nfunction fn() &#123;\n    var num = 10;\n    function fun() &#123;\n        num++; //当a++后，会形成闭包，a会永久存在，除非刷新页面或关闭\n        console.log(num);\n    &#125;\n    return fun;\n&#125;\nvar f = fn();\n\nf();  // 11\nf();  // 12\nf();  // 13\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-js高级\"><a href=\"#03-js高级\" class=\"headerlink\" title=\"03-js高级\"></a>03-js高级</h1><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li><p>作用</p>\n<ol>\n<li>把一段需要重复使用的代码，用function语法抱起来，方便调用，分块和简化代码</li>\n</ol>\n</li>\n<li><p>创建函数</p>\n<pre><code class=\"js\">//面试题：创造函数有几种方式\n//1.使用function关键字创建\nfunction fn1()&#123;\n&#125;\n\n//2.使用函数表达式\nvar fn2 = function()&#123;\n&#125;\n\n//3.new Function\nvar f = new Function(&#39;参数1&#39;,&#39;参数2&#39;,...,函数体)&#123;&#125;\nf(1,2)\n</code></pre>\n</li>\n<li><p>调用函数</p>\n<pre><code class=\"js\">\n//函数调用：\n//1.普通函数调用\n    fun1();    //这里的this指向是windows\n\n//2.调用对象上的方法\nvar obj = &#123;\n    fun2:function()&#123;&#125;\n&#125;\n    obj.fun2();    //这里this指的是obj\n\n//3.调用构造函数\nvar per = function()&#123;\n    this.name = &quot;小白&quot;\n    this.say = function()&#123;\n        console.log(this.name)\n    &#125;\n&#125;\nvar p = new per()\np.say() //调用构造函数中的函数\n\n//4.定时器调用\n     setTimeout(function()&#123;&#125;,1000) //定时器内部this指的是windows\n\n//5.自调用函数\n(函数体)()   //this指的是window \n！函数体();\n</code></pre>\n</li>\n</ul>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><pre><code class=\"js\">function fun(a)&#123;\n    a()\n&#125;\nfun(function()&#123;\n    console.log(&quot;hh&quot;)\n&#125;) //fun是高阶函数 ， a为回调函数，\n当一个函数作为另一个函数的实参的时候，并且在其内部调用，就会被称为回调函数，而它的父级就是高阶函数\n如果是在内部return的函数，它就是一个普通函数。\n\n</code></pre>\n<h2 id=\"构造函数-？\"><a href=\"#构造函数-？\" class=\"headerlink\" title=\"构造函数 ？\"></a>构造函数 ？</h2><pre><code class=\"js\">构造函数也是一个普通函数,他们的本质都一样，但是执行顺序不一样\n\n普通函数调用：fun1()\n        执行顺序：\n        1.当出现fun1()时，执行该函数体\n        2.普通函数不加return没有返回值\n构造函数调用: new Fun2()\n    要使用new关键字来调用,且函数名大写\n    执行顺序：\n        1.当new Fun2()时，立刻在内存中创建一个新的对象，将this的指向指到该对象\n        2.执行函数中的代码\n        3.执行完后，返回值为新建的这个对象\n</code></pre>\n<h2 id=\"改变this指向方法\"><a href=\"#改变this指向方法\" class=\"headerlink\" title=\"改变this指向方法\"></a>改变this指向方法</h2><pre><code class=\"js\">fn.call(obj,1,2) //第一参数是this的指向：指向obj，执行函数，主要用在构造函数的继承\nfn.apply(obj,[1,2])    //第一参数是this的指向，第二个参数是数组[10，20]，执行函数,主要用在对数组的操作\nfn.bind(obj,1,2) //第一个参数是this的指向，第二个参数逗号分隔，不执行函数，返回值是内部this已经改变后的函数,利用不执行的特性可用来改变函数中的this指向而不执行\n\n\n\n//求数组的最大值\nvar arr = [1,2,3,4,5,6]  //\nMath.max(1,2,3,4,5,6)    //这种方法只能传入以逗号隔开的数字\nMath.max.apply(Math,arr) //利用apply改变this的指向，并且可传入数组的特性\n</code></pre>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><ul>\n<li><p>函数 和 函数内部 能访问到的变量 的 环境，会构成闭包，要出现两个局部作用域</p>\n</li>\n<li><p>闭包会造成内存泄露。</p>\n<h3 id=\"什么是内存泄漏\"><a href=\"#什么是内存泄漏\" class=\"headerlink\" title=\"什么是内存泄漏\"></a>什么是内存泄漏</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</p>\n</li>\n</ul>\n<pre><code class=\"js\">function a()&#123;\n    var a = 10; \n    function b()&#123;\n        a++    \n    &#125;\n    b()\n&#125;\na();\n\n//只要闭包，那个变量在内存中就不会被销毁\nfunction fn() &#123;\n    var num = 10;\n    function fun() &#123;\n        num++; //当a++后，会形成闭包，a会永久存在，除非刷新页面或关闭\n        console.log(num);\n    &#125;\n    return fun;\n&#125;\nvar f = fn();\n\nf();  // 11\nf();  // 12\nf();  // 13\n</code></pre>\n"},{"title":"javascript高级-递归","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# 04-js高级\n\n## 递归\n\n+ 递归其实就是在函数体内调用本函数\n+ 递归函数的使用要注意函数终止条件避免死循环\n\n```js\n//形成递归死循环\nfunction fun(){\n    console.log(1)\n    fun()\n}\nfun()\n\n//面试题：深拷贝，浅拷贝\n1.创建一个函数，函数内部判断参数类型，分别判断数组，对象，普通数据类型\nfunction copy(data){\n    var _new\n    if(data instanceof Array){\n        _new = [];\n        for(let i=0;i<data.length;i++){\n            _new[i] = copy(data[i])\n        }\n    }\n    if(data instanceof Object && !Array.isArray(data)){\n        console.log(1);\n        _new = {}\n        for(key in data){\n            _new[key] = copy(data[key])\n        }\n    }else{\n        _new = data\n    }\n    \n   return _new\n}\n\n/*\n浅拷贝只能复制第一层\n深拷贝不管几层都会拷贝到\n*/\n\nArray.isArray(arr) //判断是否为数组，为数组返回true\n```\n\n## 正则\n\n+ 作用：用于描述一组字符串特征的模式，用来匹配特定的字符串。\n+ 正则与语言无关\n+ 常用正则\n\n```js\nvar a = /规则/  //\nvar b = new RegExp(/123/) //用构造函数创建正则表达式\n\n\nvar c = b.test(\"addddd\") //test用于检测字符串中的正则\n\n\n/a/  //匹配字符中是否出现a,出现为true \n^   //必须以规定文字开头\n$ //必须以规定 文字 结尾\n/^abc$/ // 必须是abc\n/^(abc|bbb|ccc)$/ //从括号中选取一个组\n/[a-z]/  // 只要包含 a到z其中一个字符 就可以\n/^[abcde]$/ //从[] 只选出一个字符\n/^[a-zA-Z0-9]$/ //a到z的大小写+0到9\n/[^a-zA-Z0-9]/ //只要不包含a-zA-Z0-9就可\n\n* // 出现0次或n次\n+ //出现1次或n次\n？ // 0 或1次\n{n}//n次\n{n,} //重复n次或更多次\n{n,m} //重复n到m次\n\n \\d //0-9\n \n .replace(/a/,\"b\") //将第一个a替换成新的字符\n .replace(/a/g,\"新替换的字符\") //将所有的a(小写)替换成新的字符\n .replace(/a/gi,\"新替换的字符\") //将所有的a（不分大小写）替换成新的字符\n \n //严格模式后未声明的变量会报错\n 'use strict'\n```\n\n## ？\n\n1. 递归面试题\n\n   + 1个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞？\n\n     ```js\n     //\n     \n     \n     \n     \n     ```\n\n     ","source":"_posts/笔记/ocean/05-javascript高级总结/04-递归和正则/04-笔记.md","raw":"---\ntitle: javascript高级-递归\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# 04-js高级\n\n## 递归\n\n+ 递归其实就是在函数体内调用本函数\n+ 递归函数的使用要注意函数终止条件避免死循环\n\n```js\n//形成递归死循环\nfunction fun(){\n    console.log(1)\n    fun()\n}\nfun()\n\n//面试题：深拷贝，浅拷贝\n1.创建一个函数，函数内部判断参数类型，分别判断数组，对象，普通数据类型\nfunction copy(data){\n    var _new\n    if(data instanceof Array){\n        _new = [];\n        for(let i=0;i<data.length;i++){\n            _new[i] = copy(data[i])\n        }\n    }\n    if(data instanceof Object && !Array.isArray(data)){\n        console.log(1);\n        _new = {}\n        for(key in data){\n            _new[key] = copy(data[key])\n        }\n    }else{\n        _new = data\n    }\n    \n   return _new\n}\n\n/*\n浅拷贝只能复制第一层\n深拷贝不管几层都会拷贝到\n*/\n\nArray.isArray(arr) //判断是否为数组，为数组返回true\n```\n\n## 正则\n\n+ 作用：用于描述一组字符串特征的模式，用来匹配特定的字符串。\n+ 正则与语言无关\n+ 常用正则\n\n```js\nvar a = /规则/  //\nvar b = new RegExp(/123/) //用构造函数创建正则表达式\n\n\nvar c = b.test(\"addddd\") //test用于检测字符串中的正则\n\n\n/a/  //匹配字符中是否出现a,出现为true \n^   //必须以规定文字开头\n$ //必须以规定 文字 结尾\n/^abc$/ // 必须是abc\n/^(abc|bbb|ccc)$/ //从括号中选取一个组\n/[a-z]/  // 只要包含 a到z其中一个字符 就可以\n/^[abcde]$/ //从[] 只选出一个字符\n/^[a-zA-Z0-9]$/ //a到z的大小写+0到9\n/[^a-zA-Z0-9]/ //只要不包含a-zA-Z0-9就可\n\n* // 出现0次或n次\n+ //出现1次或n次\n？ // 0 或1次\n{n}//n次\n{n,} //重复n次或更多次\n{n,m} //重复n到m次\n\n \\d //0-9\n \n .replace(/a/,\"b\") //将第一个a替换成新的字符\n .replace(/a/g,\"新替换的字符\") //将所有的a(小写)替换成新的字符\n .replace(/a/gi,\"新替换的字符\") //将所有的a（不分大小写）替换成新的字符\n \n //严格模式后未声明的变量会报错\n 'use strict'\n```\n\n## ？\n\n1. 递归面试题\n\n   + 1个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞？\n\n     ```js\n     //\n     \n     \n     \n     \n     ```\n\n     ","slug":"笔记/ocean/05-javascript高级总结/04-递归和正则/04-笔记","published":1,"updated":"2023-03-01T06:59:16.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qct002nawaf1vpm23ze","content":"<h1 id=\"04-js高级\"><a href=\"#04-js高级\" class=\"headerlink\" title=\"04-js高级\"></a>04-js高级</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><ul>\n<li>递归其实就是在函数体内调用本函数</li>\n<li>递归函数的使用要注意函数终止条件避免死循环</li>\n</ul>\n<pre><code class=\"js\">//形成递归死循环\nfunction fun()&#123;\n    console.log(1)\n    fun()\n&#125;\nfun()\n\n//面试题：深拷贝，浅拷贝\n1.创建一个函数，函数内部判断参数类型，分别判断数组，对象，普通数据类型\nfunction copy(data)&#123;\n    var _new\n    if(data instanceof Array)&#123;\n        _new = [];\n        for(let i=0;i&lt;data.length;i++)&#123;\n            _new[i] = copy(data[i])\n        &#125;\n    &#125;\n    if(data instanceof Object &amp;&amp; !Array.isArray(data))&#123;\n        console.log(1);\n        _new = &#123;&#125;\n        for(key in data)&#123;\n            _new[key] = copy(data[key])\n        &#125;\n    &#125;else&#123;\n        _new = data\n    &#125;\n    \n   return _new\n&#125;\n\n/*\n浅拷贝只能复制第一层\n深拷贝不管几层都会拷贝到\n*/\n\nArray.isArray(arr) //判断是否为数组，为数组返回true\n</code></pre>\n<h2 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h2><ul>\n<li>作用：用于描述一组字符串特征的模式，用来匹配特定的字符串。</li>\n<li>正则与语言无关</li>\n<li>常用正则</li>\n</ul>\n<pre><code class=\"js\">var a = /规则/  //\nvar b = new RegExp(/123/) //用构造函数创建正则表达式\n\n\nvar c = b.test(&quot;addddd&quot;) //test用于检测字符串中的正则\n\n\n/a/  //匹配字符中是否出现a,出现为true \n^   //必须以规定文字开头\n$ //必须以规定 文字 结尾\n/^abc$/ // 必须是abc\n/^(abc|bbb|ccc)$/ //从括号中选取一个组\n/[a-z]/  // 只要包含 a到z其中一个字符 就可以\n/^[abcde]$/ //从[] 只选出一个字符\n/^[a-zA-Z0-9]$/ //a到z的大小写+0到9\n/[^a-zA-Z0-9]/ //只要不包含a-zA-Z0-9就可\n\n* // 出现0次或n次\n+ //出现1次或n次\n？ // 0 或1次\n&#123;n&#125;//n次\n&#123;n,&#125; //重复n次或更多次\n&#123;n,m&#125; //重复n到m次\n\n \\d //0-9\n \n .replace(/a/,&quot;b&quot;) //将第一个a替换成新的字符\n .replace(/a/g,&quot;新替换的字符&quot;) //将所有的a(小写)替换成新的字符\n .replace(/a/gi,&quot;新替换的字符&quot;) //将所有的a（不分大小写）替换成新的字符\n \n //严格模式后未声明的变量会报错\n &#39;use strict&#39;\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>递归面试题</p>\n<ul>\n<li><p>1个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞？</p>\n<pre><code class=\"js\">//\n\n\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"04-js高级\"><a href=\"#04-js高级\" class=\"headerlink\" title=\"04-js高级\"></a>04-js高级</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><ul>\n<li>递归其实就是在函数体内调用本函数</li>\n<li>递归函数的使用要注意函数终止条件避免死循环</li>\n</ul>\n<pre><code class=\"js\">//形成递归死循环\nfunction fun()&#123;\n    console.log(1)\n    fun()\n&#125;\nfun()\n\n//面试题：深拷贝，浅拷贝\n1.创建一个函数，函数内部判断参数类型，分别判断数组，对象，普通数据类型\nfunction copy(data)&#123;\n    var _new\n    if(data instanceof Array)&#123;\n        _new = [];\n        for(let i=0;i&lt;data.length;i++)&#123;\n            _new[i] = copy(data[i])\n        &#125;\n    &#125;\n    if(data instanceof Object &amp;&amp; !Array.isArray(data))&#123;\n        console.log(1);\n        _new = &#123;&#125;\n        for(key in data)&#123;\n            _new[key] = copy(data[key])\n        &#125;\n    &#125;else&#123;\n        _new = data\n    &#125;\n    \n   return _new\n&#125;\n\n/*\n浅拷贝只能复制第一层\n深拷贝不管几层都会拷贝到\n*/\n\nArray.isArray(arr) //判断是否为数组，为数组返回true\n</code></pre>\n<h2 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h2><ul>\n<li>作用：用于描述一组字符串特征的模式，用来匹配特定的字符串。</li>\n<li>正则与语言无关</li>\n<li>常用正则</li>\n</ul>\n<pre><code class=\"js\">var a = /规则/  //\nvar b = new RegExp(/123/) //用构造函数创建正则表达式\n\n\nvar c = b.test(&quot;addddd&quot;) //test用于检测字符串中的正则\n\n\n/a/  //匹配字符中是否出现a,出现为true \n^   //必须以规定文字开头\n$ //必须以规定 文字 结尾\n/^abc$/ // 必须是abc\n/^(abc|bbb|ccc)$/ //从括号中选取一个组\n/[a-z]/  // 只要包含 a到z其中一个字符 就可以\n/^[abcde]$/ //从[] 只选出一个字符\n/^[a-zA-Z0-9]$/ //a到z的大小写+0到9\n/[^a-zA-Z0-9]/ //只要不包含a-zA-Z0-9就可\n\n* // 出现0次或n次\n+ //出现1次或n次\n？ // 0 或1次\n&#123;n&#125;//n次\n&#123;n,&#125; //重复n次或更多次\n&#123;n,m&#125; //重复n到m次\n\n \\d //0-9\n \n .replace(/a/,&quot;b&quot;) //将第一个a替换成新的字符\n .replace(/a/g,&quot;新替换的字符&quot;) //将所有的a(小写)替换成新的字符\n .replace(/a/gi,&quot;新替换的字符&quot;) //将所有的a（不分大小写）替换成新的字符\n \n //严格模式后未声明的变量会报错\n &#39;use strict&#39;\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>递归面试题</p>\n<ul>\n<li><p>1个细胞，一个小时分裂一次，生命周期是3小时，求n小时后容器内，有多少细胞？</p>\n<pre><code class=\"js\">//\n\n\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"javascript高级-类和继承","date":"2017-02-06T04:01:23.000Z","_content":"\n\n# js高级02\n\n\n\n##call\n\n+ 可改变this指向，会执行函数\n+ 函数.call(this的指向，传参)\n\n```js\nfunction fn(a,b){\n    this.a = a\n    this.b = b\n}\n\nvar obj = {\n    \n}\n\nfn.call(obj,10,20) //前面是被调用的函数.(新对象，需要执行的参数)，fn会被执行\n\n\nfunction fn2(a,b,c,d){\n    fn.call(this,a,b)\n    \n    this.c = c\n    this.d = d\n}\nnew fn2(1,2,3,4);\n```\n\n##继承\n\n1. 原型链继承\n\n   + 通过修改原型的原型对象，指向要继承的对象或原型，从而实现继承,会造成数据共享的问题。\n\n2. 借助构造函数\n\n   + 在子构造函数中使用call()，apply()来改变this的指向，实现继承,不会造成共享，可以传参，但是函数复用性就没有了,且访问不到父构造函数原型中的方法。\n\n3. 组合继承\n\n   + 用原型链和构造函数结合使用，通过原型链实现属性和方法的继承，然后借用构造函数来实现实例属性的集成。既有函数复用性，有保证都有自己的独立性。但是构造函数会被调用两次\n\n4. 原型式继承\n\n5. 寄生式继承\n\n6. 寄生组合式继承\n\n   \n\n\n\n\n\n\n\n##ES6类\n\n+ 传统的js中只有对象没有类，它是基于原型的面向对象的语言。原型对象特点就是将自身的属性共享给新对象，如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。\n\n+ ES6加入了类，通过class定义。该关键字出现使其在对象写法上更加清晰。\n\n+ 特点\n\n  1. 实质上类就是一个函数，自身指向的就是构造函数\n\n  ```js\n  class Person{\n      \n  }\n  console.log(typeof Person);//function\n  console.log(Person===Person.prototype.constructor);//true=\n  ```\n\n  2. 类的所有方法都定义在prototype上\n  3. constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用\n  4. constructor不定义也存在，默认返回实例对象this\n  5. constructor中定义的属性可称为实例属性，即定义在this对象上，在它之外定义都是在原型上的\n  6. 类的所有实例共享一个原型对象，所以proto属性是相等的。\n  7. class不存在变量提升，需要先定义在使用\n\n```js\nclass 类名{ //创建类\n    constructor(name,age){\t//es5的构造函数\n        this.name = name\n        this.age = age\n    }\n    \n    fun1(){ } //自定义方法\n}\t\n\nvar cls = new 类名(\"zs\",12)\t//实例化对象\ncls.fun1() //调用类里的方法\n\n\nhasOwnProperty() //判断是否为实例属性\n```\n\n### 类的继承\n\n> **其实质是先创造出父类的this对象，然后用子类的构造函数修改this** \n\n1. extends 要继承的类\n2. constructor中使用super()获取继承类的属性\n\n```js\n\nclass my extends 要继承的类名 {\t//类的继承\n    //如果继承方法同名是不会覆盖的，调用时会按照原型链规则执行\n    super.被继承的方法() //可以调用上级方法\n}\nvar m = new my('1',2)//可直接传参\n\n\nclass my extends 要继承的类名{\n    constructor(x,y,z){\n        super(x,y) //给被继承的类构造函数，确定留几个位置,必需在this前面调用，即使没有参数也要放在前面。\n    }\n}\n\n```\n\n\n\n","source":"_posts/笔记/ocean/05-javascript高级总结/02-类和继承/02-note.md","raw":"---\ntitle: javascript高级-类和继承\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- javascript\n---\n\n\n# js高级02\n\n\n\n##call\n\n+ 可改变this指向，会执行函数\n+ 函数.call(this的指向，传参)\n\n```js\nfunction fn(a,b){\n    this.a = a\n    this.b = b\n}\n\nvar obj = {\n    \n}\n\nfn.call(obj,10,20) //前面是被调用的函数.(新对象，需要执行的参数)，fn会被执行\n\n\nfunction fn2(a,b,c,d){\n    fn.call(this,a,b)\n    \n    this.c = c\n    this.d = d\n}\nnew fn2(1,2,3,4);\n```\n\n##继承\n\n1. 原型链继承\n\n   + 通过修改原型的原型对象，指向要继承的对象或原型，从而实现继承,会造成数据共享的问题。\n\n2. 借助构造函数\n\n   + 在子构造函数中使用call()，apply()来改变this的指向，实现继承,不会造成共享，可以传参，但是函数复用性就没有了,且访问不到父构造函数原型中的方法。\n\n3. 组合继承\n\n   + 用原型链和构造函数结合使用，通过原型链实现属性和方法的继承，然后借用构造函数来实现实例属性的集成。既有函数复用性，有保证都有自己的独立性。但是构造函数会被调用两次\n\n4. 原型式继承\n\n5. 寄生式继承\n\n6. 寄生组合式继承\n\n   \n\n\n\n\n\n\n\n##ES6类\n\n+ 传统的js中只有对象没有类，它是基于原型的面向对象的语言。原型对象特点就是将自身的属性共享给新对象，如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。\n\n+ ES6加入了类，通过class定义。该关键字出现使其在对象写法上更加清晰。\n\n+ 特点\n\n  1. 实质上类就是一个函数，自身指向的就是构造函数\n\n  ```js\n  class Person{\n      \n  }\n  console.log(typeof Person);//function\n  console.log(Person===Person.prototype.constructor);//true=\n  ```\n\n  2. 类的所有方法都定义在prototype上\n  3. constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用\n  4. constructor不定义也存在，默认返回实例对象this\n  5. constructor中定义的属性可称为实例属性，即定义在this对象上，在它之外定义都是在原型上的\n  6. 类的所有实例共享一个原型对象，所以proto属性是相等的。\n  7. class不存在变量提升，需要先定义在使用\n\n```js\nclass 类名{ //创建类\n    constructor(name,age){\t//es5的构造函数\n        this.name = name\n        this.age = age\n    }\n    \n    fun1(){ } //自定义方法\n}\t\n\nvar cls = new 类名(\"zs\",12)\t//实例化对象\ncls.fun1() //调用类里的方法\n\n\nhasOwnProperty() //判断是否为实例属性\n```\n\n### 类的继承\n\n> **其实质是先创造出父类的this对象，然后用子类的构造函数修改this** \n\n1. extends 要继承的类\n2. constructor中使用super()获取继承类的属性\n\n```js\n\nclass my extends 要继承的类名 {\t//类的继承\n    //如果继承方法同名是不会覆盖的，调用时会按照原型链规则执行\n    super.被继承的方法() //可以调用上级方法\n}\nvar m = new my('1',2)//可直接传参\n\n\nclass my extends 要继承的类名{\n    constructor(x,y,z){\n        super(x,y) //给被继承的类构造函数，确定留几个位置,必需在this前面调用，即使没有参数也要放在前面。\n    }\n}\n\n```\n\n\n\n","slug":"笔记/ocean/05-javascript高级总结/02-类和继承/02-note","published":1,"updated":"2023-03-01T06:56:52.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcu002rawaf1fno1j0y","content":"<h1 id=\"js高级02\"><a href=\"#js高级02\" class=\"headerlink\" title=\"js高级02\"></a>js高级02</h1><p>##call</p>\n<ul>\n<li>可改变this指向，会执行函数</li>\n<li>函数.call(this的指向，传参)</li>\n</ul>\n<pre><code class=\"js\">function fn(a,b)&#123;\n    this.a = a\n    this.b = b\n&#125;\n\nvar obj = &#123;\n    \n&#125;\n\nfn.call(obj,10,20) //前面是被调用的函数.(新对象，需要执行的参数)，fn会被执行\n\n\nfunction fn2(a,b,c,d)&#123;\n    fn.call(this,a,b)\n    \n    this.c = c\n    this.d = d\n&#125;\nnew fn2(1,2,3,4);\n</code></pre>\n<p>##继承</p>\n<ol>\n<li><p>原型链继承</p>\n<ul>\n<li>通过修改原型的原型对象，指向要继承的对象或原型，从而实现继承,会造成数据共享的问题。</li>\n</ul>\n</li>\n<li><p>借助构造函数</p>\n<ul>\n<li>在子构造函数中使用call()，apply()来改变this的指向，实现继承,不会造成共享，可以传参，但是函数复用性就没有了,且访问不到父构造函数原型中的方法。</li>\n</ul>\n</li>\n<li><p>组合继承</p>\n<ul>\n<li>用原型链和构造函数结合使用，通过原型链实现属性和方法的继承，然后借用构造函数来实现实例属性的集成。既有函数复用性，有保证都有自己的独立性。但是构造函数会被调用两次</li>\n</ul>\n</li>\n<li><p>原型式继承</p>\n</li>\n<li><p>寄生式继承</p>\n</li>\n<li><p>寄生组合式继承</p>\n</li>\n</ol>\n<p>##ES6类</p>\n<ul>\n<li><p>传统的js中只有对象没有类，它是基于原型的面向对象的语言。原型对象特点就是将自身的属性共享给新对象，如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。</p>\n</li>\n<li><p>ES6加入了类，通过class定义。该关键字出现使其在对象写法上更加清晰。</p>\n</li>\n<li><p>特点</p>\n<ol>\n<li>实质上类就是一个函数，自身指向的就是构造函数</li>\n</ol>\n<pre><code class=\"js\">class Person&#123;\n    \n&#125;\nconsole.log(typeof Person);//function\nconsole.log(Person===Person.prototype.constructor);//true=\n</code></pre>\n<ol start=\"2\">\n<li>类的所有方法都定义在prototype上</li>\n<li>constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用</li>\n<li>constructor不定义也存在，默认返回实例对象this</li>\n<li>constructor中定义的属性可称为实例属性，即定义在this对象上，在它之外定义都是在原型上的</li>\n<li>类的所有实例共享一个原型对象，所以proto属性是相等的。</li>\n<li>class不存在变量提升，需要先定义在使用</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">class 类名&#123; //创建类\n    constructor(name,age)&#123;    //es5的构造函数\n        this.name = name\n        this.age = age\n    &#125;\n    \n    fun1()&#123; &#125; //自定义方法\n&#125;    \n\nvar cls = new 类名(&quot;zs&quot;,12)    //实例化对象\ncls.fun1() //调用类里的方法\n\n\nhasOwnProperty() //判断是否为实例属性\n</code></pre>\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><blockquote>\n<p><strong>其实质是先创造出父类的this对象，然后用子类的构造函数修改this</strong> </p>\n</blockquote>\n<ol>\n<li>extends 要继承的类</li>\n<li>constructor中使用super()获取继承类的属性</li>\n</ol>\n<pre><code class=\"js\">\nclass my extends 要继承的类名 &#123;    //类的继承\n    //如果继承方法同名是不会覆盖的，调用时会按照原型链规则执行\n    super.被继承的方法() //可以调用上级方法\n&#125;\nvar m = new my(&#39;1&#39;,2)//可直接传参\n\n\nclass my extends 要继承的类名&#123;\n    constructor(x,y,z)&#123;\n        super(x,y) //给被继承的类构造函数，确定留几个位置,必需在this前面调用，即使没有参数也要放在前面。\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"js高级02\"><a href=\"#js高级02\" class=\"headerlink\" title=\"js高级02\"></a>js高级02</h1><p>##call</p>\n<ul>\n<li>可改变this指向，会执行函数</li>\n<li>函数.call(this的指向，传参)</li>\n</ul>\n<pre><code class=\"js\">function fn(a,b)&#123;\n    this.a = a\n    this.b = b\n&#125;\n\nvar obj = &#123;\n    \n&#125;\n\nfn.call(obj,10,20) //前面是被调用的函数.(新对象，需要执行的参数)，fn会被执行\n\n\nfunction fn2(a,b,c,d)&#123;\n    fn.call(this,a,b)\n    \n    this.c = c\n    this.d = d\n&#125;\nnew fn2(1,2,3,4);\n</code></pre>\n<p>##继承</p>\n<ol>\n<li><p>原型链继承</p>\n<ul>\n<li>通过修改原型的原型对象，指向要继承的对象或原型，从而实现继承,会造成数据共享的问题。</li>\n</ul>\n</li>\n<li><p>借助构造函数</p>\n<ul>\n<li>在子构造函数中使用call()，apply()来改变this的指向，实现继承,不会造成共享，可以传参，但是函数复用性就没有了,且访问不到父构造函数原型中的方法。</li>\n</ul>\n</li>\n<li><p>组合继承</p>\n<ul>\n<li>用原型链和构造函数结合使用，通过原型链实现属性和方法的继承，然后借用构造函数来实现实例属性的集成。既有函数复用性，有保证都有自己的独立性。但是构造函数会被调用两次</li>\n</ul>\n</li>\n<li><p>原型式继承</p>\n</li>\n<li><p>寄生式继承</p>\n</li>\n<li><p>寄生组合式继承</p>\n</li>\n</ol>\n<p>##ES6类</p>\n<ul>\n<li><p>传统的js中只有对象没有类，它是基于原型的面向对象的语言。原型对象特点就是将自身的属性共享给新对象，如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。</p>\n</li>\n<li><p>ES6加入了类，通过class定义。该关键字出现使其在对象写法上更加清晰。</p>\n</li>\n<li><p>特点</p>\n<ol>\n<li>实质上类就是一个函数，自身指向的就是构造函数</li>\n</ol>\n<pre><code class=\"js\">class Person&#123;\n    \n&#125;\nconsole.log(typeof Person);//function\nconsole.log(Person===Person.prototype.constructor);//true=\n</code></pre>\n<ol start=\"2\">\n<li>类的所有方法都定义在prototype上</li>\n<li>constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用</li>\n<li>constructor不定义也存在，默认返回实例对象this</li>\n<li>constructor中定义的属性可称为实例属性，即定义在this对象上，在它之外定义都是在原型上的</li>\n<li>类的所有实例共享一个原型对象，所以proto属性是相等的。</li>\n<li>class不存在变量提升，需要先定义在使用</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">class 类名&#123; //创建类\n    constructor(name,age)&#123;    //es5的构造函数\n        this.name = name\n        this.age = age\n    &#125;\n    \n    fun1()&#123; &#125; //自定义方法\n&#125;    \n\nvar cls = new 类名(&quot;zs&quot;,12)    //实例化对象\ncls.fun1() //调用类里的方法\n\n\nhasOwnProperty() //判断是否为实例属性\n</code></pre>\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><blockquote>\n<p><strong>其实质是先创造出父类的this对象，然后用子类的构造函数修改this</strong> </p>\n</blockquote>\n<ol>\n<li>extends 要继承的类</li>\n<li>constructor中使用super()获取继承类的属性</li>\n</ol>\n<pre><code class=\"js\">\nclass my extends 要继承的类名 &#123;    //类的继承\n    //如果继承方法同名是不会覆盖的，调用时会按照原型链规则执行\n    super.被继承的方法() //可以调用上级方法\n&#125;\nvar m = new my(&#39;1&#39;,2)//可直接传参\n\n\nclass my extends 要继承的类名&#123;\n    constructor(x,y,z)&#123;\n        super(x,y) //给被继承的类构造函数，确定留几个位置,必需在this前面调用，即使没有参数也要放在前面。\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"jquery-方法3","date":"2017-02-06T04:01:23.000Z","_content":"\n# 03-jquery\n\n## 尺寸和位置\n\n1. 获取高宽\n\n   ```js\n   jq.width() //w，不带px,只能获取\n   jq.height()\n   \n   innerWidth() //w+p\n   innerHieght() \n   \n   outerWidth() // w+p+b\n   outerHieght()\n   \n   outerWidth(true) //w+p+b+m，加上true后包含margin\n   outerHeight(true) \n   \n   ```\n\n2. 位置\n\n   ```js\n   //获取位置，返回的是位置对象里面有位置，只能获取\n   jq.position(); \n   \n   \n   //参考dom设置距离，根据左上角计算\n   jq.offset({\n   \ttop:像素不带px,\n       left:像素不带px\n   }) \n   \n   \n   //当用户滚动滚动条时，触发 scroll 事件。\n   $(window).scroll(function(){ \n       jq.scrollTop()//获取垂直滚动条滚动的距离\n       jq.scrollLeft() //获取水平滚动条滚动的距离\n   }) \n   jq.scrollLeft(200) //将水平滚动条设置到指定位置\n   jq.scrollTop(200)//将垂直滚动条设置指定位置\n   \n   \n   \n   \n   //创建自定义动画\n   jq.stop().animate({\n      样式\n   },时间)\n   \n   ```\n\n   \n\n## 事件\n\n+ 解绑\n\n  ```js\n  //1.全部解绑\n  jq.off()  //移除on绑定的事件\n  jq.unbind();  //移除bind()绑定的事件\n  \n  //2.解绑指定事件\n  jq.off('click') //解除点击事件\n  jq.off('click',\"子元素\") //解除子元素的点击事件\n  \n  //3.一次性事件，只执行一次\n  jq.one('事件'，function(){})\n  ```\n\n+ 触发\n\n  ```js\n  //4.自定义事件\n  jq.trigger('事件，[参数1，参数2]') //触发自定义事件，或者原生事件\n  jq.triggerHandler(\"事件\")\t\n  ```\n\n  + trigger和triggerHandler\n    1. trigger会触发默认行为函数，如表单提交，文本域焦点等。triggerHandler不会触发\n    2. tiggerHandler只会触发jq对象集合的第一个元素事件处理函数，而且不会冒泡，trigger不同。\n\n\n\n## 事件对象\n\n+ jq 对 DOM的事件对象event进行了封装\n\n```js\njq.on('click',function(event){\n    event.stopPropagation() //阻止冒泡\n})\n```\n\n\n\n## 拷贝对象\n\n```js\n//1.合并数据\nvar obj = {}\nvar obj1 = {\n    zs:1\n}\n$.extend(obj,obj1) \nconsole.log(obj.zs)\n\n$.extend(obj2,obj,obj1)   //将3个数据合并\n\n//2.浅拷贝\nvar obj = {\n    zs:4\n}\nvar obj1 = {\n    zs:1\n}\n$.extend(obj,obj1)  //可实现浅拷贝,重复的属性里的数据会被覆盖\n\n\n//3.深拷贝\nvar obj = {\n    zs:4\n    name:['zs']\n}\nvar obj1 = {\n    zs:1\n}\n$.extend(true,obj,obj1)  //将obj里面的属性复制一份给obj1,不冲突则合并，冲突会覆盖\n\n```\n\n\n\n\n\n##多库共存\n\n+ 无冲突处理\n\n  1. jq使用$在为命名空间，可能会与其他库和框架造成冲突\n  2. jq版本不一样，导致不同版本对插件的支持都不一样\n\n+ 解决\n\n  + 让jq 释放对$的控制权，谁用自己决定\n\n    ```js\n    var zs = JQuery.noConflict() //给jq重新定义$\n    ```\n\n\n\n## jq插件\n\n+ jq功能有限，有些复杂特效可以借助插件完成\n+ 这些插件都是依赖jq,所以必须传入jq\n+ 常用网站\n  - jQuery 插件库  http://www.jq22.com/     \n  - jQuery 之家   http://www.htmleaf.com/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/笔记/ocean/06-jquery总结/03-对象尺寸与位置/03-笔记.md","raw":"---\ntitle: jquery-方法3\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- jquery\n- javascript\n---\n\n# 03-jquery\n\n## 尺寸和位置\n\n1. 获取高宽\n\n   ```js\n   jq.width() //w，不带px,只能获取\n   jq.height()\n   \n   innerWidth() //w+p\n   innerHieght() \n   \n   outerWidth() // w+p+b\n   outerHieght()\n   \n   outerWidth(true) //w+p+b+m，加上true后包含margin\n   outerHeight(true) \n   \n   ```\n\n2. 位置\n\n   ```js\n   //获取位置，返回的是位置对象里面有位置，只能获取\n   jq.position(); \n   \n   \n   //参考dom设置距离，根据左上角计算\n   jq.offset({\n   \ttop:像素不带px,\n       left:像素不带px\n   }) \n   \n   \n   //当用户滚动滚动条时，触发 scroll 事件。\n   $(window).scroll(function(){ \n       jq.scrollTop()//获取垂直滚动条滚动的距离\n       jq.scrollLeft() //获取水平滚动条滚动的距离\n   }) \n   jq.scrollLeft(200) //将水平滚动条设置到指定位置\n   jq.scrollTop(200)//将垂直滚动条设置指定位置\n   \n   \n   \n   \n   //创建自定义动画\n   jq.stop().animate({\n      样式\n   },时间)\n   \n   ```\n\n   \n\n## 事件\n\n+ 解绑\n\n  ```js\n  //1.全部解绑\n  jq.off()  //移除on绑定的事件\n  jq.unbind();  //移除bind()绑定的事件\n  \n  //2.解绑指定事件\n  jq.off('click') //解除点击事件\n  jq.off('click',\"子元素\") //解除子元素的点击事件\n  \n  //3.一次性事件，只执行一次\n  jq.one('事件'，function(){})\n  ```\n\n+ 触发\n\n  ```js\n  //4.自定义事件\n  jq.trigger('事件，[参数1，参数2]') //触发自定义事件，或者原生事件\n  jq.triggerHandler(\"事件\")\t\n  ```\n\n  + trigger和triggerHandler\n    1. trigger会触发默认行为函数，如表单提交，文本域焦点等。triggerHandler不会触发\n    2. tiggerHandler只会触发jq对象集合的第一个元素事件处理函数，而且不会冒泡，trigger不同。\n\n\n\n## 事件对象\n\n+ jq 对 DOM的事件对象event进行了封装\n\n```js\njq.on('click',function(event){\n    event.stopPropagation() //阻止冒泡\n})\n```\n\n\n\n## 拷贝对象\n\n```js\n//1.合并数据\nvar obj = {}\nvar obj1 = {\n    zs:1\n}\n$.extend(obj,obj1) \nconsole.log(obj.zs)\n\n$.extend(obj2,obj,obj1)   //将3个数据合并\n\n//2.浅拷贝\nvar obj = {\n    zs:4\n}\nvar obj1 = {\n    zs:1\n}\n$.extend(obj,obj1)  //可实现浅拷贝,重复的属性里的数据会被覆盖\n\n\n//3.深拷贝\nvar obj = {\n    zs:4\n    name:['zs']\n}\nvar obj1 = {\n    zs:1\n}\n$.extend(true,obj,obj1)  //将obj里面的属性复制一份给obj1,不冲突则合并，冲突会覆盖\n\n```\n\n\n\n\n\n##多库共存\n\n+ 无冲突处理\n\n  1. jq使用$在为命名空间，可能会与其他库和框架造成冲突\n  2. jq版本不一样，导致不同版本对插件的支持都不一样\n\n+ 解决\n\n  + 让jq 释放对$的控制权，谁用自己决定\n\n    ```js\n    var zs = JQuery.noConflict() //给jq重新定义$\n    ```\n\n\n\n## jq插件\n\n+ jq功能有限，有些复杂特效可以借助插件完成\n+ 这些插件都是依赖jq,所以必须传入jq\n+ 常用网站\n  - jQuery 插件库  http://www.jq22.com/     \n  - jQuery 之家   http://www.htmleaf.com/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"笔记/ocean/06-jquery总结/03-对象尺寸与位置/03-笔记","published":1,"updated":"2023-03-01T07:00:36.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qcv002tawaf6cu13umx","content":"<h1 id=\"03-jquery\"><a href=\"#03-jquery\" class=\"headerlink\" title=\"03-jquery\"></a>03-jquery</h1><h2 id=\"尺寸和位置\"><a href=\"#尺寸和位置\" class=\"headerlink\" title=\"尺寸和位置\"></a>尺寸和位置</h2><ol>\n<li><p>获取高宽</p>\n<pre><code class=\"js\">jq.width() //w，不带px,只能获取\njq.height()\n\ninnerWidth() //w+p\ninnerHieght() \n\nouterWidth() // w+p+b\nouterHieght()\n\nouterWidth(true) //w+p+b+m，加上true后包含margin\nouterHeight(true) \n</code></pre>\n</li>\n<li><p>位置</p>\n<pre><code class=\"js\">//获取位置，返回的是位置对象里面有位置，只能获取\njq.position(); \n\n\n//参考dom设置距离，根据左上角计算\njq.offset(&#123;\n    top:像素不带px,\n    left:像素不带px\n&#125;) \n\n\n//当用户滚动滚动条时，触发 scroll 事件。\n$(window).scroll(function()&#123; \n    jq.scrollTop()//获取垂直滚动条滚动的距离\n    jq.scrollLeft() //获取水平滚动条滚动的距离\n&#125;) \njq.scrollLeft(200) //将水平滚动条设置到指定位置\njq.scrollTop(200)//将垂直滚动条设置指定位置\n\n\n\n\n//创建自定义动画\njq.stop().animate(&#123;\n   样式\n&#125;,时间)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li><p>解绑</p>\n<pre><code class=\"js\">//1.全部解绑\njq.off()  //移除on绑定的事件\njq.unbind();  //移除bind()绑定的事件\n\n//2.解绑指定事件\njq.off(&#39;click&#39;) //解除点击事件\njq.off(&#39;click&#39;,&quot;子元素&quot;) //解除子元素的点击事件\n\n//3.一次性事件，只执行一次\njq.one(&#39;事件&#39;，function()&#123;&#125;)\n</code></pre>\n</li>\n<li><p>触发</p>\n<pre><code class=\"js\">//4.自定义事件\njq.trigger(&#39;事件，[参数1，参数2]&#39;) //触发自定义事件，或者原生事件\njq.triggerHandler(&quot;事件&quot;)    \n</code></pre>\n<ul>\n<li>trigger和triggerHandler<ol>\n<li>trigger会触发默认行为函数，如表单提交，文本域焦点等。triggerHandler不会触发</li>\n<li>tiggerHandler只会触发jq对象集合的第一个元素事件处理函数，而且不会冒泡，trigger不同。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><ul>\n<li>jq 对 DOM的事件对象event进行了封装</li>\n</ul>\n<pre><code class=\"js\">jq.on(&#39;click&#39;,function(event)&#123;\n    event.stopPropagation() //阻止冒泡\n&#125;)\n</code></pre>\n<h2 id=\"拷贝对象\"><a href=\"#拷贝对象\" class=\"headerlink\" title=\"拷贝对象\"></a>拷贝对象</h2><pre><code class=\"js\">//1.合并数据\nvar obj = &#123;&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(obj,obj1) \nconsole.log(obj.zs)\n\n$.extend(obj2,obj,obj1)   //将3个数据合并\n\n//2.浅拷贝\nvar obj = &#123;\n    zs:4\n&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(obj,obj1)  //可实现浅拷贝,重复的属性里的数据会被覆盖\n\n\n//3.深拷贝\nvar obj = &#123;\n    zs:4\n    name:[&#39;zs&#39;]\n&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(true,obj,obj1)  //将obj里面的属性复制一份给obj1,不冲突则合并，冲突会覆盖\n</code></pre>\n<p>##多库共存</p>\n<ul>\n<li><p>无冲突处理</p>\n<ol>\n<li>jq使用$在为命名空间，可能会与其他库和框架造成冲突</li>\n<li>jq版本不一样，导致不同版本对插件的支持都不一样</li>\n</ol>\n</li>\n<li><p>解决</p>\n<ul>\n<li><p>让jq 释放对$的控制权，谁用自己决定</p>\n<pre><code class=\"js\">var zs = JQuery.noConflict() //给jq重新定义$\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jq插件\"><a href=\"#jq插件\" class=\"headerlink\" title=\"jq插件\"></a>jq插件</h2><ul>\n<li>jq功能有限，有些复杂特效可以借助插件完成</li>\n<li>这些插件都是依赖jq,所以必须传入jq</li>\n<li>常用网站<ul>\n<li>jQuery 插件库  <a href=\"http://www.jq22.com/\">http://www.jq22.com/</a>     </li>\n<li>jQuery 之家   <a href=\"http://www.htmleaf.com/\">http://www.htmleaf.com/</a> </li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-jquery\"><a href=\"#03-jquery\" class=\"headerlink\" title=\"03-jquery\"></a>03-jquery</h1><h2 id=\"尺寸和位置\"><a href=\"#尺寸和位置\" class=\"headerlink\" title=\"尺寸和位置\"></a>尺寸和位置</h2><ol>\n<li><p>获取高宽</p>\n<pre><code class=\"js\">jq.width() //w，不带px,只能获取\njq.height()\n\ninnerWidth() //w+p\ninnerHieght() \n\nouterWidth() // w+p+b\nouterHieght()\n\nouterWidth(true) //w+p+b+m，加上true后包含margin\nouterHeight(true) \n</code></pre>\n</li>\n<li><p>位置</p>\n<pre><code class=\"js\">//获取位置，返回的是位置对象里面有位置，只能获取\njq.position(); \n\n\n//参考dom设置距离，根据左上角计算\njq.offset(&#123;\n    top:像素不带px,\n    left:像素不带px\n&#125;) \n\n\n//当用户滚动滚动条时，触发 scroll 事件。\n$(window).scroll(function()&#123; \n    jq.scrollTop()//获取垂直滚动条滚动的距离\n    jq.scrollLeft() //获取水平滚动条滚动的距离\n&#125;) \njq.scrollLeft(200) //将水平滚动条设置到指定位置\njq.scrollTop(200)//将垂直滚动条设置指定位置\n\n\n\n\n//创建自定义动画\njq.stop().animate(&#123;\n   样式\n&#125;,时间)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li><p>解绑</p>\n<pre><code class=\"js\">//1.全部解绑\njq.off()  //移除on绑定的事件\njq.unbind();  //移除bind()绑定的事件\n\n//2.解绑指定事件\njq.off(&#39;click&#39;) //解除点击事件\njq.off(&#39;click&#39;,&quot;子元素&quot;) //解除子元素的点击事件\n\n//3.一次性事件，只执行一次\njq.one(&#39;事件&#39;，function()&#123;&#125;)\n</code></pre>\n</li>\n<li><p>触发</p>\n<pre><code class=\"js\">//4.自定义事件\njq.trigger(&#39;事件，[参数1，参数2]&#39;) //触发自定义事件，或者原生事件\njq.triggerHandler(&quot;事件&quot;)    \n</code></pre>\n<ul>\n<li>trigger和triggerHandler<ol>\n<li>trigger会触发默认行为函数，如表单提交，文本域焦点等。triggerHandler不会触发</li>\n<li>tiggerHandler只会触发jq对象集合的第一个元素事件处理函数，而且不会冒泡，trigger不同。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><ul>\n<li>jq 对 DOM的事件对象event进行了封装</li>\n</ul>\n<pre><code class=\"js\">jq.on(&#39;click&#39;,function(event)&#123;\n    event.stopPropagation() //阻止冒泡\n&#125;)\n</code></pre>\n<h2 id=\"拷贝对象\"><a href=\"#拷贝对象\" class=\"headerlink\" title=\"拷贝对象\"></a>拷贝对象</h2><pre><code class=\"js\">//1.合并数据\nvar obj = &#123;&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(obj,obj1) \nconsole.log(obj.zs)\n\n$.extend(obj2,obj,obj1)   //将3个数据合并\n\n//2.浅拷贝\nvar obj = &#123;\n    zs:4\n&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(obj,obj1)  //可实现浅拷贝,重复的属性里的数据会被覆盖\n\n\n//3.深拷贝\nvar obj = &#123;\n    zs:4\n    name:[&#39;zs&#39;]\n&#125;\nvar obj1 = &#123;\n    zs:1\n&#125;\n$.extend(true,obj,obj1)  //将obj里面的属性复制一份给obj1,不冲突则合并，冲突会覆盖\n</code></pre>\n<p>##多库共存</p>\n<ul>\n<li><p>无冲突处理</p>\n<ol>\n<li>jq使用$在为命名空间，可能会与其他库和框架造成冲突</li>\n<li>jq版本不一样，导致不同版本对插件的支持都不一样</li>\n</ol>\n</li>\n<li><p>解决</p>\n<ul>\n<li><p>让jq 释放对$的控制权，谁用自己决定</p>\n<pre><code class=\"js\">var zs = JQuery.noConflict() //给jq重新定义$\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jq插件\"><a href=\"#jq插件\" class=\"headerlink\" title=\"jq插件\"></a>jq插件</h2><ul>\n<li>jq功能有限，有些复杂特效可以借助插件完成</li>\n<li>这些插件都是依赖jq,所以必须传入jq</li>\n<li>常用网站<ul>\n<li>jQuery 插件库  <a href=\"http://www.jq22.com/\">http://www.jq22.com/</a>     </li>\n<li>jQuery 之家   <a href=\"http://www.htmleaf.com/\">http://www.htmleaf.com/</a> </li>\n</ul>\n</li>\n</ul>\n"},{"title":"ajax","date":"2017-02-06T04:01:23.000Z","_content":"\n# ajax\t\n\n## 网站\n\n将网页代码上传到服务器，并能通过域名或ip访问，它就是网站\n\n+ 静态网站\n  + 提前写好的网站，没有后台服务器的交互支持，不能实时更新数据。\n\n+ 动态网站\n  + 使用后端语言进行前后端交互，网页的数据是从服务器中动态获取到的。\n\n  ### url\n\n  ulr是统一资源定位符，资源类型有很多；\n\n  url地址 = 协议 + 域名 + 路径\n\n## 什么是ajax\n\n+ 即异步的( Asynchronous) + JavaScript 和 XML，是一种用于创建快速动态网页的技术；使用AJAX则不需要加载更新整个网页，实现部分内容更新\n+ 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。\n+ 本身不是一个新技术，是2005年Jesse James Garrett提出的新术语，用来描述一种使用现有拘束集合的’新‘方法，包括HTML,XHTML,CSS,javaScript,DOM,XML,XSLT以及XMLHttpRequest.\n+ 尽管X在AJAX中代表XML，但是JSON的许多优势，不如更轻量以及作为javascrit的一部分，目前JSON比XML更加普遍。\n\n### 知识点\n\n1. XMLHttpRequer \n   + 它是Ajax的核心，用于与服务器进行交互，通过这个对象可以在不刷新页面的情况下请求特定URL,获取数据。\n   + 它可用于获取任何数据类型，不仅仅是XML，更多出于安全等级原因的限制\n   + XMLHttpRequest的过程是以异步进行的，当open()的第三个参数设置为false时，他就会已同步进行。\n\n\n\n## get和post\n\n+ get  和 post 区别 \n\n  + get //主要获取服务器的资源数据，通过url传参\t\t\n  + post 主要是向指定的资源提交要被处理的数据\n  + 区别：\n\n  1. url可见性：get参数url可见，post url不可见\n\n  2. 数据传输：get,通过拼接url进行传参，post 通过body体传输\n\n  3. 缓存性：get请求是可缓存的，post不可缓存\n\n  4. 后退页面：get后退时，不产生影响，post后重新提交\n\n  5. 传输大小：get传输数据不超过2k-4k，浏览器不同限制不同\n\n     ​\t\t    post传输数据大小由php.ini配置文件设定，所以可无限制。\n\n  6. 6.安全性：原则上post比get安全，毕竟传参url不可见，但是抓包会抓到\n\n\n\n## jquery中的ajax\n\n```js\n基于jq的三个方法\n$.get('url地址',地址的参数，function(){\n      \n      })\n$.post('url地址',地址的参数，function(){})\n$.ajax({\n    url:'',\n    type:\"get\",\n    success:function(res){\n        \n    }\n})\n```\n\n## 接口\n\n后端需要给前端接口文档 \n\n指的是API：程序员与计算机的对接\n\n,或者URL：前后端对接\n\n\n\n## 调试工具\n\nPostman 验证接口是否正常。\n\n\n\n## 图书管理案例\n\n+ 实现的功能\n  + 查询，删除，添加，并渲染到html页面\n\n+ 接口\n\n  + http://www.liulongbin.top:3006\n\n    \n\n  + 查询\n\n    + 接口：get:  /api/getbooks\n\n    |  参数名   |  类型  |   说明   |\n    | :-------: | :----: | :------: |\n    |    id     | Number |  图书id  |\n    | bookname  | String | 图书名称 |\n    |  author   | String |   作者   |\n    | publisher | String |  出版社  |\n\n  + 添加\n    + 接口：post : /api/addbook\n\n  |  参数名   |  类型  |   说明   |\n  | :-------: | :----: | :------: |\n  |    id     | Number |  图书id  |\n  | bookname  | String | 图书名称 |\n  |  author   | String |   作者   |\n  | publisher | String |  出版社  |\n\n  \n\n  + 删除\n\n    + 接口：get : /api/delbook\n\n      | 参数名 | 类型   | 说明   |\n      | ------ | ------ | ------ |\n      | id     | Number | 图书id |\n\n\n","source":"_posts/笔记/ocean/07-Ajax总结/01-jq中的ajax/01-ajax笔记.md","raw":"---\ntitle: ajax\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- ajax\n- javascript\n---\n\n# ajax\t\n\n## 网站\n\n将网页代码上传到服务器，并能通过域名或ip访问，它就是网站\n\n+ 静态网站\n  + 提前写好的网站，没有后台服务器的交互支持，不能实时更新数据。\n\n+ 动态网站\n  + 使用后端语言进行前后端交互，网页的数据是从服务器中动态获取到的。\n\n  ### url\n\n  ulr是统一资源定位符，资源类型有很多；\n\n  url地址 = 协议 + 域名 + 路径\n\n## 什么是ajax\n\n+ 即异步的( Asynchronous) + JavaScript 和 XML，是一种用于创建快速动态网页的技术；使用AJAX则不需要加载更新整个网页，实现部分内容更新\n+ 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。\n+ 本身不是一个新技术，是2005年Jesse James Garrett提出的新术语，用来描述一种使用现有拘束集合的’新‘方法，包括HTML,XHTML,CSS,javaScript,DOM,XML,XSLT以及XMLHttpRequest.\n+ 尽管X在AJAX中代表XML，但是JSON的许多优势，不如更轻量以及作为javascrit的一部分，目前JSON比XML更加普遍。\n\n### 知识点\n\n1. XMLHttpRequer \n   + 它是Ajax的核心，用于与服务器进行交互，通过这个对象可以在不刷新页面的情况下请求特定URL,获取数据。\n   + 它可用于获取任何数据类型，不仅仅是XML，更多出于安全等级原因的限制\n   + XMLHttpRequest的过程是以异步进行的，当open()的第三个参数设置为false时，他就会已同步进行。\n\n\n\n## get和post\n\n+ get  和 post 区别 \n\n  + get //主要获取服务器的资源数据，通过url传参\t\t\n  + post 主要是向指定的资源提交要被处理的数据\n  + 区别：\n\n  1. url可见性：get参数url可见，post url不可见\n\n  2. 数据传输：get,通过拼接url进行传参，post 通过body体传输\n\n  3. 缓存性：get请求是可缓存的，post不可缓存\n\n  4. 后退页面：get后退时，不产生影响，post后重新提交\n\n  5. 传输大小：get传输数据不超过2k-4k，浏览器不同限制不同\n\n     ​\t\t    post传输数据大小由php.ini配置文件设定，所以可无限制。\n\n  6. 6.安全性：原则上post比get安全，毕竟传参url不可见，但是抓包会抓到\n\n\n\n## jquery中的ajax\n\n```js\n基于jq的三个方法\n$.get('url地址',地址的参数，function(){\n      \n      })\n$.post('url地址',地址的参数，function(){})\n$.ajax({\n    url:'',\n    type:\"get\",\n    success:function(res){\n        \n    }\n})\n```\n\n## 接口\n\n后端需要给前端接口文档 \n\n指的是API：程序员与计算机的对接\n\n,或者URL：前后端对接\n\n\n\n## 调试工具\n\nPostman 验证接口是否正常。\n\n\n\n## 图书管理案例\n\n+ 实现的功能\n  + 查询，删除，添加，并渲染到html页面\n\n+ 接口\n\n  + http://www.liulongbin.top:3006\n\n    \n\n  + 查询\n\n    + 接口：get:  /api/getbooks\n\n    |  参数名   |  类型  |   说明   |\n    | :-------: | :----: | :------: |\n    |    id     | Number |  图书id  |\n    | bookname  | String | 图书名称 |\n    |  author   | String |   作者   |\n    | publisher | String |  出版社  |\n\n  + 添加\n    + 接口：post : /api/addbook\n\n  |  参数名   |  类型  |   说明   |\n  | :-------: | :----: | :------: |\n  |    id     | Number |  图书id  |\n  | bookname  | String | 图书名称 |\n  |  author   | String |   作者   |\n  | publisher | String |  出版社  |\n\n  \n\n  + 删除\n\n    + 接口：get : /api/delbook\n\n      | 参数名 | 类型   | 说明   |\n      | ------ | ------ | ------ |\n      | id     | Number | 图书id |\n\n\n","slug":"笔记/ocean/07-Ajax总结/01-jq中的ajax/01-ajax笔记","published":1,"updated":"2023-03-01T07:01:02.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe2009yawafhe1mg2zc","content":"<h1 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h1><h2 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h2><p>将网页代码上传到服务器，并能通过域名或ip访问，它就是网站</p>\n<ul>\n<li><p>静态网站</p>\n<ul>\n<li>提前写好的网站，没有后台服务器的交互支持，不能实时更新数据。</li>\n</ul>\n</li>\n<li><p>动态网站</p>\n<ul>\n<li>使用后端语言进行前后端交互，网页的数据是从服务器中动态获取到的。</li>\n</ul>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><p>ulr是统一资源定位符，资源类型有很多；</p>\n<p>url地址 = 协议 + 域名 + 路径</p>\n</li>\n</ul>\n<h2 id=\"什么是ajax\"><a href=\"#什么是ajax\" class=\"headerlink\" title=\"什么是ajax\"></a>什么是ajax</h2><ul>\n<li>即异步的( Asynchronous) + JavaScript 和 XML，是一种用于创建快速动态网页的技术；使用AJAX则不需要加载更新整个网页，实现部分内容更新</li>\n<li>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</li>\n<li>本身不是一个新技术，是2005年Jesse James Garrett提出的新术语，用来描述一种使用现有拘束集合的’新‘方法，包括HTML,XHTML,CSS,javaScript,DOM,XML,XSLT以及XMLHttpRequest.</li>\n<li>尽管X在AJAX中代表XML，但是JSON的许多优势，不如更轻量以及作为javascrit的一部分，目前JSON比XML更加普遍。</li>\n</ul>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li>XMLHttpRequer <ul>\n<li>它是Ajax的核心，用于与服务器进行交互，通过这个对象可以在不刷新页面的情况下请求特定URL,获取数据。</li>\n<li>它可用于获取任何数据类型，不仅仅是XML，更多出于安全等级原因的限制</li>\n<li>XMLHttpRequest的过程是以异步进行的，当open()的第三个参数设置为false时，他就会已同步进行。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"get和post\"><a href=\"#get和post\" class=\"headerlink\" title=\"get和post\"></a>get和post</h2><ul>\n<li><p>get  和 post 区别 </p>\n<ul>\n<li>get //主要获取服务器的资源数据，通过url传参        </li>\n<li>post 主要是向指定的资源提交要被处理的数据</li>\n<li>区别：</li>\n</ul>\n<ol>\n<li><p>url可见性：get参数url可见，post url不可见</p>\n</li>\n<li><p>数据传输：get,通过拼接url进行传参，post 通过body体传输</p>\n</li>\n<li><p>缓存性：get请求是可缓存的，post不可缓存</p>\n</li>\n<li><p>后退页面：get后退时，不产生影响，post后重新提交</p>\n</li>\n<li><p>传输大小：get传输数据不超过2k-4k，浏览器不同限制不同</p>\n<p>​            post传输数据大小由php.ini配置文件设定，所以可无限制。</p>\n</li>\n<li><p>6.安全性：原则上post比get安全，毕竟传参url不可见，但是抓包会抓到</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"jquery中的ajax\"><a href=\"#jquery中的ajax\" class=\"headerlink\" title=\"jquery中的ajax\"></a>jquery中的ajax</h2><pre><code class=\"js\">基于jq的三个方法\n$.get(&#39;url地址&#39;,地址的参数，function()&#123;\n      \n      &#125;)\n$.post(&#39;url地址&#39;,地址的参数，function()&#123;&#125;)\n$.ajax(&#123;\n    url:&#39;&#39;,\n    type:&quot;get&quot;,\n    success:function(res)&#123;\n        \n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>后端需要给前端接口文档 </p>\n<p>指的是API：程序员与计算机的对接</p>\n<p>,或者URL：前后端对接</p>\n<h2 id=\"调试工具\"><a href=\"#调试工具\" class=\"headerlink\" title=\"调试工具\"></a>调试工具</h2><p>Postman 验证接口是否正常。</p>\n<h2 id=\"图书管理案例\"><a href=\"#图书管理案例\" class=\"headerlink\" title=\"图书管理案例\"></a>图书管理案例</h2><ul>\n<li><p>实现的功能</p>\n<ul>\n<li>查询，删除，添加，并渲染到html页面</li>\n</ul>\n</li>\n<li><p>接口</p>\n<ul>\n<li><p><a href=\"http://www.liulongbin.top:3006/\">http://www.liulongbin.top:3006</a></p>\n</li>\n<li><p>查询</p>\n<ul>\n<li>接口：get:  /api/getbooks</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">Number</td>\n<td align=\"center\">图书id</td>\n</tr>\n<tr>\n<td align=\"center\">bookname</td>\n<td align=\"center\">String</td>\n<td align=\"center\">图书名称</td>\n</tr>\n<tr>\n<td align=\"center\">author</td>\n<td align=\"center\">String</td>\n<td align=\"center\">作者</td>\n</tr>\n<tr>\n<td align=\"center\">publisher</td>\n<td align=\"center\">String</td>\n<td align=\"center\">出版社</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>添加</p>\n<ul>\n<li>接口：post : /api/addbook</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">Number</td>\n<td align=\"center\">图书id</td>\n</tr>\n<tr>\n<td align=\"center\">bookname</td>\n<td align=\"center\">String</td>\n<td align=\"center\">图书名称</td>\n</tr>\n<tr>\n<td align=\"center\">author</td>\n<td align=\"center\">String</td>\n<td align=\"center\">作者</td>\n</tr>\n<tr>\n<td align=\"center\">publisher</td>\n<td align=\"center\">String</td>\n<td align=\"center\">出版社</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>删除</p>\n<ul>\n<li><p>接口：get : /api/delbook</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>Number</td>\n<td>图书id</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h1><h2 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h2><p>将网页代码上传到服务器，并能通过域名或ip访问，它就是网站</p>\n<ul>\n<li><p>静态网站</p>\n<ul>\n<li>提前写好的网站，没有后台服务器的交互支持，不能实时更新数据。</li>\n</ul>\n</li>\n<li><p>动态网站</p>\n<ul>\n<li>使用后端语言进行前后端交互，网页的数据是从服务器中动态获取到的。</li>\n</ul>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><p>ulr是统一资源定位符，资源类型有很多；</p>\n<p>url地址 = 协议 + 域名 + 路径</p>\n</li>\n</ul>\n<h2 id=\"什么是ajax\"><a href=\"#什么是ajax\" class=\"headerlink\" title=\"什么是ajax\"></a>什么是ajax</h2><ul>\n<li>即异步的( Asynchronous) + JavaScript 和 XML，是一种用于创建快速动态网页的技术；使用AJAX则不需要加载更新整个网页，实现部分内容更新</li>\n<li>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</li>\n<li>本身不是一个新技术，是2005年Jesse James Garrett提出的新术语，用来描述一种使用现有拘束集合的’新‘方法，包括HTML,XHTML,CSS,javaScript,DOM,XML,XSLT以及XMLHttpRequest.</li>\n<li>尽管X在AJAX中代表XML，但是JSON的许多优势，不如更轻量以及作为javascrit的一部分，目前JSON比XML更加普遍。</li>\n</ul>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li>XMLHttpRequer <ul>\n<li>它是Ajax的核心，用于与服务器进行交互，通过这个对象可以在不刷新页面的情况下请求特定URL,获取数据。</li>\n<li>它可用于获取任何数据类型，不仅仅是XML，更多出于安全等级原因的限制</li>\n<li>XMLHttpRequest的过程是以异步进行的，当open()的第三个参数设置为false时，他就会已同步进行。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"get和post\"><a href=\"#get和post\" class=\"headerlink\" title=\"get和post\"></a>get和post</h2><ul>\n<li><p>get  和 post 区别 </p>\n<ul>\n<li>get //主要获取服务器的资源数据，通过url传参        </li>\n<li>post 主要是向指定的资源提交要被处理的数据</li>\n<li>区别：</li>\n</ul>\n<ol>\n<li><p>url可见性：get参数url可见，post url不可见</p>\n</li>\n<li><p>数据传输：get,通过拼接url进行传参，post 通过body体传输</p>\n</li>\n<li><p>缓存性：get请求是可缓存的，post不可缓存</p>\n</li>\n<li><p>后退页面：get后退时，不产生影响，post后重新提交</p>\n</li>\n<li><p>传输大小：get传输数据不超过2k-4k，浏览器不同限制不同</p>\n<p>​            post传输数据大小由php.ini配置文件设定，所以可无限制。</p>\n</li>\n<li><p>6.安全性：原则上post比get安全，毕竟传参url不可见，但是抓包会抓到</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"jquery中的ajax\"><a href=\"#jquery中的ajax\" class=\"headerlink\" title=\"jquery中的ajax\"></a>jquery中的ajax</h2><pre><code class=\"js\">基于jq的三个方法\n$.get(&#39;url地址&#39;,地址的参数，function()&#123;\n      \n      &#125;)\n$.post(&#39;url地址&#39;,地址的参数，function()&#123;&#125;)\n$.ajax(&#123;\n    url:&#39;&#39;,\n    type:&quot;get&quot;,\n    success:function(res)&#123;\n        \n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>后端需要给前端接口文档 </p>\n<p>指的是API：程序员与计算机的对接</p>\n<p>,或者URL：前后端对接</p>\n<h2 id=\"调试工具\"><a href=\"#调试工具\" class=\"headerlink\" title=\"调试工具\"></a>调试工具</h2><p>Postman 验证接口是否正常。</p>\n<h2 id=\"图书管理案例\"><a href=\"#图书管理案例\" class=\"headerlink\" title=\"图书管理案例\"></a>图书管理案例</h2><ul>\n<li><p>实现的功能</p>\n<ul>\n<li>查询，删除，添加，并渲染到html页面</li>\n</ul>\n</li>\n<li><p>接口</p>\n<ul>\n<li><p><a href=\"http://www.liulongbin.top:3006/\">http://www.liulongbin.top:3006</a></p>\n</li>\n<li><p>查询</p>\n<ul>\n<li>接口：get:  /api/getbooks</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">Number</td>\n<td align=\"center\">图书id</td>\n</tr>\n<tr>\n<td align=\"center\">bookname</td>\n<td align=\"center\">String</td>\n<td align=\"center\">图书名称</td>\n</tr>\n<tr>\n<td align=\"center\">author</td>\n<td align=\"center\">String</td>\n<td align=\"center\">作者</td>\n</tr>\n<tr>\n<td align=\"center\">publisher</td>\n<td align=\"center\">String</td>\n<td align=\"center\">出版社</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>添加</p>\n<ul>\n<li>接口：post : /api/addbook</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">Number</td>\n<td align=\"center\">图书id</td>\n</tr>\n<tr>\n<td align=\"center\">bookname</td>\n<td align=\"center\">String</td>\n<td align=\"center\">图书名称</td>\n</tr>\n<tr>\n<td align=\"center\">author</td>\n<td align=\"center\">String</td>\n<td align=\"center\">作者</td>\n</tr>\n<tr>\n<td align=\"center\">publisher</td>\n<td align=\"center\">String</td>\n<td align=\"center\">出版社</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>删除</p>\n<ul>\n<li><p>接口：get : /api/delbook</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>Number</td>\n<td>图书id</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"jquery-方法1","date":"2017-02-06T04:01:23.000Z","_content":"\n# 01-jquery\n\n## 概念\n\n> jq（javascript query）是一个快速简介的javaScript库，其设计的宗旨是\"write Less,Do More\",倡导写更少的代码，做更多的事情,本质就是将js中的DOM操作进行了封装，可以快速使用其功能。\n\n+ jq的顶级对象是$ 和 Jquery,所以不能使用原生对象上的方法和属性\n\n### 两大特性\n\n+ 隐式迭代\n\n  在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 \n\n+ 链式编程\n\n  任意的设置形操作后都可以继续操作当前对象。\n\n## 查\n\n+ \n\n```js\n//如果jq对象要获取原生dom对象，使用.get(下标)\n$(原生dom节点)  //将原生dom节点转为jq对象\n\n$('li').filter();//获取第一个元素\n$('li:eq()') //选择特定位置的对象\n$('li:odd') //获取下标为基数的元素\n$('li:even') //偶数\n```\n\n##方法\n\n```js\njq.parent() //获取的是jq对象的上级父级\njq.parents('') //可以获取所有的父级，里面的参数是指定的css选择器，如果有参数就可以获取指定父级。\n\njq.children('') //获取jq的子代元素,有参数后可以获取指定的子代元素。\njq.find('') //获取jq的所有的后代元素,参数是后代的css选择器\n\njq.siblings('') //获取的是除自己以外的兄弟元素,参数是获取指定css选择器\njq.nextAll() //获取某个jq对象后面的 所有兄弟\njq.show() //显示\njq.hidde() //隐藏\njq.index() //直接返回自己的下标\n```\n\n## 绑定事件\n\n```js\n\n1.jq.on('click',function(){   })\t//最常用的方式\n2.jq.click(function(){  })\n3.jq.delegate('css选择器','事件',function(){\t}) //支持动态创建的元素\n4.jq.bind('事件1 事件2'，function(){  })\t//不推荐1.7版后被on取代\n```\n\n## 类名\n\n```js\n$('li').addClass(\"类名\"); //添加类名\n$('li').removeClass('类名') //移除类名\n$('li').toggleClass('类名') //切换类名\n$('li').hasClass('类名') //用于判断jq对象有没有指定的类名\n```\n\n## 样式\n\n```js\n$('.aa').css('属性名') //获取css样式，属性名驼峰，不区分行内外。\n```\n\n\n\n## 动画\n\n+ 显示隐藏\n\n  ```js\n  jq.show(时间，速度曲线，执行完毕后执行的函数)\n  jq.hide() //和上述一样\n  jq.toggle() // 也一样\n  ```\n\n+ 滑动\n\n  ```js\n  jq.slideDown()//滑动\n  jq.slideUp()\t//滑动\n  jq.slideToggle() //滑动\n  ```\n\n+ 移入移出\n\n  ```js\n  jq.hover(function(){},function(){}) //鼠标移入和移出都执行这个函数,效果相当于mouseenter和mouseleave\n  ```\n\n+ 停止动画\n\n  ```js\n  jq.stop() //用来停止事件,加在动画的前面\n  ```\n\n+ 淡入淡出\n\n  ```js\n  jq.fadeIn() //淡入\n  jq.fadeOut() //淡出\n  jq.fadeToggle() //淡入淡出切换\n  jq.fadeTo(时间,0.3) //淡出透明\n  ```\n\n+ 自定义动画\n\n  ```js\n  animate(params,[speed],[callback])\n  \n  参数：\n  1.paramas：表示一个包含属性和值的映射，可以同时包含多个属性\n  2.speed：表示动画运行的适度，参数规则同其他动画效果的speed一致，它是一个可选参数\n  3.callback：表示一个回调函数，当动画效果运行完毕后执行该回调函数，它也是一个可选参数\n  \n  注意：\n   元素必须设置定位，元素才能动起来\n  \n  jq.animate({\n      width:\"400px\",\n      backgroundColor:\"color\",\n      css样式，-\n      borderRadius:50%,\n  })\n  ```\n\n## 加载\n\n```js\n//dom节点渲染完毕后执行\n$(document).ready(function(){\n\n})\n\n简写：\n$(function(){\n\n})\n```\n\n+ window.onload()和$(document).ready的区别\n  1. onload必须等页面全部加载完后(图片等)在执行，ready网页中dom结构加载完毕执行\n  2. onload只能执行一次，第二次会将第一次的覆盖，ready可执行多次，不会被覆盖\n\n\n\n","source":"_posts/笔记/ocean/06-jquery总结/01-方法和事件和类/01-笔记.md","raw":"---\ntitle: jquery-方法1\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- jquery\n- javascript\n---\n\n# 01-jquery\n\n## 概念\n\n> jq（javascript query）是一个快速简介的javaScript库，其设计的宗旨是\"write Less,Do More\",倡导写更少的代码，做更多的事情,本质就是将js中的DOM操作进行了封装，可以快速使用其功能。\n\n+ jq的顶级对象是$ 和 Jquery,所以不能使用原生对象上的方法和属性\n\n### 两大特性\n\n+ 隐式迭代\n\n  在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 \n\n+ 链式编程\n\n  任意的设置形操作后都可以继续操作当前对象。\n\n## 查\n\n+ \n\n```js\n//如果jq对象要获取原生dom对象，使用.get(下标)\n$(原生dom节点)  //将原生dom节点转为jq对象\n\n$('li').filter();//获取第一个元素\n$('li:eq()') //选择特定位置的对象\n$('li:odd') //获取下标为基数的元素\n$('li:even') //偶数\n```\n\n##方法\n\n```js\njq.parent() //获取的是jq对象的上级父级\njq.parents('') //可以获取所有的父级，里面的参数是指定的css选择器，如果有参数就可以获取指定父级。\n\njq.children('') //获取jq的子代元素,有参数后可以获取指定的子代元素。\njq.find('') //获取jq的所有的后代元素,参数是后代的css选择器\n\njq.siblings('') //获取的是除自己以外的兄弟元素,参数是获取指定css选择器\njq.nextAll() //获取某个jq对象后面的 所有兄弟\njq.show() //显示\njq.hidde() //隐藏\njq.index() //直接返回自己的下标\n```\n\n## 绑定事件\n\n```js\n\n1.jq.on('click',function(){   })\t//最常用的方式\n2.jq.click(function(){  })\n3.jq.delegate('css选择器','事件',function(){\t}) //支持动态创建的元素\n4.jq.bind('事件1 事件2'，function(){  })\t//不推荐1.7版后被on取代\n```\n\n## 类名\n\n```js\n$('li').addClass(\"类名\"); //添加类名\n$('li').removeClass('类名') //移除类名\n$('li').toggleClass('类名') //切换类名\n$('li').hasClass('类名') //用于判断jq对象有没有指定的类名\n```\n\n## 样式\n\n```js\n$('.aa').css('属性名') //获取css样式，属性名驼峰，不区分行内外。\n```\n\n\n\n## 动画\n\n+ 显示隐藏\n\n  ```js\n  jq.show(时间，速度曲线，执行完毕后执行的函数)\n  jq.hide() //和上述一样\n  jq.toggle() // 也一样\n  ```\n\n+ 滑动\n\n  ```js\n  jq.slideDown()//滑动\n  jq.slideUp()\t//滑动\n  jq.slideToggle() //滑动\n  ```\n\n+ 移入移出\n\n  ```js\n  jq.hover(function(){},function(){}) //鼠标移入和移出都执行这个函数,效果相当于mouseenter和mouseleave\n  ```\n\n+ 停止动画\n\n  ```js\n  jq.stop() //用来停止事件,加在动画的前面\n  ```\n\n+ 淡入淡出\n\n  ```js\n  jq.fadeIn() //淡入\n  jq.fadeOut() //淡出\n  jq.fadeToggle() //淡入淡出切换\n  jq.fadeTo(时间,0.3) //淡出透明\n  ```\n\n+ 自定义动画\n\n  ```js\n  animate(params,[speed],[callback])\n  \n  参数：\n  1.paramas：表示一个包含属性和值的映射，可以同时包含多个属性\n  2.speed：表示动画运行的适度，参数规则同其他动画效果的speed一致，它是一个可选参数\n  3.callback：表示一个回调函数，当动画效果运行完毕后执行该回调函数，它也是一个可选参数\n  \n  注意：\n   元素必须设置定位，元素才能动起来\n  \n  jq.animate({\n      width:\"400px\",\n      backgroundColor:\"color\",\n      css样式，-\n      borderRadius:50%,\n  })\n  ```\n\n## 加载\n\n```js\n//dom节点渲染完毕后执行\n$(document).ready(function(){\n\n})\n\n简写：\n$(function(){\n\n})\n```\n\n+ window.onload()和$(document).ready的区别\n  1. onload必须等页面全部加载完后(图片等)在执行，ready网页中dom结构加载完毕执行\n  2. onload只能执行一次，第二次会将第一次的覆盖，ready可执行多次，不会被覆盖\n\n\n\n","slug":"笔记/ocean/06-jquery总结/01-方法和事件和类/01-笔记","published":1,"updated":"2023-03-01T07:00:02.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe2009zawaf60znde3v","content":"<h1 id=\"01-jquery\"><a href=\"#01-jquery\" class=\"headerlink\" title=\"01-jquery\"></a>01-jquery</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>jq（javascript query）是一个快速简介的javaScript库，其设计的宗旨是”write Less,Do More”,倡导写更少的代码，做更多的事情,本质就是将js中的DOM操作进行了封装，可以快速使用其功能。</p>\n</blockquote>\n<ul>\n<li>jq的顶级对象是$ 和 Jquery,所以不能使用原生对象上的方法和属性</li>\n</ul>\n<h3 id=\"两大特性\"><a href=\"#两大特性\" class=\"headerlink\" title=\"两大特性\"></a>两大特性</h3><ul>\n<li><p>隐式迭代</p>\n<p>在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 </p>\n</li>\n<li><p>链式编程</p>\n<p>任意的设置形操作后都可以继续操作当前对象。</p>\n</li>\n</ul>\n<h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><ul>\n<li></li>\n</ul>\n<pre><code class=\"js\">//如果jq对象要获取原生dom对象，使用.get(下标)\n$(原生dom节点)  //将原生dom节点转为jq对象\n\n$(&#39;li&#39;).filter();//获取第一个元素\n$(&#39;li:eq()&#39;) //选择特定位置的对象\n$(&#39;li:odd&#39;) //获取下标为基数的元素\n$(&#39;li:even&#39;) //偶数\n</code></pre>\n<p>##方法</p>\n<pre><code class=\"js\">jq.parent() //获取的是jq对象的上级父级\njq.parents(&#39;&#39;) //可以获取所有的父级，里面的参数是指定的css选择器，如果有参数就可以获取指定父级。\n\njq.children(&#39;&#39;) //获取jq的子代元素,有参数后可以获取指定的子代元素。\njq.find(&#39;&#39;) //获取jq的所有的后代元素,参数是后代的css选择器\n\njq.siblings(&#39;&#39;) //获取的是除自己以外的兄弟元素,参数是获取指定css选择器\njq.nextAll() //获取某个jq对象后面的 所有兄弟\njq.show() //显示\njq.hidde() //隐藏\njq.index() //直接返回自己的下标\n</code></pre>\n<h2 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h2><pre><code class=\"js\">\n1.jq.on(&#39;click&#39;,function()&#123;   &#125;)    //最常用的方式\n2.jq.click(function()&#123;  &#125;)\n3.jq.delegate(&#39;css选择器&#39;,&#39;事件&#39;,function()&#123;    &#125;) //支持动态创建的元素\n4.jq.bind(&#39;事件1 事件2&#39;，function()&#123;  &#125;)    //不推荐1.7版后被on取代\n</code></pre>\n<h2 id=\"类名\"><a href=\"#类名\" class=\"headerlink\" title=\"类名\"></a>类名</h2><pre><code class=\"js\">$(&#39;li&#39;).addClass(&quot;类名&quot;); //添加类名\n$(&#39;li&#39;).removeClass(&#39;类名&#39;) //移除类名\n$(&#39;li&#39;).toggleClass(&#39;类名&#39;) //切换类名\n$(&#39;li&#39;).hasClass(&#39;类名&#39;) //用于判断jq对象有没有指定的类名\n</code></pre>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><pre><code class=\"js\">$(&#39;.aa&#39;).css(&#39;属性名&#39;) //获取css样式，属性名驼峰，不区分行内外。\n</code></pre>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><ul>\n<li><p>显示隐藏</p>\n<pre><code class=\"js\">jq.show(时间，速度曲线，执行完毕后执行的函数)\njq.hide() //和上述一样\njq.toggle() // 也一样\n</code></pre>\n</li>\n<li><p>滑动</p>\n<pre><code class=\"js\">jq.slideDown()//滑动\njq.slideUp()    //滑动\njq.slideToggle() //滑动\n</code></pre>\n</li>\n<li><p>移入移出</p>\n<pre><code class=\"js\">jq.hover(function()&#123;&#125;,function()&#123;&#125;) //鼠标移入和移出都执行这个函数,效果相当于mouseenter和mouseleave\n</code></pre>\n</li>\n<li><p>停止动画</p>\n<pre><code class=\"js\">jq.stop() //用来停止事件,加在动画的前面\n</code></pre>\n</li>\n<li><p>淡入淡出</p>\n<pre><code class=\"js\">jq.fadeIn() //淡入\njq.fadeOut() //淡出\njq.fadeToggle() //淡入淡出切换\njq.fadeTo(时间,0.3) //淡出透明\n</code></pre>\n</li>\n<li><p>自定义动画</p>\n<pre><code class=\"js\">animate(params,[speed],[callback])\n\n参数：\n1.paramas：表示一个包含属性和值的映射，可以同时包含多个属性\n2.speed：表示动画运行的适度，参数规则同其他动画效果的speed一致，它是一个可选参数\n3.callback：表示一个回调函数，当动画效果运行完毕后执行该回调函数，它也是一个可选参数\n\n注意：\n 元素必须设置定位，元素才能动起来\n\njq.animate(&#123;\n    width:&quot;400px&quot;,\n    backgroundColor:&quot;color&quot;,\n    css样式，-\n    borderRadius:50%,\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><pre><code class=\"js\">//dom节点渲染完毕后执行\n$(document).ready(function()&#123;\n\n&#125;)\n\n简写：\n$(function()&#123;\n\n&#125;)\n</code></pre>\n<ul>\n<li>window.onload()和$(document).ready的区别<ol>\n<li>onload必须等页面全部加载完后(图片等)在执行，ready网页中dom结构加载完毕执行</li>\n<li>onload只能执行一次，第二次会将第一次的覆盖，ready可执行多次，不会被覆盖</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-jquery\"><a href=\"#01-jquery\" class=\"headerlink\" title=\"01-jquery\"></a>01-jquery</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>jq（javascript query）是一个快速简介的javaScript库，其设计的宗旨是”write Less,Do More”,倡导写更少的代码，做更多的事情,本质就是将js中的DOM操作进行了封装，可以快速使用其功能。</p>\n</blockquote>\n<ul>\n<li>jq的顶级对象是$ 和 Jquery,所以不能使用原生对象上的方法和属性</li>\n</ul>\n<h3 id=\"两大特性\"><a href=\"#两大特性\" class=\"headerlink\" title=\"两大特性\"></a>两大特性</h3><ul>\n<li><p>隐式迭代</p>\n<p>在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 </p>\n</li>\n<li><p>链式编程</p>\n<p>任意的设置形操作后都可以继续操作当前对象。</p>\n</li>\n</ul>\n<h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><ul>\n<li></li>\n</ul>\n<pre><code class=\"js\">//如果jq对象要获取原生dom对象，使用.get(下标)\n$(原生dom节点)  //将原生dom节点转为jq对象\n\n$(&#39;li&#39;).filter();//获取第一个元素\n$(&#39;li:eq()&#39;) //选择特定位置的对象\n$(&#39;li:odd&#39;) //获取下标为基数的元素\n$(&#39;li:even&#39;) //偶数\n</code></pre>\n<p>##方法</p>\n<pre><code class=\"js\">jq.parent() //获取的是jq对象的上级父级\njq.parents(&#39;&#39;) //可以获取所有的父级，里面的参数是指定的css选择器，如果有参数就可以获取指定父级。\n\njq.children(&#39;&#39;) //获取jq的子代元素,有参数后可以获取指定的子代元素。\njq.find(&#39;&#39;) //获取jq的所有的后代元素,参数是后代的css选择器\n\njq.siblings(&#39;&#39;) //获取的是除自己以外的兄弟元素,参数是获取指定css选择器\njq.nextAll() //获取某个jq对象后面的 所有兄弟\njq.show() //显示\njq.hidde() //隐藏\njq.index() //直接返回自己的下标\n</code></pre>\n<h2 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h2><pre><code class=\"js\">\n1.jq.on(&#39;click&#39;,function()&#123;   &#125;)    //最常用的方式\n2.jq.click(function()&#123;  &#125;)\n3.jq.delegate(&#39;css选择器&#39;,&#39;事件&#39;,function()&#123;    &#125;) //支持动态创建的元素\n4.jq.bind(&#39;事件1 事件2&#39;，function()&#123;  &#125;)    //不推荐1.7版后被on取代\n</code></pre>\n<h2 id=\"类名\"><a href=\"#类名\" class=\"headerlink\" title=\"类名\"></a>类名</h2><pre><code class=\"js\">$(&#39;li&#39;).addClass(&quot;类名&quot;); //添加类名\n$(&#39;li&#39;).removeClass(&#39;类名&#39;) //移除类名\n$(&#39;li&#39;).toggleClass(&#39;类名&#39;) //切换类名\n$(&#39;li&#39;).hasClass(&#39;类名&#39;) //用于判断jq对象有没有指定的类名\n</code></pre>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><pre><code class=\"js\">$(&#39;.aa&#39;).css(&#39;属性名&#39;) //获取css样式，属性名驼峰，不区分行内外。\n</code></pre>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><ul>\n<li><p>显示隐藏</p>\n<pre><code class=\"js\">jq.show(时间，速度曲线，执行完毕后执行的函数)\njq.hide() //和上述一样\njq.toggle() // 也一样\n</code></pre>\n</li>\n<li><p>滑动</p>\n<pre><code class=\"js\">jq.slideDown()//滑动\njq.slideUp()    //滑动\njq.slideToggle() //滑动\n</code></pre>\n</li>\n<li><p>移入移出</p>\n<pre><code class=\"js\">jq.hover(function()&#123;&#125;,function()&#123;&#125;) //鼠标移入和移出都执行这个函数,效果相当于mouseenter和mouseleave\n</code></pre>\n</li>\n<li><p>停止动画</p>\n<pre><code class=\"js\">jq.stop() //用来停止事件,加在动画的前面\n</code></pre>\n</li>\n<li><p>淡入淡出</p>\n<pre><code class=\"js\">jq.fadeIn() //淡入\njq.fadeOut() //淡出\njq.fadeToggle() //淡入淡出切换\njq.fadeTo(时间,0.3) //淡出透明\n</code></pre>\n</li>\n<li><p>自定义动画</p>\n<pre><code class=\"js\">animate(params,[speed],[callback])\n\n参数：\n1.paramas：表示一个包含属性和值的映射，可以同时包含多个属性\n2.speed：表示动画运行的适度，参数规则同其他动画效果的speed一致，它是一个可选参数\n3.callback：表示一个回调函数，当动画效果运行完毕后执行该回调函数，它也是一个可选参数\n\n注意：\n 元素必须设置定位，元素才能动起来\n\njq.animate(&#123;\n    width:&quot;400px&quot;,\n    backgroundColor:&quot;color&quot;,\n    css样式，-\n    borderRadius:50%,\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><pre><code class=\"js\">//dom节点渲染完毕后执行\n$(document).ready(function()&#123;\n\n&#125;)\n\n简写：\n$(function()&#123;\n\n&#125;)\n</code></pre>\n<ul>\n<li>window.onload()和$(document).ready的区别<ol>\n<li>onload必须等页面全部加载完后(图片等)在执行，ready网页中dom结构加载完毕执行</li>\n<li>onload只能执行一次，第二次会将第一次的覆盖，ready可执行多次，不会被覆盖</li>\n</ol>\n</li>\n</ul>\n"},{"title":"jquery-方法2","date":"2017-02-06T04:01:23.000Z","_content":"\n# 02-jquery\n\n## 属性操作\n\n+ 属性：\n\n  1. css属性\n  2. 标签标准属性：元素本身自带的属性\n  3. 自定义属性：自己设置的\n\n+ 使用\n\n  ```js\n  jq.attr() //设置属性或者返回属性值\n  jq.attr(\"属性名\",值)\n  jq.prop() //设置属性或者返回属性值\n  jq.prop('属性名',值) //设置属性值\n  \n  \n  jq.removeAttr() //移除属性\n  ```\n\n+ 什么时候使用attr()，什么时候使用prop()？\n\n  ```js\n  1.对标签固有属性用prop()\n    对标签的自定义属性用attr()\n  2.当涉及到获取checked,disabled,selected时\n  ```\n\n\n\n\n## 数据缓存data()\n\n> data()是jq提供的缓存机制\n\n+ 存储在哪里？\n\n  data() 方法可以在指定的JQ元素上存取数据，**并不会修改 DOM 元素结构。**\n\n+ 使用\n\n  1. 绑定在 dom\n\n     ```js\n     var dom = document.body;\n     $.data(dom,\"键\",\"值\") //存入dom，不会修改dom元素结构\n     \n     console.log($('body').data('name')) //输出\n     ```\n\n## 文本操作\n\n```js\njq.html() //识别html\njq.text() //不识别html\njq.val()\t//获取value\n```\n\n\n\n## 遍历元素\n\n```js\njqarr.each(function(index,domEle){\n    index //下标\n    domEle // 原生dom节点\n}); //遍历数组\n```\n\n\n\n##创建、添加、删除、克隆元素\n\n```js\n//事件类型change,一般用于input输入框checkbox check改变\n\n1.创建\n$('标签')\t//创建标签 \n\n2.添加\n$('ul').append(li) // 添加到ul的最底下\n$('ul').prepend(li) //从前面添加\n$('jq').after(li) //在那个元素后面添加\n\n\n3.删除\njq.remove() //删除自身\njq.empty() //清空自身\n\n4.克隆\njq.clone() //克隆出新的jq节点\n```\n\n## js补充\n\n```js\ndom.toFixed(3) //保留3位小数\n```\n\n","source":"_posts/笔记/ocean/06-jquery总结/02-方法和循环/02-笔记.md","raw":"---\ntitle: jquery-方法2\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- jquery\n- javascript\n---\n\n# 02-jquery\n\n## 属性操作\n\n+ 属性：\n\n  1. css属性\n  2. 标签标准属性：元素本身自带的属性\n  3. 自定义属性：自己设置的\n\n+ 使用\n\n  ```js\n  jq.attr() //设置属性或者返回属性值\n  jq.attr(\"属性名\",值)\n  jq.prop() //设置属性或者返回属性值\n  jq.prop('属性名',值) //设置属性值\n  \n  \n  jq.removeAttr() //移除属性\n  ```\n\n+ 什么时候使用attr()，什么时候使用prop()？\n\n  ```js\n  1.对标签固有属性用prop()\n    对标签的自定义属性用attr()\n  2.当涉及到获取checked,disabled,selected时\n  ```\n\n\n\n\n## 数据缓存data()\n\n> data()是jq提供的缓存机制\n\n+ 存储在哪里？\n\n  data() 方法可以在指定的JQ元素上存取数据，**并不会修改 DOM 元素结构。**\n\n+ 使用\n\n  1. 绑定在 dom\n\n     ```js\n     var dom = document.body;\n     $.data(dom,\"键\",\"值\") //存入dom，不会修改dom元素结构\n     \n     console.log($('body').data('name')) //输出\n     ```\n\n## 文本操作\n\n```js\njq.html() //识别html\njq.text() //不识别html\njq.val()\t//获取value\n```\n\n\n\n## 遍历元素\n\n```js\njqarr.each(function(index,domEle){\n    index //下标\n    domEle // 原生dom节点\n}); //遍历数组\n```\n\n\n\n##创建、添加、删除、克隆元素\n\n```js\n//事件类型change,一般用于input输入框checkbox check改变\n\n1.创建\n$('标签')\t//创建标签 \n\n2.添加\n$('ul').append(li) // 添加到ul的最底下\n$('ul').prepend(li) //从前面添加\n$('jq').after(li) //在那个元素后面添加\n\n\n3.删除\njq.remove() //删除自身\njq.empty() //清空自身\n\n4.克隆\njq.clone() //克隆出新的jq节点\n```\n\n## js补充\n\n```js\ndom.toFixed(3) //保留3位小数\n```\n\n","slug":"笔记/ocean/06-jquery总结/02-方法和循环/02-笔记","published":1,"updated":"2023-03-01T07:00:25.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe300a1awaf799s3qg8","content":"<h1 id=\"02-jquery\"><a href=\"#02-jquery\" class=\"headerlink\" title=\"02-jquery\"></a>02-jquery</h1><h2 id=\"属性操作\"><a href=\"#属性操作\" class=\"headerlink\" title=\"属性操作\"></a>属性操作</h2><ul>\n<li><p>属性：</p>\n<ol>\n<li>css属性</li>\n<li>标签标准属性：元素本身自带的属性</li>\n<li>自定义属性：自己设置的</li>\n</ol>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">jq.attr() //设置属性或者返回属性值\njq.attr(&quot;属性名&quot;,值)\njq.prop() //设置属性或者返回属性值\njq.prop(&#39;属性名&#39;,值) //设置属性值\n\n\njq.removeAttr() //移除属性\n</code></pre>\n</li>\n<li><p>什么时候使用attr()，什么时候使用prop()？</p>\n<pre><code class=\"js\">1.对标签固有属性用prop()\n  对标签的自定义属性用attr()\n2.当涉及到获取checked,disabled,selected时\n</code></pre>\n</li>\n</ul>\n<h2 id=\"数据缓存data\"><a href=\"#数据缓存data\" class=\"headerlink\" title=\"数据缓存data()\"></a>数据缓存data()</h2><blockquote>\n<p>data()是jq提供的缓存机制</p>\n</blockquote>\n<ul>\n<li><p>存储在哪里？</p>\n<p>data() 方法可以在指定的JQ元素上存取数据，<strong>并不会修改 DOM 元素结构。</strong></p>\n</li>\n<li><p>使用</p>\n<ol>\n<li><p>绑定在 dom</p>\n<pre><code class=\"js\">var dom = document.body;\n$.data(dom,&quot;键&quot;,&quot;值&quot;) //存入dom，不会修改dom元素结构\n\nconsole.log($(&#39;body&#39;).data(&#39;name&#39;)) //输出\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"文本操作\"><a href=\"#文本操作\" class=\"headerlink\" title=\"文本操作\"></a>文本操作</h2><pre><code class=\"js\">jq.html() //识别html\njq.text() //不识别html\njq.val()    //获取value\n</code></pre>\n<h2 id=\"遍历元素\"><a href=\"#遍历元素\" class=\"headerlink\" title=\"遍历元素\"></a>遍历元素</h2><pre><code class=\"js\">jqarr.each(function(index,domEle)&#123;\n    index //下标\n    domEle // 原生dom节点\n&#125;); //遍历数组\n</code></pre>\n<p>##创建、添加、删除、克隆元素</p>\n<pre><code class=\"js\">//事件类型change,一般用于input输入框checkbox check改变\n\n1.创建\n$(&#39;标签&#39;)    //创建标签 \n\n2.添加\n$(&#39;ul&#39;).append(li) // 添加到ul的最底下\n$(&#39;ul&#39;).prepend(li) //从前面添加\n$(&#39;jq&#39;).after(li) //在那个元素后面添加\n\n\n3.删除\njq.remove() //删除自身\njq.empty() //清空自身\n\n4.克隆\njq.clone() //克隆出新的jq节点\n</code></pre>\n<h2 id=\"js补充\"><a href=\"#js补充\" class=\"headerlink\" title=\"js补充\"></a>js补充</h2><pre><code class=\"js\">dom.toFixed(3) //保留3位小数\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-jquery\"><a href=\"#02-jquery\" class=\"headerlink\" title=\"02-jquery\"></a>02-jquery</h1><h2 id=\"属性操作\"><a href=\"#属性操作\" class=\"headerlink\" title=\"属性操作\"></a>属性操作</h2><ul>\n<li><p>属性：</p>\n<ol>\n<li>css属性</li>\n<li>标签标准属性：元素本身自带的属性</li>\n<li>自定义属性：自己设置的</li>\n</ol>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">jq.attr() //设置属性或者返回属性值\njq.attr(&quot;属性名&quot;,值)\njq.prop() //设置属性或者返回属性值\njq.prop(&#39;属性名&#39;,值) //设置属性值\n\n\njq.removeAttr() //移除属性\n</code></pre>\n</li>\n<li><p>什么时候使用attr()，什么时候使用prop()？</p>\n<pre><code class=\"js\">1.对标签固有属性用prop()\n  对标签的自定义属性用attr()\n2.当涉及到获取checked,disabled,selected时\n</code></pre>\n</li>\n</ul>\n<h2 id=\"数据缓存data\"><a href=\"#数据缓存data\" class=\"headerlink\" title=\"数据缓存data()\"></a>数据缓存data()</h2><blockquote>\n<p>data()是jq提供的缓存机制</p>\n</blockquote>\n<ul>\n<li><p>存储在哪里？</p>\n<p>data() 方法可以在指定的JQ元素上存取数据，<strong>并不会修改 DOM 元素结构。</strong></p>\n</li>\n<li><p>使用</p>\n<ol>\n<li><p>绑定在 dom</p>\n<pre><code class=\"js\">var dom = document.body;\n$.data(dom,&quot;键&quot;,&quot;值&quot;) //存入dom，不会修改dom元素结构\n\nconsole.log($(&#39;body&#39;).data(&#39;name&#39;)) //输出\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"文本操作\"><a href=\"#文本操作\" class=\"headerlink\" title=\"文本操作\"></a>文本操作</h2><pre><code class=\"js\">jq.html() //识别html\njq.text() //不识别html\njq.val()    //获取value\n</code></pre>\n<h2 id=\"遍历元素\"><a href=\"#遍历元素\" class=\"headerlink\" title=\"遍历元素\"></a>遍历元素</h2><pre><code class=\"js\">jqarr.each(function(index,domEle)&#123;\n    index //下标\n    domEle // 原生dom节点\n&#125;); //遍历数组\n</code></pre>\n<p>##创建、添加、删除、克隆元素</p>\n<pre><code class=\"js\">//事件类型change,一般用于input输入框checkbox check改变\n\n1.创建\n$(&#39;标签&#39;)    //创建标签 \n\n2.添加\n$(&#39;ul&#39;).append(li) // 添加到ul的最底下\n$(&#39;ul&#39;).prepend(li) //从前面添加\n$(&#39;jq&#39;).after(li) //在那个元素后面添加\n\n\n3.删除\njq.remove() //删除自身\njq.empty() //清空自身\n\n4.克隆\njq.clone() //克隆出新的jq节点\n</code></pre>\n<h2 id=\"js补充\"><a href=\"#js补充\" class=\"headerlink\" title=\"js补充\"></a>js补充</h2><pre><code class=\"js\">dom.toFixed(3) //保留3位小数\n</code></pre>\n"},{"title":"ajax02和跨域","date":"2017-02-06T04:01:23.000Z","_content":"# Ajax04\n\n## 回顾\n\n1. 三天总结\n   + 其实就是将数据传送到服务器端，然后将服务器的数据渲染到页面。\n\n## jquery的Ajax进阶\n\n### jquery的方式上传文件\n\n```js\n使用$.ajax({\n    type:\"post\",\n    url:\"地址\"，\n    data:{fd}, \n    xhr：function(){\t//jq本身不提供进度控制，可借原生的xhr实例化对象控制\n        var xhr = new XMLHttpRequest()\n        return xhr\n    }\n    processData:false\t //jquery默认提交的参数是字符串形式的，需要禁止转为字符串\n    contentType:false //默认提交的参数类型，需要禁止默认的参数类型，采用FormData类型\n})\t//传递\n\n\n```\n\n## axios\n\n### axios介绍\n\n+ axios是一个专门调用后台接口的js库，后续都会使用\n  + 支持客户端发送Ajax请求\n  + 支持服务端Node.js发送\n  + 支持Promise相关用法（解决回调地狱）\n  + 支持请求和响应的拦截器功能（登录时会用到）\n  + 可以手动取消请求\n  + 自动转换JSON数据（JSON.parse(res))\n  + 可更加安全的处理请求\n\n### 使用\n\n+ get请求\n\n  ```js\n  //1.下载\n  <script type'text/javascript' src='axios.js'> //2.导入\n   axios.defaults.baseURL = `路径` //配置基准请求路径\n  \n  //3.请求服务器\n  axios.get('路径'，{\n            params:{\t//传参，params的名字是固定的\n            \tid:2,\n            \tauthor:\"呵呵\"\n            }     \n   }）\n  .then(function(res){\n      console.log(res.data) //基\t于axios发送get请求\n  })\n  .catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  \n  //另一种使用方法，当成函数使用\n  axios({\n      method:\"get\"//请求方式\n      url：\"\"\t//路径\n      params:{\n      \tid:1,\n      \tauthor:'nohao'\n  \t}\n   }).then(function(res){\n      \n   }).catch(function(err){  \n  })\n  ```\n\n+ post请求\n\n  ```js\n  axios.post('路径'，\n         {\t//传参\n            id:2,\n            author:\"呵呵\"\n  }）\n  .then(function(res){\n      console.log(res.data) //基于axios发送get请求\n  })\n  .catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  //post传参，默认请求参数格式是JSON,application/json\n  //如果前端提交的是json格式，后端需要额外处理\n  //解决\n  //使用URLSearchParams()设置参数格式为application/x-www-form-urlencoded\n  var fd = new URLSearchParams()\n  fd.append('name','list')\n  fd.append('pwd','123')\n  \n  \n  axios.post('路径'，fd）.then(function(res){\n      console.log(res.data) //基于axios发送post请求\n  }).catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  \n  //另一种使用方法，当成函数使用\n  axios({\n      method:\"post\"//请求方式\n      url：\"\"\t//路径\n      data:{//post提交要使用data\n      \tfd \n  \t}\n   }).then(function(res){\n      \n   }).catch(function(err){  \n  })\n  ```\n\n  \n\n## 请求格式\n\n```js\nConten-type\n\n//表单的默认提交方式，new URLSearchParams()\napplication/x-www-form-urlencoded \n\n//使用new Form-data来进行文件上传，支持普通上传，后端需要支持\nmultipart/form-data; new Formdata()\n\n//axios的post默认上传格式，这种格式后端需要支持，不支持可采用new URLSearchParams()\napplication/json\n\n```\n\n## 跨域介绍\n\n### 同源策略\n\n1. 协议，域名，端口都相同则同源，只要有一项不同就是不同源\n2. 这是浏览器提供的一种安全机制，限制来自不同源的数据。\n3. 不同源就是跨域\n  + 在当前显示的页面中，如果触发了一个Ajax请求，如果请求的URL地址和当前页面的URL地址不同原就是跨域\n  + 浏览器不允许跨域获取数据，但是实际会经常有这个跨域获取需求。\n\n### 解决跨域方案\n\n+ jsonp(前后端配合)\n\n  + 原理：利用了script标签中src来发送请求给服务器，而服务器返回一个 调用函数，这个函数为回调函数，需要在定义之前声明函数\n\n  + 就是服务器回调当前页面的函数并且传递参数。\n\n\n  ```js\n  /*script标签天生支持跨域发送请求\n  如\n  果服务器返回的数据是一个变量，那么即可获取到这个数据\n  */\n  <script type=\"text/javascript\" src=\"接口\">\n  \n  /*默认script标签发送的请求是同步的（阻塞的）\n  如果给script标签添加一个async属性，那么就变成了异步的（不阻塞的）\n  当是可能会获取不到数据\n  */\n  \n  <script async type=\"text/javascript\" src=\"接口\">\n  \n  /*\n  解决方案：\n  服务器返回（函数调用）: foo(123)\n  如果想自己起函数名字，则把函数名字通过传参的形式传入后端\n  */\n  <script async type=\"text/javascript\" src=\"请求接口\">\n     \n  functio foo(n){\n  \tconsole.log(n)\n  }\n  foo是一个回调函数\n  \n  ```\n\n+ cors(后端技术)\n\n+ 服务端反向代理(后端)\n\n+ 跨域Ajax请求的错误提示（后端不支持跨域）\n\n### 改进：动态创建标签\n\n```js\nvar script = document.createElement('script')//1.创建一个scr标签\nscript.src = '接口'\t\t//2.设置这个标签的src\nvar head = document.getElementsByTagName('head')[0]\t//3.获取head\nhead.appendChild(script)\t//4.添加到head\nhead.removeChild(script)\t//5.获取请求后将其删除\n\n//6.拿到数据\nfunction hello(n){\n    console.log(n)\n}\n```\n\n### 基于Jquery对跨域的支持\n\n使用$.ajax() 方法，该方法可以发送jsonp请求\n\n```js\n$.ajax({\n    type:'get',\n    url:'接口',\n    dataType:'jsonp',//服务器返回数据的格式\n    jsonpCallback:\"abc\" //定制一个属性值，也是回调函数名称，如果不写jq会默认生成一个，他会自动在参数后面添加一个时间戳，作用是防止缓存\n    jsonp:\"cb\" //定制一个属性名，该属性名由后端决定\n    success:function(data){\n        data\t//拿到数据\n    }\n})\n\n```\n\n### jsonp的缺点\n\n1. 仅支持get请求，不支持其他请求\n\n2. script标签发出请求本身就是get,不支持别的请求方式\n\n3. get请求传递的数据量有限制，URL地址的长度不超过8000个字符。\n4. post请求可以传递更多数据,如果确实希望跨域post提交数据，需要让后端去做CORS.\n\n","source":"_posts/笔记/ocean/07-Ajax总结/04-axios和跨域/04-笔记.md","raw":"---\ntitle: ajax02和跨域\ndate: 2017-02-06 12:01:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- 笔记\n- js\n- ajax\n- javascript\n---\n# Ajax04\n\n## 回顾\n\n1. 三天总结\n   + 其实就是将数据传送到服务器端，然后将服务器的数据渲染到页面。\n\n## jquery的Ajax进阶\n\n### jquery的方式上传文件\n\n```js\n使用$.ajax({\n    type:\"post\",\n    url:\"地址\"，\n    data:{fd}, \n    xhr：function(){\t//jq本身不提供进度控制，可借原生的xhr实例化对象控制\n        var xhr = new XMLHttpRequest()\n        return xhr\n    }\n    processData:false\t //jquery默认提交的参数是字符串形式的，需要禁止转为字符串\n    contentType:false //默认提交的参数类型，需要禁止默认的参数类型，采用FormData类型\n})\t//传递\n\n\n```\n\n## axios\n\n### axios介绍\n\n+ axios是一个专门调用后台接口的js库，后续都会使用\n  + 支持客户端发送Ajax请求\n  + 支持服务端Node.js发送\n  + 支持Promise相关用法（解决回调地狱）\n  + 支持请求和响应的拦截器功能（登录时会用到）\n  + 可以手动取消请求\n  + 自动转换JSON数据（JSON.parse(res))\n  + 可更加安全的处理请求\n\n### 使用\n\n+ get请求\n\n  ```js\n  //1.下载\n  <script type'text/javascript' src='axios.js'> //2.导入\n   axios.defaults.baseURL = `路径` //配置基准请求路径\n  \n  //3.请求服务器\n  axios.get('路径'，{\n            params:{\t//传参，params的名字是固定的\n            \tid:2,\n            \tauthor:\"呵呵\"\n            }     \n   }）\n  .then(function(res){\n      console.log(res.data) //基\t于axios发送get请求\n  })\n  .catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  \n  //另一种使用方法，当成函数使用\n  axios({\n      method:\"get\"//请求方式\n      url：\"\"\t//路径\n      params:{\n      \tid:1,\n      \tauthor:'nohao'\n  \t}\n   }).then(function(res){\n      \n   }).catch(function(err){  \n  })\n  ```\n\n+ post请求\n\n  ```js\n  axios.post('路径'，\n         {\t//传参\n            id:2,\n            author:\"呵呵\"\n  }）\n  .then(function(res){\n      console.log(res.data) //基于axios发送get请求\n  })\n  .catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  //post传参，默认请求参数格式是JSON,application/json\n  //如果前端提交的是json格式，后端需要额外处理\n  //解决\n  //使用URLSearchParams()设置参数格式为application/x-www-form-urlencoded\n  var fd = new URLSearchParams()\n  fd.append('name','list')\n  fd.append('pwd','123')\n  \n  \n  axios.post('路径'，fd）.then(function(res){\n      console.log(res.data) //基于axios发送post请求\n  }).catch(function(err){ //处理报错\n      console.log(err)\n  })\n  \n  \n  \n  //另一种使用方法，当成函数使用\n  axios({\n      method:\"post\"//请求方式\n      url：\"\"\t//路径\n      data:{//post提交要使用data\n      \tfd \n  \t}\n   }).then(function(res){\n      \n   }).catch(function(err){  \n  })\n  ```\n\n  \n\n## 请求格式\n\n```js\nConten-type\n\n//表单的默认提交方式，new URLSearchParams()\napplication/x-www-form-urlencoded \n\n//使用new Form-data来进行文件上传，支持普通上传，后端需要支持\nmultipart/form-data; new Formdata()\n\n//axios的post默认上传格式，这种格式后端需要支持，不支持可采用new URLSearchParams()\napplication/json\n\n```\n\n## 跨域介绍\n\n### 同源策略\n\n1. 协议，域名，端口都相同则同源，只要有一项不同就是不同源\n2. 这是浏览器提供的一种安全机制，限制来自不同源的数据。\n3. 不同源就是跨域\n  + 在当前显示的页面中，如果触发了一个Ajax请求，如果请求的URL地址和当前页面的URL地址不同原就是跨域\n  + 浏览器不允许跨域获取数据，但是实际会经常有这个跨域获取需求。\n\n### 解决跨域方案\n\n+ jsonp(前后端配合)\n\n  + 原理：利用了script标签中src来发送请求给服务器，而服务器返回一个 调用函数，这个函数为回调函数，需要在定义之前声明函数\n\n  + 就是服务器回调当前页面的函数并且传递参数。\n\n\n  ```js\n  /*script标签天生支持跨域发送请求\n  如\n  果服务器返回的数据是一个变量，那么即可获取到这个数据\n  */\n  <script type=\"text/javascript\" src=\"接口\">\n  \n  /*默认script标签发送的请求是同步的（阻塞的）\n  如果给script标签添加一个async属性，那么就变成了异步的（不阻塞的）\n  当是可能会获取不到数据\n  */\n  \n  <script async type=\"text/javascript\" src=\"接口\">\n  \n  /*\n  解决方案：\n  服务器返回（函数调用）: foo(123)\n  如果想自己起函数名字，则把函数名字通过传参的形式传入后端\n  */\n  <script async type=\"text/javascript\" src=\"请求接口\">\n     \n  functio foo(n){\n  \tconsole.log(n)\n  }\n  foo是一个回调函数\n  \n  ```\n\n+ cors(后端技术)\n\n+ 服务端反向代理(后端)\n\n+ 跨域Ajax请求的错误提示（后端不支持跨域）\n\n### 改进：动态创建标签\n\n```js\nvar script = document.createElement('script')//1.创建一个scr标签\nscript.src = '接口'\t\t//2.设置这个标签的src\nvar head = document.getElementsByTagName('head')[0]\t//3.获取head\nhead.appendChild(script)\t//4.添加到head\nhead.removeChild(script)\t//5.获取请求后将其删除\n\n//6.拿到数据\nfunction hello(n){\n    console.log(n)\n}\n```\n\n### 基于Jquery对跨域的支持\n\n使用$.ajax() 方法，该方法可以发送jsonp请求\n\n```js\n$.ajax({\n    type:'get',\n    url:'接口',\n    dataType:'jsonp',//服务器返回数据的格式\n    jsonpCallback:\"abc\" //定制一个属性值，也是回调函数名称，如果不写jq会默认生成一个，他会自动在参数后面添加一个时间戳，作用是防止缓存\n    jsonp:\"cb\" //定制一个属性名，该属性名由后端决定\n    success:function(data){\n        data\t//拿到数据\n    }\n})\n\n```\n\n### jsonp的缺点\n\n1. 仅支持get请求，不支持其他请求\n\n2. script标签发出请求本身就是get,不支持别的请求方式\n\n3. get请求传递的数据量有限制，URL地址的长度不超过8000个字符。\n4. post请求可以传递更多数据,如果确实希望跨域post提交数据，需要让后端去做CORS.\n\n","slug":"笔记/ocean/07-Ajax总结/04-axios和跨域/04-笔记","published":1,"updated":"2023-03-01T07:02:04.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe300a3awafaglt6itp","content":"<h1 id=\"Ajax04\"><a href=\"#Ajax04\" class=\"headerlink\" title=\"Ajax04\"></a>Ajax04</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><ol>\n<li>三天总结<ul>\n<li>其实就是将数据传送到服务器端，然后将服务器的数据渲染到页面。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"jquery的Ajax进阶\"><a href=\"#jquery的Ajax进阶\" class=\"headerlink\" title=\"jquery的Ajax进阶\"></a>jquery的Ajax进阶</h2><h3 id=\"jquery的方式上传文件\"><a href=\"#jquery的方式上传文件\" class=\"headerlink\" title=\"jquery的方式上传文件\"></a>jquery的方式上传文件</h3><pre><code class=\"js\">使用$.ajax(&#123;\n    type:&quot;post&quot;,\n    url:&quot;地址&quot;，\n    data:&#123;fd&#125;, \n    xhr：function()&#123;    //jq本身不提供进度控制，可借原生的xhr实例化对象控制\n        var xhr = new XMLHttpRequest()\n        return xhr\n    &#125;\n    processData:false     //jquery默认提交的参数是字符串形式的，需要禁止转为字符串\n    contentType:false //默认提交的参数类型，需要禁止默认的参数类型，采用FormData类型\n&#125;)    //传递\n\n</code></pre>\n<h2 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h2><h3 id=\"axios介绍\"><a href=\"#axios介绍\" class=\"headerlink\" title=\"axios介绍\"></a>axios介绍</h3><ul>\n<li>axios是一个专门调用后台接口的js库，后续都会使用<ul>\n<li>支持客户端发送Ajax请求</li>\n<li>支持服务端Node.js发送</li>\n<li>支持Promise相关用法（解决回调地狱）</li>\n<li>支持请求和响应的拦截器功能（登录时会用到）</li>\n<li>可以手动取消请求</li>\n<li>自动转换JSON数据（JSON.parse(res))</li>\n<li>可更加安全的处理请求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li><p>get请求</p>\n<pre><code class=\"js\">//1.下载\n&lt;script type&#39;text/javascript&#39; src=&#39;axios.js&#39;&gt; //2.导入\n axios.defaults.baseURL = `路径` //配置基准请求路径\n\n//3.请求服务器\naxios.get(&#39;路径&#39;，&#123;\n          params:&#123;    //传参，params的名字是固定的\n              id:2,\n              author:&quot;呵呵&quot;\n          &#125;     \n &#125;）\n.then(function(res)&#123;\n    console.log(res.data) //基    于axios发送get请求\n&#125;)\n.catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n\n//另一种使用方法，当成函数使用\naxios(&#123;\n    method:&quot;get&quot;//请求方式\n    url：&quot;&quot;    //路径\n    params:&#123;\n        id:1,\n        author:&#39;nohao&#39;\n    &#125;\n &#125;).then(function(res)&#123;\n    \n &#125;).catch(function(err)&#123;  \n&#125;)\n</code></pre>\n</li>\n<li><p>post请求</p>\n<pre><code class=\"js\">axios.post(&#39;路径&#39;，\n       &#123;    //传参\n          id:2,\n          author:&quot;呵呵&quot;\n&#125;）\n.then(function(res)&#123;\n    console.log(res.data) //基于axios发送get请求\n&#125;)\n.catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n//post传参，默认请求参数格式是JSON,application/json\n//如果前端提交的是json格式，后端需要额外处理\n//解决\n//使用URLSearchParams()设置参数格式为application/x-www-form-urlencoded\nvar fd = new URLSearchParams()\nfd.append(&#39;name&#39;,&#39;list&#39;)\nfd.append(&#39;pwd&#39;,&#39;123&#39;)\n\n\naxios.post(&#39;路径&#39;，fd）.then(function(res)&#123;\n    console.log(res.data) //基于axios发送post请求\n&#125;).catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n\n//另一种使用方法，当成函数使用\naxios(&#123;\n    method:&quot;post&quot;//请求方式\n    url：&quot;&quot;    //路径\n    data:&#123;//post提交要使用data\n        fd \n    &#125;\n &#125;).then(function(res)&#123;\n    \n &#125;).catch(function(err)&#123;  \n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"请求格式\"><a href=\"#请求格式\" class=\"headerlink\" title=\"请求格式\"></a>请求格式</h2><pre><code class=\"js\">Conten-type\n\n//表单的默认提交方式，new URLSearchParams()\napplication/x-www-form-urlencoded \n\n//使用new Form-data来进行文件上传，支持普通上传，后端需要支持\nmultipart/form-data; new Formdata()\n\n//axios的post默认上传格式，这种格式后端需要支持，不支持可采用new URLSearchParams()\napplication/json\n</code></pre>\n<h2 id=\"跨域介绍\"><a href=\"#跨域介绍\" class=\"headerlink\" title=\"跨域介绍\"></a>跨域介绍</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ol>\n<li>协议，域名，端口都相同则同源，只要有一项不同就是不同源</li>\n<li>这是浏览器提供的一种安全机制，限制来自不同源的数据。</li>\n<li>不同源就是跨域</li>\n</ol>\n<ul>\n<li>在当前显示的页面中，如果触发了一个Ajax请求，如果请求的URL地址和当前页面的URL地址不同原就是跨域</li>\n<li>浏览器不允许跨域获取数据，但是实际会经常有这个跨域获取需求。</li>\n</ul>\n<h3 id=\"解决跨域方案\"><a href=\"#解决跨域方案\" class=\"headerlink\" title=\"解决跨域方案\"></a>解决跨域方案</h3><ul>\n<li><p>jsonp(前后端配合)</p>\n<ul>\n<li><p>原理：利用了script标签中src来发送请求给服务器，而服务器返回一个 调用函数，这个函数为回调函数，需要在定义之前声明函数</p>\n</li>\n<li><p>就是服务器回调当前页面的函数并且传递参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">/*script标签天生支持跨域发送请求\n如\n果服务器返回的数据是一个变量，那么即可获取到这个数据\n*/\n&lt;script type=&quot;text/javascript&quot; src=&quot;接口&quot;&gt;\n\n/*默认script标签发送的请求是同步的（阻塞的）\n如果给script标签添加一个async属性，那么就变成了异步的（不阻塞的）\n当是可能会获取不到数据\n*/\n\n&lt;script async type=&quot;text/javascript&quot; src=&quot;接口&quot;&gt;\n\n/*\n解决方案：\n服务器返回（函数调用）: foo(123)\n如果想自己起函数名字，则把函数名字通过传参的形式传入后端\n*/\n&lt;script async type=&quot;text/javascript&quot; src=&quot;请求接口&quot;&gt;\n   \nfunctio foo(n)&#123;\n    console.log(n)\n&#125;\nfoo是一个回调函数\n</code></pre>\n<ul>\n<li><p>cors(后端技术)</p>\n</li>\n<li><p>服务端反向代理(后端)</p>\n</li>\n<li><p>跨域Ajax请求的错误提示（后端不支持跨域）</p>\n</li>\n</ul>\n<h3 id=\"改进：动态创建标签\"><a href=\"#改进：动态创建标签\" class=\"headerlink\" title=\"改进：动态创建标签\"></a>改进：动态创建标签</h3><pre><code class=\"js\">var script = document.createElement(&#39;script&#39;)//1.创建一个scr标签\nscript.src = &#39;接口&#39;        //2.设置这个标签的src\nvar head = document.getElementsByTagName(&#39;head&#39;)[0]    //3.获取head\nhead.appendChild(script)    //4.添加到head\nhead.removeChild(script)    //5.获取请求后将其删除\n\n//6.拿到数据\nfunction hello(n)&#123;\n    console.log(n)\n&#125;\n</code></pre>\n<h3 id=\"基于Jquery对跨域的支持\"><a href=\"#基于Jquery对跨域的支持\" class=\"headerlink\" title=\"基于Jquery对跨域的支持\"></a>基于Jquery对跨域的支持</h3><p>使用$.ajax() 方法，该方法可以发送jsonp请求</p>\n<pre><code class=\"js\">$.ajax(&#123;\n    type:&#39;get&#39;,\n    url:&#39;接口&#39;,\n    dataType:&#39;jsonp&#39;,//服务器返回数据的格式\n    jsonpCallback:&quot;abc&quot; //定制一个属性值，也是回调函数名称，如果不写jq会默认生成一个，他会自动在参数后面添加一个时间戳，作用是防止缓存\n    jsonp:&quot;cb&quot; //定制一个属性名，该属性名由后端决定\n    success:function(data)&#123;\n        data    //拿到数据\n    &#125;\n&#125;)\n</code></pre>\n<h3 id=\"jsonp的缺点\"><a href=\"#jsonp的缺点\" class=\"headerlink\" title=\"jsonp的缺点\"></a>jsonp的缺点</h3><ol>\n<li><p>仅支持get请求，不支持其他请求</p>\n</li>\n<li><p>script标签发出请求本身就是get,不支持别的请求方式</p>\n</li>\n<li><p>get请求传递的数据量有限制，URL地址的长度不超过8000个字符。</p>\n</li>\n<li><p>post请求可以传递更多数据,如果确实希望跨域post提交数据，需要让后端去做CORS.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Ajax04\"><a href=\"#Ajax04\" class=\"headerlink\" title=\"Ajax04\"></a>Ajax04</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><ol>\n<li>三天总结<ul>\n<li>其实就是将数据传送到服务器端，然后将服务器的数据渲染到页面。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"jquery的Ajax进阶\"><a href=\"#jquery的Ajax进阶\" class=\"headerlink\" title=\"jquery的Ajax进阶\"></a>jquery的Ajax进阶</h2><h3 id=\"jquery的方式上传文件\"><a href=\"#jquery的方式上传文件\" class=\"headerlink\" title=\"jquery的方式上传文件\"></a>jquery的方式上传文件</h3><pre><code class=\"js\">使用$.ajax(&#123;\n    type:&quot;post&quot;,\n    url:&quot;地址&quot;，\n    data:&#123;fd&#125;, \n    xhr：function()&#123;    //jq本身不提供进度控制，可借原生的xhr实例化对象控制\n        var xhr = new XMLHttpRequest()\n        return xhr\n    &#125;\n    processData:false     //jquery默认提交的参数是字符串形式的，需要禁止转为字符串\n    contentType:false //默认提交的参数类型，需要禁止默认的参数类型，采用FormData类型\n&#125;)    //传递\n\n</code></pre>\n<h2 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h2><h3 id=\"axios介绍\"><a href=\"#axios介绍\" class=\"headerlink\" title=\"axios介绍\"></a>axios介绍</h3><ul>\n<li>axios是一个专门调用后台接口的js库，后续都会使用<ul>\n<li>支持客户端发送Ajax请求</li>\n<li>支持服务端Node.js发送</li>\n<li>支持Promise相关用法（解决回调地狱）</li>\n<li>支持请求和响应的拦截器功能（登录时会用到）</li>\n<li>可以手动取消请求</li>\n<li>自动转换JSON数据（JSON.parse(res))</li>\n<li>可更加安全的处理请求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li><p>get请求</p>\n<pre><code class=\"js\">//1.下载\n&lt;script type&#39;text/javascript&#39; src=&#39;axios.js&#39;&gt; //2.导入\n axios.defaults.baseURL = `路径` //配置基准请求路径\n\n//3.请求服务器\naxios.get(&#39;路径&#39;，&#123;\n          params:&#123;    //传参，params的名字是固定的\n              id:2,\n              author:&quot;呵呵&quot;\n          &#125;     \n &#125;）\n.then(function(res)&#123;\n    console.log(res.data) //基    于axios发送get请求\n&#125;)\n.catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n\n//另一种使用方法，当成函数使用\naxios(&#123;\n    method:&quot;get&quot;//请求方式\n    url：&quot;&quot;    //路径\n    params:&#123;\n        id:1,\n        author:&#39;nohao&#39;\n    &#125;\n &#125;).then(function(res)&#123;\n    \n &#125;).catch(function(err)&#123;  \n&#125;)\n</code></pre>\n</li>\n<li><p>post请求</p>\n<pre><code class=\"js\">axios.post(&#39;路径&#39;，\n       &#123;    //传参\n          id:2,\n          author:&quot;呵呵&quot;\n&#125;）\n.then(function(res)&#123;\n    console.log(res.data) //基于axios发送get请求\n&#125;)\n.catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n//post传参，默认请求参数格式是JSON,application/json\n//如果前端提交的是json格式，后端需要额外处理\n//解决\n//使用URLSearchParams()设置参数格式为application/x-www-form-urlencoded\nvar fd = new URLSearchParams()\nfd.append(&#39;name&#39;,&#39;list&#39;)\nfd.append(&#39;pwd&#39;,&#39;123&#39;)\n\n\naxios.post(&#39;路径&#39;，fd）.then(function(res)&#123;\n    console.log(res.data) //基于axios发送post请求\n&#125;).catch(function(err)&#123; //处理报错\n    console.log(err)\n&#125;)\n\n\n\n//另一种使用方法，当成函数使用\naxios(&#123;\n    method:&quot;post&quot;//请求方式\n    url：&quot;&quot;    //路径\n    data:&#123;//post提交要使用data\n        fd \n    &#125;\n &#125;).then(function(res)&#123;\n    \n &#125;).catch(function(err)&#123;  \n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"请求格式\"><a href=\"#请求格式\" class=\"headerlink\" title=\"请求格式\"></a>请求格式</h2><pre><code class=\"js\">Conten-type\n\n//表单的默认提交方式，new URLSearchParams()\napplication/x-www-form-urlencoded \n\n//使用new Form-data来进行文件上传，支持普通上传，后端需要支持\nmultipart/form-data; new Formdata()\n\n//axios的post默认上传格式，这种格式后端需要支持，不支持可采用new URLSearchParams()\napplication/json\n</code></pre>\n<h2 id=\"跨域介绍\"><a href=\"#跨域介绍\" class=\"headerlink\" title=\"跨域介绍\"></a>跨域介绍</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ol>\n<li>协议，域名，端口都相同则同源，只要有一项不同就是不同源</li>\n<li>这是浏览器提供的一种安全机制，限制来自不同源的数据。</li>\n<li>不同源就是跨域</li>\n</ol>\n<ul>\n<li>在当前显示的页面中，如果触发了一个Ajax请求，如果请求的URL地址和当前页面的URL地址不同原就是跨域</li>\n<li>浏览器不允许跨域获取数据，但是实际会经常有这个跨域获取需求。</li>\n</ul>\n<h3 id=\"解决跨域方案\"><a href=\"#解决跨域方案\" class=\"headerlink\" title=\"解决跨域方案\"></a>解决跨域方案</h3><ul>\n<li><p>jsonp(前后端配合)</p>\n<ul>\n<li><p>原理：利用了script标签中src来发送请求给服务器，而服务器返回一个 调用函数，这个函数为回调函数，需要在定义之前声明函数</p>\n</li>\n<li><p>就是服务器回调当前页面的函数并且传递参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">/*script标签天生支持跨域发送请求\n如\n果服务器返回的数据是一个变量，那么即可获取到这个数据\n*/\n&lt;script type=&quot;text/javascript&quot; src=&quot;接口&quot;&gt;\n\n/*默认script标签发送的请求是同步的（阻塞的）\n如果给script标签添加一个async属性，那么就变成了异步的（不阻塞的）\n当是可能会获取不到数据\n*/\n\n&lt;script async type=&quot;text/javascript&quot; src=&quot;接口&quot;&gt;\n\n/*\n解决方案：\n服务器返回（函数调用）: foo(123)\n如果想自己起函数名字，则把函数名字通过传参的形式传入后端\n*/\n&lt;script async type=&quot;text/javascript&quot; src=&quot;请求接口&quot;&gt;\n   \nfunctio foo(n)&#123;\n    console.log(n)\n&#125;\nfoo是一个回调函数\n</code></pre>\n<ul>\n<li><p>cors(后端技术)</p>\n</li>\n<li><p>服务端反向代理(后端)</p>\n</li>\n<li><p>跨域Ajax请求的错误提示（后端不支持跨域）</p>\n</li>\n</ul>\n<h3 id=\"改进：动态创建标签\"><a href=\"#改进：动态创建标签\" class=\"headerlink\" title=\"改进：动态创建标签\"></a>改进：动态创建标签</h3><pre><code class=\"js\">var script = document.createElement(&#39;script&#39;)//1.创建一个scr标签\nscript.src = &#39;接口&#39;        //2.设置这个标签的src\nvar head = document.getElementsByTagName(&#39;head&#39;)[0]    //3.获取head\nhead.appendChild(script)    //4.添加到head\nhead.removeChild(script)    //5.获取请求后将其删除\n\n//6.拿到数据\nfunction hello(n)&#123;\n    console.log(n)\n&#125;\n</code></pre>\n<h3 id=\"基于Jquery对跨域的支持\"><a href=\"#基于Jquery对跨域的支持\" class=\"headerlink\" title=\"基于Jquery对跨域的支持\"></a>基于Jquery对跨域的支持</h3><p>使用$.ajax() 方法，该方法可以发送jsonp请求</p>\n<pre><code class=\"js\">$.ajax(&#123;\n    type:&#39;get&#39;,\n    url:&#39;接口&#39;,\n    dataType:&#39;jsonp&#39;,//服务器返回数据的格式\n    jsonpCallback:&quot;abc&quot; //定制一个属性值，也是回调函数名称，如果不写jq会默认生成一个，他会自动在参数后面添加一个时间戳，作用是防止缓存\n    jsonp:&quot;cb&quot; //定制一个属性名，该属性名由后端决定\n    success:function(data)&#123;\n        data    //拿到数据\n    &#125;\n&#125;)\n</code></pre>\n<h3 id=\"jsonp的缺点\"><a href=\"#jsonp的缺点\" class=\"headerlink\" title=\"jsonp的缺点\"></a>jsonp的缺点</h3><ol>\n<li><p>仅支持get请求，不支持其他请求</p>\n</li>\n<li><p>script标签发出请求本身就是get,不支持别的请求方式</p>\n</li>\n<li><p>get请求传递的数据量有限制，URL地址的长度不超过8000个字符。</p>\n</li>\n<li><p>post请求可以传递更多数据,如果确实希望跨域post提交数据，需要让后端去做CORS.</p>\n</li>\n</ol>\n"},{"title":"node 概念","date":"2019-04-12T02:41:48.000Z","_content":"\n# 01-Node.js\n\n## 概述\n\n### js为什么可以运行在浏览器\n\n+ js运行在浏览器内核进行解析\n\n+ 浏览器内核主要包括：\n\n  1. js引擎：负责解析运行js\n  2. 渲染引擎:负责渲染html和css\n\n  \n\n### Node.js是什么\n\n> Node.js是一个开发平台，在这个平台上可进行软件开发，网站开发，Node.js提供了丰富的API和优秀的运行性能。\n\n+ Node.js在平台中依然使用的是js（除了DOM和BOM），提供了一套内置的API\n\n  \n\n### Node.js可以做什么\n\n1. 服务端Web开发，做动态网站，操作数据库\n2. 服务端后台接口API项目\n3. 桌面程序（客户端程序）\n4. 命令行工具\n5. App（移动端应用）\n\n\n\n### Node.js核心模块\n\n+ 功能：文件操作，网络通信，进程管理等。\n\n### Node.js的运行方式\n\n+ 交互式命令方式\n+ 运行js文件\n\n\n\n## fs模块\n\n> 文件系统(file System) \n\n+ 使用\n\n  + 读取文件\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    \n    2.读取\n    fd.readFile('路径'，\"utf-8\",function(err,data){\n        console.log(data) //文件的内容\n        console.log(err) //成功为null\n    })\n    ```\n\n  + 写文件\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    \n    2.写\n    fs.writeFile('路径','内容','utf-8',function(err){\n    \tconsole.log(err) //成功为null\n    })\n    ```\n\n  + 同步的方式读写\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    2.读文件\n    var res = fs.readFileSync('路径','utf-8')\n    ```\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    2.写\n    fs.writeFileSync('路径'，'内容','utf-8') //返回值为undefined\n    ```\n\n\n\n\n## path模块\n\n+ 处理文件路径的模块\n\n  \n\n+ 使用\n\n  ```js\n  1.导入\n  var path = require('path')\n  \n  2.拼接路径的同时规范化路径\n  var str = path.join(__dirname,'路径1','路径2')\n  \n  3.返回文件名\n  path.basename(\"路径\")\n  \n  4.返回扩展名\n  path.extname(\"路径\")\n  \n  5.返回一个文件路径对象\n  path.parse(\"路径\")\n  \n  6.把对象转换为字符串路径\n  path.format({\n      dir:\"D:\" //根目录\n      base:\"文件名\"\n  })\n  ```\n\n\n\n## http模块\n\n+ 服务器提供Web服务基本流程\n\n+ 使用\n\n  ```js\n  1.导入\n  var http = require('http')\n  \n  2.创建服务器实例\n  var server = http.createServer()\n  \n  3.监听一个端口,不可使用0-1024\n  server.listen(3000,function(){\n  \tconsole.log('服务器启动成功')\n  })\n  \n  4.客户端请求时触发\n  server.on('request',function(req,res){\n      res.end('你好') //结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。\n      req.method //获取请求方式\n      req.url //获取请求路径\n  })\n  ```\n\n\n\n\n## 全局属性\n\n```jsx\n__dirname //获取当前路径\n```\n\n\n\n## 图书接口案例\n\n+ 需求\n  1. 根据不同的请求路径，配置不同路径地址\n  2. 读取图书列表，并显示到页面，当传参时怎么判断url地址？\n  3. 删除图书，先读取图书，然后获取请求参数id,根据id删除图书，在写回文件\n\n\n\n## 提取css,js\n\n+ 步骤\n  1. 导入模块\n  2. 使用path拼接一个路径\n  3. 读取html页面\n  4. 使用正则匹配要提取的内容\n  5. 将内容写入到拼接好的那个路径里\n  6. 替换html中的内容，并写入文件\n\n## new知识\n\n+ 正则\n\n  ```js\n  \\s : 空格\n  \\S : 所有字符串除了空格\n  \n  正则.exec(内容)： 提取符合规则的内容，返回值是数组，\n  下标0是匹配到的所有内容，父串\n  下标1是下标0的子串\n  ```\n\n\n## ？\n\n+ 关于路径中斜杠问题\n\n  ```js\n  1.windows中的斜杠是右斜杠 \\\n  2.unix/lunux的斜杠是左斜 /\n  \n  使用path模块根据系统自动识别使用左斜杠还是右斜杠\n  __dirname + path.sep + '文件名'\n  ```\n\n  ","source":"_posts/笔记/ocean/10-node.js总结/01-什么是node.js/01-笔记.md","raw":"---\ntitle: node 概念\ndate: 2019-04-12 10:41:48\ncategories:\n- 笔记\n- node\ntags:\n- 前端\n- node\n---\n\n# 01-Node.js\n\n## 概述\n\n### js为什么可以运行在浏览器\n\n+ js运行在浏览器内核进行解析\n\n+ 浏览器内核主要包括：\n\n  1. js引擎：负责解析运行js\n  2. 渲染引擎:负责渲染html和css\n\n  \n\n### Node.js是什么\n\n> Node.js是一个开发平台，在这个平台上可进行软件开发，网站开发，Node.js提供了丰富的API和优秀的运行性能。\n\n+ Node.js在平台中依然使用的是js（除了DOM和BOM），提供了一套内置的API\n\n  \n\n### Node.js可以做什么\n\n1. 服务端Web开发，做动态网站，操作数据库\n2. 服务端后台接口API项目\n3. 桌面程序（客户端程序）\n4. 命令行工具\n5. App（移动端应用）\n\n\n\n### Node.js核心模块\n\n+ 功能：文件操作，网络通信，进程管理等。\n\n### Node.js的运行方式\n\n+ 交互式命令方式\n+ 运行js文件\n\n\n\n## fs模块\n\n> 文件系统(file System) \n\n+ 使用\n\n  + 读取文件\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    \n    2.读取\n    fd.readFile('路径'，\"utf-8\",function(err,data){\n        console.log(data) //文件的内容\n        console.log(err) //成功为null\n    })\n    ```\n\n  + 写文件\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    \n    2.写\n    fs.writeFile('路径','内容','utf-8',function(err){\n    \tconsole.log(err) //成功为null\n    })\n    ```\n\n  + 同步的方式读写\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    2.读文件\n    var res = fs.readFileSync('路径','utf-8')\n    ```\n\n    ```js\n    1.导入\n    const fs = require('fs')\n    \n    2.写\n    fs.writeFileSync('路径'，'内容','utf-8') //返回值为undefined\n    ```\n\n\n\n\n## path模块\n\n+ 处理文件路径的模块\n\n  \n\n+ 使用\n\n  ```js\n  1.导入\n  var path = require('path')\n  \n  2.拼接路径的同时规范化路径\n  var str = path.join(__dirname,'路径1','路径2')\n  \n  3.返回文件名\n  path.basename(\"路径\")\n  \n  4.返回扩展名\n  path.extname(\"路径\")\n  \n  5.返回一个文件路径对象\n  path.parse(\"路径\")\n  \n  6.把对象转换为字符串路径\n  path.format({\n      dir:\"D:\" //根目录\n      base:\"文件名\"\n  })\n  ```\n\n\n\n## http模块\n\n+ 服务器提供Web服务基本流程\n\n+ 使用\n\n  ```js\n  1.导入\n  var http = require('http')\n  \n  2.创建服务器实例\n  var server = http.createServer()\n  \n  3.监听一个端口,不可使用0-1024\n  server.listen(3000,function(){\n  \tconsole.log('服务器启动成功')\n  })\n  \n  4.客户端请求时触发\n  server.on('request',function(req,res){\n      res.end('你好') //结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。\n      req.method //获取请求方式\n      req.url //获取请求路径\n  })\n  ```\n\n\n\n\n## 全局属性\n\n```jsx\n__dirname //获取当前路径\n```\n\n\n\n## 图书接口案例\n\n+ 需求\n  1. 根据不同的请求路径，配置不同路径地址\n  2. 读取图书列表，并显示到页面，当传参时怎么判断url地址？\n  3. 删除图书，先读取图书，然后获取请求参数id,根据id删除图书，在写回文件\n\n\n\n## 提取css,js\n\n+ 步骤\n  1. 导入模块\n  2. 使用path拼接一个路径\n  3. 读取html页面\n  4. 使用正则匹配要提取的内容\n  5. 将内容写入到拼接好的那个路径里\n  6. 替换html中的内容，并写入文件\n\n## new知识\n\n+ 正则\n\n  ```js\n  \\s : 空格\n  \\S : 所有字符串除了空格\n  \n  正则.exec(内容)： 提取符合规则的内容，返回值是数组，\n  下标0是匹配到的所有内容，父串\n  下标1是下标0的子串\n  ```\n\n\n## ？\n\n+ 关于路径中斜杠问题\n\n  ```js\n  1.windows中的斜杠是右斜杠 \\\n  2.unix/lunux的斜杠是左斜 /\n  \n  使用path模块根据系统自动识别使用左斜杠还是右斜杠\n  __dirname + path.sep + '文件名'\n  ```\n\n  ","slug":"笔记/ocean/10-node.js总结/01-什么是node.js/01-笔记","published":1,"updated":"2023-03-01T07:11:05.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe400a6awaf4c90h732","content":"<h1 id=\"01-Node-js\"><a href=\"#01-Node-js\" class=\"headerlink\" title=\"01-Node.js\"></a>01-Node.js</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"js为什么可以运行在浏览器\"><a href=\"#js为什么可以运行在浏览器\" class=\"headerlink\" title=\"js为什么可以运行在浏览器\"></a>js为什么可以运行在浏览器</h3><ul>\n<li><p>js运行在浏览器内核进行解析</p>\n</li>\n<li><p>浏览器内核主要包括：</p>\n<ol>\n<li>js引擎：负责解析运行js</li>\n<li>渲染引擎:负责渲染html和css</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"Node-js是什么\"><a href=\"#Node-js是什么\" class=\"headerlink\" title=\"Node.js是什么\"></a>Node.js是什么</h3><blockquote>\n<p>Node.js是一个开发平台，在这个平台上可进行软件开发，网站开发，Node.js提供了丰富的API和优秀的运行性能。</p>\n</blockquote>\n<ul>\n<li>Node.js在平台中依然使用的是js（除了DOM和BOM），提供了一套内置的API</li>\n</ul>\n<h3 id=\"Node-js可以做什么\"><a href=\"#Node-js可以做什么\" class=\"headerlink\" title=\"Node.js可以做什么\"></a>Node.js可以做什么</h3><ol>\n<li>服务端Web开发，做动态网站，操作数据库</li>\n<li>服务端后台接口API项目</li>\n<li>桌面程序（客户端程序）</li>\n<li>命令行工具</li>\n<li>App（移动端应用）</li>\n</ol>\n<h3 id=\"Node-js核心模块\"><a href=\"#Node-js核心模块\" class=\"headerlink\" title=\"Node.js核心模块\"></a>Node.js核心模块</h3><ul>\n<li>功能：文件操作，网络通信，进程管理等。</li>\n</ul>\n<h3 id=\"Node-js的运行方式\"><a href=\"#Node-js的运行方式\" class=\"headerlink\" title=\"Node.js的运行方式\"></a>Node.js的运行方式</h3><ul>\n<li>交互式命令方式</li>\n<li>运行js文件</li>\n</ul>\n<h2 id=\"fs模块\"><a href=\"#fs模块\" class=\"headerlink\" title=\"fs模块\"></a>fs模块</h2><blockquote>\n<p>文件系统(file System) </p>\n</blockquote>\n<ul>\n<li><p>使用</p>\n<ul>\n<li><p>读取文件</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n\n2.读取\nfd.readFile(&#39;路径&#39;，&quot;utf-8&quot;,function(err,data)&#123;\n    console.log(data) //文件的内容\n    console.log(err) //成功为null\n&#125;)\n</code></pre>\n</li>\n<li><p>写文件</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n\n2.写\nfs.writeFile(&#39;路径&#39;,&#39;内容&#39;,&#39;utf-8&#39;,function(err)&#123;\n    console.log(err) //成功为null\n&#125;)\n</code></pre>\n</li>\n<li><p>同步的方式读写</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n2.读文件\nvar res = fs.readFileSync(&#39;路径&#39;,&#39;utf-8&#39;)\n</code></pre>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n2.写\nfs.writeFileSync(&#39;路径&#39;，&#39;内容&#39;,&#39;utf-8&#39;) //返回值为undefined\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"path模块\"><a href=\"#path模块\" class=\"headerlink\" title=\"path模块\"></a>path模块</h2><ul>\n<li><p>处理文件路径的模块</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nvar path = require(&#39;path&#39;)\n\n2.拼接路径的同时规范化路径\nvar str = path.join(__dirname,&#39;路径1&#39;,&#39;路径2&#39;)\n\n3.返回文件名\npath.basename(&quot;路径&quot;)\n\n4.返回扩展名\npath.extname(&quot;路径&quot;)\n\n5.返回一个文件路径对象\npath.parse(&quot;路径&quot;)\n\n6.把对象转换为字符串路径\npath.format(&#123;\n    dir:&quot;D:&quot; //根目录\n    base:&quot;文件名&quot;\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h2><ul>\n<li><p>服务器提供Web服务基本流程</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nvar http = require(&#39;http&#39;)\n\n2.创建服务器实例\nvar server = http.createServer()\n\n3.监听一个端口,不可使用0-1024\nserver.listen(3000,function()&#123;\n    console.log(&#39;服务器启动成功&#39;)\n&#125;)\n\n4.客户端请求时触发\nserver.on(&#39;request&#39;,function(req,res)&#123;\n    res.end(&#39;你好&#39;) //结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。\n    req.method //获取请求方式\n    req.url //获取请求路径\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"全局属性\"><a href=\"#全局属性\" class=\"headerlink\" title=\"全局属性\"></a>全局属性</h2><pre><code class=\"jsx\">__dirname //获取当前路径\n</code></pre>\n<h2 id=\"图书接口案例\"><a href=\"#图书接口案例\" class=\"headerlink\" title=\"图书接口案例\"></a>图书接口案例</h2><ul>\n<li>需求<ol>\n<li>根据不同的请求路径，配置不同路径地址</li>\n<li>读取图书列表，并显示到页面，当传参时怎么判断url地址？</li>\n<li>删除图书，先读取图书，然后获取请求参数id,根据id删除图书，在写回文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"提取css-js\"><a href=\"#提取css-js\" class=\"headerlink\" title=\"提取css,js\"></a>提取css,js</h2><ul>\n<li>步骤<ol>\n<li>导入模块</li>\n<li>使用path拼接一个路径</li>\n<li>读取html页面</li>\n<li>使用正则匹配要提取的内容</li>\n<li>将内容写入到拼接好的那个路径里</li>\n<li>替换html中的内容，并写入文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"new知识\"><a href=\"#new知识\" class=\"headerlink\" title=\"new知识\"></a>new知识</h2><ul>\n<li><p>正则</p>\n<pre><code class=\"js\">\\s : 空格\n\\S : 所有字符串除了空格\n\n正则.exec(内容)： 提取符合规则的内容，返回值是数组，\n下标0是匹配到的所有内容，父串\n下标1是下标0的子串\n</code></pre>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ul>\n<li><p>关于路径中斜杠问题</p>\n<pre><code class=\"js\">1.windows中的斜杠是右斜杠 \\\n2.unix/lunux的斜杠是左斜 /\n\n使用path模块根据系统自动识别使用左斜杠还是右斜杠\n__dirname + path.sep + &#39;文件名&#39;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-Node-js\"><a href=\"#01-Node-js\" class=\"headerlink\" title=\"01-Node.js\"></a>01-Node.js</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"js为什么可以运行在浏览器\"><a href=\"#js为什么可以运行在浏览器\" class=\"headerlink\" title=\"js为什么可以运行在浏览器\"></a>js为什么可以运行在浏览器</h3><ul>\n<li><p>js运行在浏览器内核进行解析</p>\n</li>\n<li><p>浏览器内核主要包括：</p>\n<ol>\n<li>js引擎：负责解析运行js</li>\n<li>渲染引擎:负责渲染html和css</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"Node-js是什么\"><a href=\"#Node-js是什么\" class=\"headerlink\" title=\"Node.js是什么\"></a>Node.js是什么</h3><blockquote>\n<p>Node.js是一个开发平台，在这个平台上可进行软件开发，网站开发，Node.js提供了丰富的API和优秀的运行性能。</p>\n</blockquote>\n<ul>\n<li>Node.js在平台中依然使用的是js（除了DOM和BOM），提供了一套内置的API</li>\n</ul>\n<h3 id=\"Node-js可以做什么\"><a href=\"#Node-js可以做什么\" class=\"headerlink\" title=\"Node.js可以做什么\"></a>Node.js可以做什么</h3><ol>\n<li>服务端Web开发，做动态网站，操作数据库</li>\n<li>服务端后台接口API项目</li>\n<li>桌面程序（客户端程序）</li>\n<li>命令行工具</li>\n<li>App（移动端应用）</li>\n</ol>\n<h3 id=\"Node-js核心模块\"><a href=\"#Node-js核心模块\" class=\"headerlink\" title=\"Node.js核心模块\"></a>Node.js核心模块</h3><ul>\n<li>功能：文件操作，网络通信，进程管理等。</li>\n</ul>\n<h3 id=\"Node-js的运行方式\"><a href=\"#Node-js的运行方式\" class=\"headerlink\" title=\"Node.js的运行方式\"></a>Node.js的运行方式</h3><ul>\n<li>交互式命令方式</li>\n<li>运行js文件</li>\n</ul>\n<h2 id=\"fs模块\"><a href=\"#fs模块\" class=\"headerlink\" title=\"fs模块\"></a>fs模块</h2><blockquote>\n<p>文件系统(file System) </p>\n</blockquote>\n<ul>\n<li><p>使用</p>\n<ul>\n<li><p>读取文件</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n\n2.读取\nfd.readFile(&#39;路径&#39;，&quot;utf-8&quot;,function(err,data)&#123;\n    console.log(data) //文件的内容\n    console.log(err) //成功为null\n&#125;)\n</code></pre>\n</li>\n<li><p>写文件</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n\n2.写\nfs.writeFile(&#39;路径&#39;,&#39;内容&#39;,&#39;utf-8&#39;,function(err)&#123;\n    console.log(err) //成功为null\n&#125;)\n</code></pre>\n</li>\n<li><p>同步的方式读写</p>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n2.读文件\nvar res = fs.readFileSync(&#39;路径&#39;,&#39;utf-8&#39;)\n</code></pre>\n<pre><code class=\"js\">1.导入\nconst fs = require(&#39;fs&#39;)\n\n2.写\nfs.writeFileSync(&#39;路径&#39;，&#39;内容&#39;,&#39;utf-8&#39;) //返回值为undefined\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"path模块\"><a href=\"#path模块\" class=\"headerlink\" title=\"path模块\"></a>path模块</h2><ul>\n<li><p>处理文件路径的模块</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nvar path = require(&#39;path&#39;)\n\n2.拼接路径的同时规范化路径\nvar str = path.join(__dirname,&#39;路径1&#39;,&#39;路径2&#39;)\n\n3.返回文件名\npath.basename(&quot;路径&quot;)\n\n4.返回扩展名\npath.extname(&quot;路径&quot;)\n\n5.返回一个文件路径对象\npath.parse(&quot;路径&quot;)\n\n6.把对象转换为字符串路径\npath.format(&#123;\n    dir:&quot;D:&quot; //根目录\n    base:&quot;文件名&quot;\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h2><ul>\n<li><p>服务器提供Web服务基本流程</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nvar http = require(&#39;http&#39;)\n\n2.创建服务器实例\nvar server = http.createServer()\n\n3.监听一个端口,不可使用0-1024\nserver.listen(3000,function()&#123;\n    console.log(&#39;服务器启动成功&#39;)\n&#125;)\n\n4.客户端请求时触发\nserver.on(&#39;request&#39;,function(req,res)&#123;\n    res.end(&#39;你好&#39;) //结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。\n    req.method //获取请求方式\n    req.url //获取请求路径\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"全局属性\"><a href=\"#全局属性\" class=\"headerlink\" title=\"全局属性\"></a>全局属性</h2><pre><code class=\"jsx\">__dirname //获取当前路径\n</code></pre>\n<h2 id=\"图书接口案例\"><a href=\"#图书接口案例\" class=\"headerlink\" title=\"图书接口案例\"></a>图书接口案例</h2><ul>\n<li>需求<ol>\n<li>根据不同的请求路径，配置不同路径地址</li>\n<li>读取图书列表，并显示到页面，当传参时怎么判断url地址？</li>\n<li>删除图书，先读取图书，然后获取请求参数id,根据id删除图书，在写回文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"提取css-js\"><a href=\"#提取css-js\" class=\"headerlink\" title=\"提取css,js\"></a>提取css,js</h2><ul>\n<li>步骤<ol>\n<li>导入模块</li>\n<li>使用path拼接一个路径</li>\n<li>读取html页面</li>\n<li>使用正则匹配要提取的内容</li>\n<li>将内容写入到拼接好的那个路径里</li>\n<li>替换html中的内容，并写入文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"new知识\"><a href=\"#new知识\" class=\"headerlink\" title=\"new知识\"></a>new知识</h2><ul>\n<li><p>正则</p>\n<pre><code class=\"js\">\\s : 空格\n\\S : 所有字符串除了空格\n\n正则.exec(内容)： 提取符合规则的内容，返回值是数组，\n下标0是匹配到的所有内容，父串\n下标1是下标0的子串\n</code></pre>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ul>\n<li><p>关于路径中斜杠问题</p>\n<pre><code class=\"js\">1.windows中的斜杠是右斜杠 \\\n2.unix/lunux的斜杠是左斜 /\n\n使用path模块根据系统自动识别使用左斜杠还是右斜杠\n__dirname + path.sep + &#39;文件名&#39;\n</code></pre>\n</li>\n</ul>\n"},{"title":"node 模块化","date":"2019-04-12T02:41:48.000Z","_content":"\n# 02-Node.js\n\n## 模块化开发\n\n### 什么是模块化\n\n> 一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块\n\n+ 优点\n\n  1. 提高代码复用率\n\n  2. 提高了可维护性\n\n  3. 实现按需加载\n\n  4. 避免函数名变量冲突\n\n     \n\n### 模块化规范\n\n+ 为什么需要模块化规范\n\n> 模块与模块之间要有隔离，并模块之间需要有交互\n\n\n\n- 浏览器端模块化规范\n  - AMD --> requireJS\n  - CMD --> Sea.js\n- 服务器端模块化规范\n  - CommonJS --> Node.js \n- ES6本身提供了模块化 ESM\n  - Vue/React项目中会大量使用\n\n\n\n\n\n\n\n## Node.js模块化\n\n+ 什么是Node.js模块化\n\n> 在node.js中，一个js文件就是一个模块，模块之间存在隔离，且模块之间可以交互\n\n### 模块类型\n\n1. Node.js内置核心模块\n2. .js模块：自定义模块\n3. json模块：自定义模块，主要用来提供数据\n4. .node模块：二进制，基于C/C++开发的，编译后形成模块\n\n\n\n\n\n### CommonJS模块化规则\n\n+ 导出\n\n  ```js\n  1.方式1\n  module.exports = {\n      a:a\n  } //可以为变量，对象，方法，函数，等。\n  \n  \n  2.方式2\n  module.exports.名字 = 值\n  \n  3.方式3\n  exports.名字 = 值 // exports = module.exports = {}\n  \n  错误写法:\n  exports = {\n      \n  }\n  原因：最终导出以module.exports为准，而exports只是一个别名，当把对象赋值给exports时，它的指向就不在指向module.exports，而指向了新对象。\n  ```\n\n+ 导入\n\n  ```js\n  var obj = require('路径')\n  ```\n\n\n\n## Node.js模块的循环调用\n\n> 如果node.js中两个模块循环调用，是否会造成死循环？\n\n+ 不会，nodejs有防止死循环机制 \n\n\n\n\n\n## 包\n\n+ 什么是包\n\n  > 一个js文件是一个模块，一般一个模块只做一件事情，那么包可以看作是将模块，代码，和其它资源组合而成的一个更大的模块\n\n+ 功能\n\n  可以实现更加复杂，完善的功能模块，方便代码复用，更加效率\n\n\n\n\n\n### npm\n\n> npm是一个网站，托管所有的包，方便用户发布包和搜索包\n>\n> npm:是一个包管理工具（Node Package Manager）,随Node.js安装包安装，可进行下载安装，更新，卸载，发布。\n\n+ 类似npm的还有yaar\n\n\n\n#### 常用操作\n\n```js\n1.初始化文件\nnpm init -y  //自动生成配置文件\n\n2.安装包\nnpm install express //npm i 包名\n\n3.导入包\nconst express = require('express')\n```\n\n+ 安装包\n\n  1. 本地安装\n\n     + 安装到项目里\n\n     ```js\n     npm install  包名  //默认安装到生产依赖\n     npm add  包名\n     npm i 包名\n     npm install  包名@版本号 //安装指定版本号 \n     \n     \n     npm install //安装package.json文件中所有依赖的包(开发依赖和生产依赖)\n     npm i --production //只安装生产依赖的包\n     \n     \n     //安装包时只记录到开发依赖\n     npm  i  -D\n     npm  i --save-dev\n     //安装到生产依赖和开发依赖\n     npm i -S\n     npm  i --save\n     \n     \n     ```\n\n  2. 全局安装\n\n     + 安装到node.js目录里的node_modules文件里，一般安装需要命令执行的包\n\n     ```js\n     npm i 包名 -g //全局安装\n     ```\n\n     \n\n  \n\n+ 卸载包\n\n  + 本地卸载\n\n    ```js\n    npm uninstall 包名 \n    npm un 包名\n    npm remove 包名\n    ```\n\n  + 全局卸载\n\n    ```js\n    npm uninstall 包名 -g \n    npm un 包名 -g\n    npm remove 包名 -g\n    ```\n\n    \n\n+ 更新包\n\n  前提条件：根目录必须有package.json文件\n\n  ```jsx\n  npm update 包名 //将包更新到最新版本\n  npm up 包名 \n  ```\n\n\n\n###package.json文件描述\n\n```js\n{\n  \"name\": \"y\", //包的名称，有唯一性\n  \"version\": \"1.0.0\", //包的版本号\n  \"description\": \"\", //介绍包的功能描述\n  \"main\": \"index.js\", //包的默认执行的文件，包的入口\n \n  \"scripts\": { //脚本，相当于给命令起个别名，运行test的时候执行它的值，可自定义多条命令\n    \"test\": \"命令\"\n  },\n      \n  \"keywords\":[\"关键字1\",\"关键字2\"], //包被搜索的关键字\n  \"author\": \"\", //包的作者\n  \"license\": \"ISC\", //包遵循的开源协议、\n    \n   \"dependencies\":{ //生产依赖，在开发和上线后都必须使用的包，程序正常运行的包\n        \n    },\n    \n   \"devDependencies\":{ //开发依赖，在开发时需要使用的包，工具，测试类的包\n        dfdf:''\n    }\n}\n```\n\n\n\n\n\n###package-lock.json文件\n\n> 记录包的依赖关系，版本信息，依赖顺序等，防止版本更新导致API变化的问题,此文件不要更改\n\n\n\n### 解决下包慢\n\n+ 为什么下包慢？\n\n  因为下载网址的服务器在国外\n\n+ 解决\n\n  1. [使用淘宝镜像](registry=https://registry.npm.taobao.org/)，淘宝镜像10分钟更新一次\n\n     - 使用\n\n       ```js\n       npm config set registry=https://registry.npm.taobao.org/ //配置\n       \n       npm config get registry //查看是否配置成功\n       \n       npm i 包名 //直接使用安装\n       ```\n\n  2. 使用nrm\n\n     + 如果需要管理各种镜像，可以使用nrm命令行工具\n\n       ```js\n       1.下载nrm\n       npm i nrm -g\n       \n       2.查询所有镜像\n       nrm ls\n       \n       3.切换镜像名称\n       nrm use 名称\n       \n       4.新增镜像源\n       nrm add 别名  地址\n       \n       5.删除镜像源\n       nrm del 别名\n       \n       6.测试镜像源的响应速度\n       nrm test 别名\n       ```\n\n  3. 安装cnpm\n\n     ```js\n     npm install -g cnpm --registry=https://registry.npm.taobao.org\n     ```\n\n     \n\n\n\n\n## 开发一个包\n\n###创建一个包\n\n+ 包的标准\n  1. 包必须是单独的目录\n  2. 项目的根目录必须有package.js包管理配置文件\n  3. 设置name，version，main\n  4. 创建readme.md文件（可有可无），包的使用说明\n\n\n\n### 发布包\n\n 1. 注册npm账号\n\n 2. 切换到npm镜像，用命令行登录\n\n    ```js\n    npm login //登录命令\n    ```\n\n    3. 发布包\n\n    ```js\n    npm publish //发布包\n    ```\n\n    \n\n###删除包\n\n- 超过3天后包将永久不可删除\n\n```js\nnpm unpublish 包名 --force //只能删除72小时以内发布的包,以删除的包不允许在24小时内重复发布\n```\n\n\n\n## 模块和包的加载机制\n\n###普通机制加载机制\n\n1. 只要把模块require进来，那么代码就会执行，与有没有module.exports导出没有关系\n2. 多次导入同一个模块只会执行1次，因为有node.js有缓存机制，会根据路径，文件位置，名字来判断是否为同一模块。\n\n###内置模块加载机制\n\n1. 当自定义模块名和内置模块名重复且导入时，优先使用内置模块\n\n###自定义模块加载机制\n\n1. 导入模块时不写后缀名，优先加载后缀为js的文件\n\n###第三方模块(包)加载机制\n\n1. 如果传递给 require() 的模块标识符不是一个内置模块，也没有以'./' 或 '../' 开头，会先在项目根目录中找node_module目录中的包没有则../，会一级一级向上找node_module目录中的包\n\n### 目录作为模块加载机制\n\n1. 导入时，会默认找package.json配置文件中main 的指定文件\n2. 如果没有package.json配置文件，那么会去找index.js\n\n\n\n\n\n\n\n\n\n\n\n## ？\n\n1. 全局模块可以本地导入吗？\n\n   不可，全局模块仅仅用来做命令\n\n2. import和require的区别\n\n   import是es6提供的\n\n\n\n3. npm  下包时报错\n\n   ```js\n   unable to verify the first certificate//无法验证第一个证书\n   ```\n\n   + 解决\n\n     ```js\n     取消ssl验证：npm config set strict-ssl false\n     ```\n\n     \n\n\n\n\n\n\n\n","source":"_posts/笔记/ocean/10-node.js总结/02-模块化开发和包/02-笔记.md","raw":"---\ntitle: node 模块化\ndate: 2019-04-12 10:41:48\ncategories:\n- 笔记\n- node\ntags:\n- 前端\n- node\n---\n\n# 02-Node.js\n\n## 模块化开发\n\n### 什么是模块化\n\n> 一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块\n\n+ 优点\n\n  1. 提高代码复用率\n\n  2. 提高了可维护性\n\n  3. 实现按需加载\n\n  4. 避免函数名变量冲突\n\n     \n\n### 模块化规范\n\n+ 为什么需要模块化规范\n\n> 模块与模块之间要有隔离，并模块之间需要有交互\n\n\n\n- 浏览器端模块化规范\n  - AMD --> requireJS\n  - CMD --> Sea.js\n- 服务器端模块化规范\n  - CommonJS --> Node.js \n- ES6本身提供了模块化 ESM\n  - Vue/React项目中会大量使用\n\n\n\n\n\n\n\n## Node.js模块化\n\n+ 什么是Node.js模块化\n\n> 在node.js中，一个js文件就是一个模块，模块之间存在隔离，且模块之间可以交互\n\n### 模块类型\n\n1. Node.js内置核心模块\n2. .js模块：自定义模块\n3. json模块：自定义模块，主要用来提供数据\n4. .node模块：二进制，基于C/C++开发的，编译后形成模块\n\n\n\n\n\n### CommonJS模块化规则\n\n+ 导出\n\n  ```js\n  1.方式1\n  module.exports = {\n      a:a\n  } //可以为变量，对象，方法，函数，等。\n  \n  \n  2.方式2\n  module.exports.名字 = 值\n  \n  3.方式3\n  exports.名字 = 值 // exports = module.exports = {}\n  \n  错误写法:\n  exports = {\n      \n  }\n  原因：最终导出以module.exports为准，而exports只是一个别名，当把对象赋值给exports时，它的指向就不在指向module.exports，而指向了新对象。\n  ```\n\n+ 导入\n\n  ```js\n  var obj = require('路径')\n  ```\n\n\n\n## Node.js模块的循环调用\n\n> 如果node.js中两个模块循环调用，是否会造成死循环？\n\n+ 不会，nodejs有防止死循环机制 \n\n\n\n\n\n## 包\n\n+ 什么是包\n\n  > 一个js文件是一个模块，一般一个模块只做一件事情，那么包可以看作是将模块，代码，和其它资源组合而成的一个更大的模块\n\n+ 功能\n\n  可以实现更加复杂，完善的功能模块，方便代码复用，更加效率\n\n\n\n\n\n### npm\n\n> npm是一个网站，托管所有的包，方便用户发布包和搜索包\n>\n> npm:是一个包管理工具（Node Package Manager）,随Node.js安装包安装，可进行下载安装，更新，卸载，发布。\n\n+ 类似npm的还有yaar\n\n\n\n#### 常用操作\n\n```js\n1.初始化文件\nnpm init -y  //自动生成配置文件\n\n2.安装包\nnpm install express //npm i 包名\n\n3.导入包\nconst express = require('express')\n```\n\n+ 安装包\n\n  1. 本地安装\n\n     + 安装到项目里\n\n     ```js\n     npm install  包名  //默认安装到生产依赖\n     npm add  包名\n     npm i 包名\n     npm install  包名@版本号 //安装指定版本号 \n     \n     \n     npm install //安装package.json文件中所有依赖的包(开发依赖和生产依赖)\n     npm i --production //只安装生产依赖的包\n     \n     \n     //安装包时只记录到开发依赖\n     npm  i  -D\n     npm  i --save-dev\n     //安装到生产依赖和开发依赖\n     npm i -S\n     npm  i --save\n     \n     \n     ```\n\n  2. 全局安装\n\n     + 安装到node.js目录里的node_modules文件里，一般安装需要命令执行的包\n\n     ```js\n     npm i 包名 -g //全局安装\n     ```\n\n     \n\n  \n\n+ 卸载包\n\n  + 本地卸载\n\n    ```js\n    npm uninstall 包名 \n    npm un 包名\n    npm remove 包名\n    ```\n\n  + 全局卸载\n\n    ```js\n    npm uninstall 包名 -g \n    npm un 包名 -g\n    npm remove 包名 -g\n    ```\n\n    \n\n+ 更新包\n\n  前提条件：根目录必须有package.json文件\n\n  ```jsx\n  npm update 包名 //将包更新到最新版本\n  npm up 包名 \n  ```\n\n\n\n###package.json文件描述\n\n```js\n{\n  \"name\": \"y\", //包的名称，有唯一性\n  \"version\": \"1.0.0\", //包的版本号\n  \"description\": \"\", //介绍包的功能描述\n  \"main\": \"index.js\", //包的默认执行的文件，包的入口\n \n  \"scripts\": { //脚本，相当于给命令起个别名，运行test的时候执行它的值，可自定义多条命令\n    \"test\": \"命令\"\n  },\n      \n  \"keywords\":[\"关键字1\",\"关键字2\"], //包被搜索的关键字\n  \"author\": \"\", //包的作者\n  \"license\": \"ISC\", //包遵循的开源协议、\n    \n   \"dependencies\":{ //生产依赖，在开发和上线后都必须使用的包，程序正常运行的包\n        \n    },\n    \n   \"devDependencies\":{ //开发依赖，在开发时需要使用的包，工具，测试类的包\n        dfdf:''\n    }\n}\n```\n\n\n\n\n\n###package-lock.json文件\n\n> 记录包的依赖关系，版本信息，依赖顺序等，防止版本更新导致API变化的问题,此文件不要更改\n\n\n\n### 解决下包慢\n\n+ 为什么下包慢？\n\n  因为下载网址的服务器在国外\n\n+ 解决\n\n  1. [使用淘宝镜像](registry=https://registry.npm.taobao.org/)，淘宝镜像10分钟更新一次\n\n     - 使用\n\n       ```js\n       npm config set registry=https://registry.npm.taobao.org/ //配置\n       \n       npm config get registry //查看是否配置成功\n       \n       npm i 包名 //直接使用安装\n       ```\n\n  2. 使用nrm\n\n     + 如果需要管理各种镜像，可以使用nrm命令行工具\n\n       ```js\n       1.下载nrm\n       npm i nrm -g\n       \n       2.查询所有镜像\n       nrm ls\n       \n       3.切换镜像名称\n       nrm use 名称\n       \n       4.新增镜像源\n       nrm add 别名  地址\n       \n       5.删除镜像源\n       nrm del 别名\n       \n       6.测试镜像源的响应速度\n       nrm test 别名\n       ```\n\n  3. 安装cnpm\n\n     ```js\n     npm install -g cnpm --registry=https://registry.npm.taobao.org\n     ```\n\n     \n\n\n\n\n## 开发一个包\n\n###创建一个包\n\n+ 包的标准\n  1. 包必须是单独的目录\n  2. 项目的根目录必须有package.js包管理配置文件\n  3. 设置name，version，main\n  4. 创建readme.md文件（可有可无），包的使用说明\n\n\n\n### 发布包\n\n 1. 注册npm账号\n\n 2. 切换到npm镜像，用命令行登录\n\n    ```js\n    npm login //登录命令\n    ```\n\n    3. 发布包\n\n    ```js\n    npm publish //发布包\n    ```\n\n    \n\n###删除包\n\n- 超过3天后包将永久不可删除\n\n```js\nnpm unpublish 包名 --force //只能删除72小时以内发布的包,以删除的包不允许在24小时内重复发布\n```\n\n\n\n## 模块和包的加载机制\n\n###普通机制加载机制\n\n1. 只要把模块require进来，那么代码就会执行，与有没有module.exports导出没有关系\n2. 多次导入同一个模块只会执行1次，因为有node.js有缓存机制，会根据路径，文件位置，名字来判断是否为同一模块。\n\n###内置模块加载机制\n\n1. 当自定义模块名和内置模块名重复且导入时，优先使用内置模块\n\n###自定义模块加载机制\n\n1. 导入模块时不写后缀名，优先加载后缀为js的文件\n\n###第三方模块(包)加载机制\n\n1. 如果传递给 require() 的模块标识符不是一个内置模块，也没有以'./' 或 '../' 开头，会先在项目根目录中找node_module目录中的包没有则../，会一级一级向上找node_module目录中的包\n\n### 目录作为模块加载机制\n\n1. 导入时，会默认找package.json配置文件中main 的指定文件\n2. 如果没有package.json配置文件，那么会去找index.js\n\n\n\n\n\n\n\n\n\n\n\n## ？\n\n1. 全局模块可以本地导入吗？\n\n   不可，全局模块仅仅用来做命令\n\n2. import和require的区别\n\n   import是es6提供的\n\n\n\n3. npm  下包时报错\n\n   ```js\n   unable to verify the first certificate//无法验证第一个证书\n   ```\n\n   + 解决\n\n     ```js\n     取消ssl验证：npm config set strict-ssl false\n     ```\n\n     \n\n\n\n\n\n\n\n","slug":"笔记/ocean/10-node.js总结/02-模块化开发和包/02-笔记","published":1,"updated":"2023-03-01T07:11:23.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe400a9awafgrio9ymw","content":"<h1 id=\"02-Node-js\"><a href=\"#02-Node-js\" class=\"headerlink\" title=\"02-Node.js\"></a>02-Node.js</h1><h2 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h2><h3 id=\"什么是模块化\"><a href=\"#什么是模块化\" class=\"headerlink\" title=\"什么是模块化\"></a>什么是模块化</h3><blockquote>\n<p>一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块</p>\n</blockquote>\n<ul>\n<li><p>优点</p>\n<ol>\n<li><p>提高代码复用率</p>\n</li>\n<li><p>提高了可维护性</p>\n</li>\n<li><p>实现按需加载</p>\n</li>\n<li><p>避免函数名变量冲突</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h3><ul>\n<li>为什么需要模块化规范</li>\n</ul>\n<blockquote>\n<p>模块与模块之间要有隔离，并模块之间需要有交互</p>\n</blockquote>\n<ul>\n<li>浏览器端模块化规范<ul>\n<li>AMD –&gt; requireJS</li>\n<li>CMD –&gt; Sea.js</li>\n</ul>\n</li>\n<li>服务器端模块化规范<ul>\n<li>CommonJS –&gt; Node.js </li>\n</ul>\n</li>\n<li>ES6本身提供了模块化 ESM<ul>\n<li>Vue/React项目中会大量使用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Node-js模块化\"><a href=\"#Node-js模块化\" class=\"headerlink\" title=\"Node.js模块化\"></a>Node.js模块化</h2><ul>\n<li>什么是Node.js模块化</li>\n</ul>\n<blockquote>\n<p>在node.js中，一个js文件就是一个模块，模块之间存在隔离，且模块之间可以交互</p>\n</blockquote>\n<h3 id=\"模块类型\"><a href=\"#模块类型\" class=\"headerlink\" title=\"模块类型\"></a>模块类型</h3><ol>\n<li>Node.js内置核心模块</li>\n<li>.js模块：自定义模块</li>\n<li>json模块：自定义模块，主要用来提供数据</li>\n<li>.node模块：二进制，基于C/C++开发的，编译后形成模块</li>\n</ol>\n<h3 id=\"CommonJS模块化规则\"><a href=\"#CommonJS模块化规则\" class=\"headerlink\" title=\"CommonJS模块化规则\"></a>CommonJS模块化规则</h3><ul>\n<li><p>导出</p>\n<pre><code class=\"js\">1.方式1\nmodule.exports = &#123;\n    a:a\n&#125; //可以为变量，对象，方法，函数，等。\n\n\n2.方式2\nmodule.exports.名字 = 值\n\n3.方式3\nexports.名字 = 值 // exports = module.exports = &#123;&#125;\n\n错误写法:\nexports = &#123;\n    \n&#125;\n原因：最终导出以module.exports为准，而exports只是一个别名，当把对象赋值给exports时，它的指向就不在指向module.exports，而指向了新对象。\n</code></pre>\n</li>\n<li><p>导入</p>\n<pre><code class=\"js\">var obj = require(&#39;路径&#39;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Node-js模块的循环调用\"><a href=\"#Node-js模块的循环调用\" class=\"headerlink\" title=\"Node.js模块的循环调用\"></a>Node.js模块的循环调用</h2><blockquote>\n<p>如果node.js中两个模块循环调用，是否会造成死循环？</p>\n</blockquote>\n<ul>\n<li>不会，nodejs有防止死循环机制 </li>\n</ul>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><ul>\n<li><p>什么是包</p>\n<blockquote>\n<p>一个js文件是一个模块，一般一个模块只做一件事情，那么包可以看作是将模块，代码，和其它资源组合而成的一个更大的模块</p>\n</blockquote>\n</li>\n<li><p>功能</p>\n<p>可以实现更加复杂，完善的功能模块，方便代码复用，更加效率</p>\n</li>\n</ul>\n<h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><blockquote>\n<p>npm是一个网站，托管所有的包，方便用户发布包和搜索包</p>\n<p>npm:是一个包管理工具（Node Package Manager）,随Node.js安装包安装，可进行下载安装，更新，卸载，发布。</p>\n</blockquote>\n<ul>\n<li>类似npm的还有yaar</li>\n</ul>\n<h4 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><pre><code class=\"js\">1.初始化文件\nnpm init -y  //自动生成配置文件\n\n2.安装包\nnpm install express //npm i 包名\n\n3.导入包\nconst express = require(&#39;express&#39;)\n</code></pre>\n<ul>\n<li><p>安装包</p>\n<ol>\n<li><p>本地安装</p>\n<ul>\n<li>安装到项目里</li>\n</ul>\n<pre><code class=\"js\">npm install  包名  //默认安装到生产依赖\nnpm add  包名\nnpm i 包名\nnpm install  包名@版本号 //安装指定版本号 \n\n\nnpm install //安装package.json文件中所有依赖的包(开发依赖和生产依赖)\nnpm i --production //只安装生产依赖的包\n\n\n//安装包时只记录到开发依赖\nnpm  i  -D\nnpm  i --save-dev\n//安装到生产依赖和开发依赖\nnpm i -S\nnpm  i --save\n\n</code></pre>\n</li>\n<li><p>全局安装</p>\n<ul>\n<li>安装到node.js目录里的node_modules文件里，一般安装需要命令执行的包</li>\n</ul>\n<pre><code class=\"js\">npm i 包名 -g //全局安装\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>卸载包</p>\n<ul>\n<li><p>本地卸载</p>\n<pre><code class=\"js\">npm uninstall 包名 \nnpm un 包名\nnpm remove 包名\n</code></pre>\n</li>\n<li><p>全局卸载</p>\n<pre><code class=\"js\">npm uninstall 包名 -g \nnpm un 包名 -g\nnpm remove 包名 -g\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>更新包</p>\n<p>前提条件：根目录必须有package.json文件</p>\n<pre><code class=\"jsx\">npm update 包名 //将包更新到最新版本\nnpm up 包名 \n</code></pre>\n</li>\n</ul>\n<p>###package.json文件描述</p>\n<pre><code class=\"js\">&#123;\n  &quot;name&quot;: &quot;y&quot;, //包的名称，有唯一性\n  &quot;version&quot;: &quot;1.0.0&quot;, //包的版本号\n  &quot;description&quot;: &quot;&quot;, //介绍包的功能描述\n  &quot;main&quot;: &quot;index.js&quot;, //包的默认执行的文件，包的入口\n \n  &quot;scripts&quot;: &#123; //脚本，相当于给命令起个别名，运行test的时候执行它的值，可自定义多条命令\n    &quot;test&quot;: &quot;命令&quot;\n  &#125;,\n      \n  &quot;keywords&quot;:[&quot;关键字1&quot;,&quot;关键字2&quot;], //包被搜索的关键字\n  &quot;author&quot;: &quot;&quot;, //包的作者\n  &quot;license&quot;: &quot;ISC&quot;, //包遵循的开源协议、\n    \n   &quot;dependencies&quot;:&#123; //生产依赖，在开发和上线后都必须使用的包，程序正常运行的包\n        \n    &#125;,\n    \n   &quot;devDependencies&quot;:&#123; //开发依赖，在开发时需要使用的包，工具，测试类的包\n        dfdf:&#39;&#39;\n    &#125;\n&#125;\n</code></pre>\n<p>###package-lock.json文件</p>\n<blockquote>\n<p>记录包的依赖关系，版本信息，依赖顺序等，防止版本更新导致API变化的问题,此文件不要更改</p>\n</blockquote>\n<h3 id=\"解决下包慢\"><a href=\"#解决下包慢\" class=\"headerlink\" title=\"解决下包慢\"></a>解决下包慢</h3><ul>\n<li><p>为什么下包慢？</p>\n<p>因为下载网址的服务器在国外</p>\n</li>\n<li><p>解决</p>\n<ol>\n<li><p><a href=\"registry=https://registry.npm.taobao.org/\">使用淘宝镜像</a>，淘宝镜像10分钟更新一次</p>\n<ul>\n<li><p>使用</p>\n<pre><code class=\"js\">npm config set registry=https://registry.npm.taobao.org/ //配置\n\nnpm config get registry //查看是否配置成功\n\nnpm i 包名 //直接使用安装\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用nrm</p>\n<ul>\n<li><p>如果需要管理各种镜像，可以使用nrm命令行工具</p>\n<pre><code class=\"js\">1.下载nrm\nnpm i nrm -g\n\n2.查询所有镜像\nnrm ls\n\n3.切换镜像名称\nnrm use 名称\n\n4.新增镜像源\nnrm add 别名  地址\n\n5.删除镜像源\nnrm del 别名\n\n6.测试镜像源的响应速度\nnrm test 别名\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>安装cnpm</p>\n<pre><code class=\"js\">npm install -g cnpm --registry=https://registry.npm.taobao.org\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"开发一个包\"><a href=\"#开发一个包\" class=\"headerlink\" title=\"开发一个包\"></a>开发一个包</h2><p>###创建一个包</p>\n<ul>\n<li>包的标准<ol>\n<li>包必须是单独的目录</li>\n<li>项目的根目录必须有package.js包管理配置文件</li>\n<li>设置name，version，main</li>\n<li>创建readme.md文件（可有可无），包的使用说明</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"发布包\"><a href=\"#发布包\" class=\"headerlink\" title=\"发布包\"></a>发布包</h3><ol>\n<li><p>注册npm账号</p>\n</li>\n<li><p>切换到npm镜像，用命令行登录</p>\n<pre><code class=\"js\">npm login //登录命令\n</code></pre>\n<ol start=\"3\">\n<li>发布包</li>\n</ol>\n<pre><code class=\"js\">npm publish //发布包\n</code></pre>\n</li>\n</ol>\n<p>###删除包</p>\n<ul>\n<li>超过3天后包将永久不可删除</li>\n</ul>\n<pre><code class=\"js\">npm unpublish 包名 --force //只能删除72小时以内发布的包,以删除的包不允许在24小时内重复发布\n</code></pre>\n<h2 id=\"模块和包的加载机制\"><a href=\"#模块和包的加载机制\" class=\"headerlink\" title=\"模块和包的加载机制\"></a>模块和包的加载机制</h2><p>###普通机制加载机制</p>\n<ol>\n<li>只要把模块require进来，那么代码就会执行，与有没有module.exports导出没有关系</li>\n<li>多次导入同一个模块只会执行1次，因为有node.js有缓存机制，会根据路径，文件位置，名字来判断是否为同一模块。</li>\n</ol>\n<p>###内置模块加载机制</p>\n<ol>\n<li>当自定义模块名和内置模块名重复且导入时，优先使用内置模块</li>\n</ol>\n<p>###自定义模块加载机制</p>\n<ol>\n<li>导入模块时不写后缀名，优先加载后缀为js的文件</li>\n</ol>\n<p>###第三方模块(包)加载机制</p>\n<ol>\n<li>如果传递给 require() 的模块标识符不是一个内置模块，也没有以’./‘ 或 ‘../‘ 开头，会先在项目根目录中找node_module目录中的包没有则../，会一级一级向上找node_module目录中的包</li>\n</ol>\n<h3 id=\"目录作为模块加载机制\"><a href=\"#目录作为模块加载机制\" class=\"headerlink\" title=\"目录作为模块加载机制\"></a>目录作为模块加载机制</h3><ol>\n<li>导入时，会默认找package.json配置文件中main 的指定文件</li>\n<li>如果没有package.json配置文件，那么会去找index.js</li>\n</ol>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>全局模块可以本地导入吗？</p>\n<p>不可，全局模块仅仅用来做命令</p>\n</li>\n<li><p>import和require的区别</p>\n<p>import是es6提供的</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>npm  下包时报错</p>\n<pre><code class=\"js\">unable to verify the first certificate//无法验证第一个证书\n</code></pre>\n<ul>\n<li><p>解决</p>\n<pre><code class=\"js\">取消ssl验证：npm config set strict-ssl false\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-Node-js\"><a href=\"#02-Node-js\" class=\"headerlink\" title=\"02-Node.js\"></a>02-Node.js</h1><h2 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h2><h3 id=\"什么是模块化\"><a href=\"#什么是模块化\" class=\"headerlink\" title=\"什么是模块化\"></a>什么是模块化</h3><blockquote>\n<p>一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块</p>\n</blockquote>\n<ul>\n<li><p>优点</p>\n<ol>\n<li><p>提高代码复用率</p>\n</li>\n<li><p>提高了可维护性</p>\n</li>\n<li><p>实现按需加载</p>\n</li>\n<li><p>避免函数名变量冲突</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h3><ul>\n<li>为什么需要模块化规范</li>\n</ul>\n<blockquote>\n<p>模块与模块之间要有隔离，并模块之间需要有交互</p>\n</blockquote>\n<ul>\n<li>浏览器端模块化规范<ul>\n<li>AMD –&gt; requireJS</li>\n<li>CMD –&gt; Sea.js</li>\n</ul>\n</li>\n<li>服务器端模块化规范<ul>\n<li>CommonJS –&gt; Node.js </li>\n</ul>\n</li>\n<li>ES6本身提供了模块化 ESM<ul>\n<li>Vue/React项目中会大量使用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Node-js模块化\"><a href=\"#Node-js模块化\" class=\"headerlink\" title=\"Node.js模块化\"></a>Node.js模块化</h2><ul>\n<li>什么是Node.js模块化</li>\n</ul>\n<blockquote>\n<p>在node.js中，一个js文件就是一个模块，模块之间存在隔离，且模块之间可以交互</p>\n</blockquote>\n<h3 id=\"模块类型\"><a href=\"#模块类型\" class=\"headerlink\" title=\"模块类型\"></a>模块类型</h3><ol>\n<li>Node.js内置核心模块</li>\n<li>.js模块：自定义模块</li>\n<li>json模块：自定义模块，主要用来提供数据</li>\n<li>.node模块：二进制，基于C/C++开发的，编译后形成模块</li>\n</ol>\n<h3 id=\"CommonJS模块化规则\"><a href=\"#CommonJS模块化规则\" class=\"headerlink\" title=\"CommonJS模块化规则\"></a>CommonJS模块化规则</h3><ul>\n<li><p>导出</p>\n<pre><code class=\"js\">1.方式1\nmodule.exports = &#123;\n    a:a\n&#125; //可以为变量，对象，方法，函数，等。\n\n\n2.方式2\nmodule.exports.名字 = 值\n\n3.方式3\nexports.名字 = 值 // exports = module.exports = &#123;&#125;\n\n错误写法:\nexports = &#123;\n    \n&#125;\n原因：最终导出以module.exports为准，而exports只是一个别名，当把对象赋值给exports时，它的指向就不在指向module.exports，而指向了新对象。\n</code></pre>\n</li>\n<li><p>导入</p>\n<pre><code class=\"js\">var obj = require(&#39;路径&#39;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Node-js模块的循环调用\"><a href=\"#Node-js模块的循环调用\" class=\"headerlink\" title=\"Node.js模块的循环调用\"></a>Node.js模块的循环调用</h2><blockquote>\n<p>如果node.js中两个模块循环调用，是否会造成死循环？</p>\n</blockquote>\n<ul>\n<li>不会，nodejs有防止死循环机制 </li>\n</ul>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><ul>\n<li><p>什么是包</p>\n<blockquote>\n<p>一个js文件是一个模块，一般一个模块只做一件事情，那么包可以看作是将模块，代码，和其它资源组合而成的一个更大的模块</p>\n</blockquote>\n</li>\n<li><p>功能</p>\n<p>可以实现更加复杂，完善的功能模块，方便代码复用，更加效率</p>\n</li>\n</ul>\n<h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h3><blockquote>\n<p>npm是一个网站，托管所有的包，方便用户发布包和搜索包</p>\n<p>npm:是一个包管理工具（Node Package Manager）,随Node.js安装包安装，可进行下载安装，更新，卸载，发布。</p>\n</blockquote>\n<ul>\n<li>类似npm的还有yaar</li>\n</ul>\n<h4 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><pre><code class=\"js\">1.初始化文件\nnpm init -y  //自动生成配置文件\n\n2.安装包\nnpm install express //npm i 包名\n\n3.导入包\nconst express = require(&#39;express&#39;)\n</code></pre>\n<ul>\n<li><p>安装包</p>\n<ol>\n<li><p>本地安装</p>\n<ul>\n<li>安装到项目里</li>\n</ul>\n<pre><code class=\"js\">npm install  包名  //默认安装到生产依赖\nnpm add  包名\nnpm i 包名\nnpm install  包名@版本号 //安装指定版本号 \n\n\nnpm install //安装package.json文件中所有依赖的包(开发依赖和生产依赖)\nnpm i --production //只安装生产依赖的包\n\n\n//安装包时只记录到开发依赖\nnpm  i  -D\nnpm  i --save-dev\n//安装到生产依赖和开发依赖\nnpm i -S\nnpm  i --save\n\n</code></pre>\n</li>\n<li><p>全局安装</p>\n<ul>\n<li>安装到node.js目录里的node_modules文件里，一般安装需要命令执行的包</li>\n</ul>\n<pre><code class=\"js\">npm i 包名 -g //全局安装\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>卸载包</p>\n<ul>\n<li><p>本地卸载</p>\n<pre><code class=\"js\">npm uninstall 包名 \nnpm un 包名\nnpm remove 包名\n</code></pre>\n</li>\n<li><p>全局卸载</p>\n<pre><code class=\"js\">npm uninstall 包名 -g \nnpm un 包名 -g\nnpm remove 包名 -g\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>更新包</p>\n<p>前提条件：根目录必须有package.json文件</p>\n<pre><code class=\"jsx\">npm update 包名 //将包更新到最新版本\nnpm up 包名 \n</code></pre>\n</li>\n</ul>\n<p>###package.json文件描述</p>\n<pre><code class=\"js\">&#123;\n  &quot;name&quot;: &quot;y&quot;, //包的名称，有唯一性\n  &quot;version&quot;: &quot;1.0.0&quot;, //包的版本号\n  &quot;description&quot;: &quot;&quot;, //介绍包的功能描述\n  &quot;main&quot;: &quot;index.js&quot;, //包的默认执行的文件，包的入口\n \n  &quot;scripts&quot;: &#123; //脚本，相当于给命令起个别名，运行test的时候执行它的值，可自定义多条命令\n    &quot;test&quot;: &quot;命令&quot;\n  &#125;,\n      \n  &quot;keywords&quot;:[&quot;关键字1&quot;,&quot;关键字2&quot;], //包被搜索的关键字\n  &quot;author&quot;: &quot;&quot;, //包的作者\n  &quot;license&quot;: &quot;ISC&quot;, //包遵循的开源协议、\n    \n   &quot;dependencies&quot;:&#123; //生产依赖，在开发和上线后都必须使用的包，程序正常运行的包\n        \n    &#125;,\n    \n   &quot;devDependencies&quot;:&#123; //开发依赖，在开发时需要使用的包，工具，测试类的包\n        dfdf:&#39;&#39;\n    &#125;\n&#125;\n</code></pre>\n<p>###package-lock.json文件</p>\n<blockquote>\n<p>记录包的依赖关系，版本信息，依赖顺序等，防止版本更新导致API变化的问题,此文件不要更改</p>\n</blockquote>\n<h3 id=\"解决下包慢\"><a href=\"#解决下包慢\" class=\"headerlink\" title=\"解决下包慢\"></a>解决下包慢</h3><ul>\n<li><p>为什么下包慢？</p>\n<p>因为下载网址的服务器在国外</p>\n</li>\n<li><p>解决</p>\n<ol>\n<li><p><a href=\"registry=https://registry.npm.taobao.org/\">使用淘宝镜像</a>，淘宝镜像10分钟更新一次</p>\n<ul>\n<li><p>使用</p>\n<pre><code class=\"js\">npm config set registry=https://registry.npm.taobao.org/ //配置\n\nnpm config get registry //查看是否配置成功\n\nnpm i 包名 //直接使用安装\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>使用nrm</p>\n<ul>\n<li><p>如果需要管理各种镜像，可以使用nrm命令行工具</p>\n<pre><code class=\"js\">1.下载nrm\nnpm i nrm -g\n\n2.查询所有镜像\nnrm ls\n\n3.切换镜像名称\nnrm use 名称\n\n4.新增镜像源\nnrm add 别名  地址\n\n5.删除镜像源\nnrm del 别名\n\n6.测试镜像源的响应速度\nnrm test 别名\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>安装cnpm</p>\n<pre><code class=\"js\">npm install -g cnpm --registry=https://registry.npm.taobao.org\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"开发一个包\"><a href=\"#开发一个包\" class=\"headerlink\" title=\"开发一个包\"></a>开发一个包</h2><p>###创建一个包</p>\n<ul>\n<li>包的标准<ol>\n<li>包必须是单独的目录</li>\n<li>项目的根目录必须有package.js包管理配置文件</li>\n<li>设置name，version，main</li>\n<li>创建readme.md文件（可有可无），包的使用说明</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"发布包\"><a href=\"#发布包\" class=\"headerlink\" title=\"发布包\"></a>发布包</h3><ol>\n<li><p>注册npm账号</p>\n</li>\n<li><p>切换到npm镜像，用命令行登录</p>\n<pre><code class=\"js\">npm login //登录命令\n</code></pre>\n<ol start=\"3\">\n<li>发布包</li>\n</ol>\n<pre><code class=\"js\">npm publish //发布包\n</code></pre>\n</li>\n</ol>\n<p>###删除包</p>\n<ul>\n<li>超过3天后包将永久不可删除</li>\n</ul>\n<pre><code class=\"js\">npm unpublish 包名 --force //只能删除72小时以内发布的包,以删除的包不允许在24小时内重复发布\n</code></pre>\n<h2 id=\"模块和包的加载机制\"><a href=\"#模块和包的加载机制\" class=\"headerlink\" title=\"模块和包的加载机制\"></a>模块和包的加载机制</h2><p>###普通机制加载机制</p>\n<ol>\n<li>只要把模块require进来，那么代码就会执行，与有没有module.exports导出没有关系</li>\n<li>多次导入同一个模块只会执行1次，因为有node.js有缓存机制，会根据路径，文件位置，名字来判断是否为同一模块。</li>\n</ol>\n<p>###内置模块加载机制</p>\n<ol>\n<li>当自定义模块名和内置模块名重复且导入时，优先使用内置模块</li>\n</ol>\n<p>###自定义模块加载机制</p>\n<ol>\n<li>导入模块时不写后缀名，优先加载后缀为js的文件</li>\n</ol>\n<p>###第三方模块(包)加载机制</p>\n<ol>\n<li>如果传递给 require() 的模块标识符不是一个内置模块，也没有以’./‘ 或 ‘../‘ 开头，会先在项目根目录中找node_module目录中的包没有则../，会一级一级向上找node_module目录中的包</li>\n</ol>\n<h3 id=\"目录作为模块加载机制\"><a href=\"#目录作为模块加载机制\" class=\"headerlink\" title=\"目录作为模块加载机制\"></a>目录作为模块加载机制</h3><ol>\n<li>导入时，会默认找package.json配置文件中main 的指定文件</li>\n<li>如果没有package.json配置文件，那么会去找index.js</li>\n</ol>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>全局模块可以本地导入吗？</p>\n<p>不可，全局模块仅仅用来做命令</p>\n</li>\n<li><p>import和require的区别</p>\n<p>import是es6提供的</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>npm  下包时报错</p>\n<pre><code class=\"js\">unable to verify the first certificate//无法验证第一个证书\n</code></pre>\n<ul>\n<li><p>解决</p>\n<pre><code class=\"js\">取消ssl验证：npm config set strict-ssl false\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"node express","date":"2019-04-12T02:41:48.000Z","_content":"# 03-node.js\n\n## 服务端开发\n\n### 概述\n\n> 代码运行在服务端上，服务器端给客户端提供相应的服务，供客户端使用，就是服务端开发。\n\n+ 早期是服务端渲染（客户端发送请求给服务器，服务器返回渲染好的HTML页面，而不是数据）\n+ 现在主流是客户端渲染（客户端通过Ajax调用后端接口，后端接口返回JSON数据，客户端把数据渲染出来）\n\n## express\n\n###介绍\n\n> express是基于node.js的web应用框架，可快速搭建一个完整功能的网站。提供了强大的各种web应用和http工具\n\n+ 特性\n\n  1. 定义了路由表用于执行不同的http请求\n\n  2. 可以通过向模板传递参数动态渲染html页面\n\n  3. 可以用中间件来响应HTTP请求 \n\n     \n\n\n### 使用\n\n```js\n1.导入包\nconst express = require('express')\n2.创建express服务器\nvar app = express()\n\n3.监听一个get请求路径\napp.get('路径',function(req,res){\n    res.send('hello') \n    //req表示请求对象\n    //res表示响应对象\n})\n\n4.监听一个端口\napp.listen(端口号,function(){\n    console.log(\"运行了\")\n})\n```\n\n\n\n\n\n##express后端路由\n\n### 概念\n\n> 分发请求，根据客户端请求的路径执行不同的代码\n\n\n\n### 静态资源服务\n\n> 功能：根据客户端请求的地址，找到对应的文件，并读取内容，然后返回给客户端\n\n+ 把页面相关内容以网站方式去访问，启动以后，静态资源和后端接口请求地址就不会跨域了，从而方便ajax测试\n\n+ 使用\n\n  ```js\n  app.use(express.static('文件夹名称'))\n  ```\n\n\n### 后端路由方法\n\n1. app.get ()查询\n2. app.post ()添加\n3. app.delete() 删除\n4. app.put() 更新\n\n####获取get请求参数\n\n```js\nreq.query \n```\n\n#### 获取post请求参数\n\n```js\n1.获取application/x-www-form-urlencoded格式的参数\napp.use(express.urlencoded({extended:true})) //解析post提交的www格式的参数\nreq.body \n\n2.获取application/json格式,之前是给前端添加new URLSearchParams()方法处理的\napp.use(express.json()) //解析post提交的json格式的请求参数\nreq.body\n```\n\n#### Restful参数获取\n\n```js\napp.get('/路径/:id',function(req,res){\n    req.params\n})\n```\n\n\n\n#### 总结\n\n```js\n1.以？方式的url地址传参使用query获取\nreq.query\n\n2.通过请求体传参使用body获取\napp.use(express.urlencoded({extended:true})) \nreq.body\n\n3.Restful形式的参数，使用params\napp.use(express.json())\nreq.params\n```\n\n\n\n## Express中间件\n\n### 概念\n\n> 中间件的作用就是专门用来接收请求和处理请求的。对于同一个请求express可以设置多个中间件，这些中间件会按照顺序依次对请求进行处理。 \n\n### 功能\n\n我们可以将一个复杂的请求处理逻辑进行分开处理，也可以在请求到达路由之前做一些验证。比如查看用户是否登录，如果登录再向下继续执行。 \n\n\n\n### 分类\n\n1. 内置中间件，静态资源服务器中间件，表单参数处理中间件\n2. 自定义中间件\n3. 第三方中间件\n\n\n\n### 自定义中间件\n\n```js\napp.use(function(req,res,next){\n    req.salt = 数据 //将数据传入req\n    next() //交给下一个中间件进行处理\n})\n```\n\n+ 将自定义中间件放到最后，一般用于错误的返回\n\n  ```js\n  app.use(function(err,req,res,next){\n      console.error(err.stack)  //报错信息\n      res.status(500).send('服务器返回错误') //status用于设置http响应状态码\n  })\n  ```\n\n\n\n### 后端使用第三方中间件CORS解决跨域\n\n```js\n1.导入\nconst cors = require('cors')\n\n2.调用\napp.use(cors())\n```\n\n### 自定义中间件解决跨域\n\n```js\napp.all('*',function(req,res,next){ //.all所有请求方式都会被拦截\n    1.允许那个域名可以访问这个接口，*全部\n    res.header('Access-Control-Allow-Origin','*')\n    \n    2.允许的请求头\n    res.header('Access-Control-Allow-Headers','Content-Type')\n    \n    3.允许的请求方式，*全部\n    res.header('Access-Control-Allow-Methods','*')\n    \n    next()\n})\n```\n\n\n\n## 数据库\n\n### 概念\n\n> 用来存储，管理数据的仓库\n\n+ 常用数据库类型\n\n  1. 关系数据库\n\n     MySQL,Oracle,SQL server\n\n  2. MongoDB\n\n### mysql常用操作\n\n+ 查询\n\n  ```js\n  select * from 表 //查询表中所有数据\n  select * from 表 where 字段 like '呵呵%' //查询以呵呵开头的\n  select count(*) as 别名 from 表 // 查询表里有几条数据\n  select min(字段名)\tfrom 表 //查询最小\n  select avg(字段名)\tfrom 表 //查询平均\n  select sum(字段名)\tfrom 表 //查询总和\n  select max(字段名)\tfrom 表 //查询最大\n  select * from 表名 order by id desc/asc //排序,默认升序，降序desc\n  select * from 表名 limit 0，2 //分页查询limit 从第几条查询，一页显示几条,公式（n-1）*m,m\n  select * from 表 where age=(select max(字段名)\tfrom 表 ) //查询嵌套\n  select * from 表名1 left join 表2 on 表名1.cid=表名2.id where 表名1.cid = 2\n  ```\n\n+ 插入\n\n  ```js\n  insert into 表 (字段) values (要插入的数据) \n  ```\n\n+ 更新\n\n  ```js\n  update 表名 set 字段='要更新的数据'  where id=3 and/or \n  ```\n\n+ 删除\n\n  ```js\n  delete from 表名 where id=3   and/or\n  ```\n\n\n\n## 通过程序操作数据库\n\n+ MySQL模块\n\n>用来连接数据库并操作数据库的模块\n\n+ 使用\n\n  ```js\n  1.导入\n  const mysql = require('mysql')\n  \n  2.访问数据库\n  const cn = mysql.createConnection({\n      host:\"域名/ip\",\n      port:端口,\n      database:\"数据库名\"\n      user:\"数据库名\",\n      password:\"密码\"\n  })\n  \n  3.连接数据库\n  cn.connect()\n  \n  4.对数据库进行操作\n  var sql = 'SELECT * FROM dynamic_img'\n  cn.query(sql,function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  5.关闭连接,节省内存\n  cn.end()\n  ```\n\n+ 封装多个数据库函数,查询，添加，删除，插入\n\n+ 占位符\n\n  + ? ，一一对应动态数据\n\n  ```js\n  1.查询\n  var sql = 'SELECT * FROM dynamic_img where ?'\n  var pramas = {id:12,name:\"zpf\"}\n  cn.query(sql,pramas，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  \n  2.插入\n  var sql = 'insert info 表 set ?'\n  cn.query(sql,{name:'za',age:\"18\"}，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  3.更新\n  var sql = 'update 表 set ? where id=?'\n  cn.query(sql,[{name:'zs',pwd:\"mojap\"},id:2]，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  4.删除\n  var sql = 'delete from 表 where id=?'\n  cn.query(sql,1，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  ```\n\n  \n\n\n\n\n\n## ？\n\n1. express()这个函数和express是什么\n\n   ```js\n   express的本身就是一个函数体\n   typeof express //function\n   调用函数后返回一个函数，函数里有很多方法和属性\n   var app = express()\n   typeof app //function\n   app.get() \n   ```\n\n   \n\n2. 使用插件修改node.js文件就重新运行一下\n\n   ```js\n   1.\n   npm install supervisor -g\n   supervisor 文件名\n   2.\n   cnpm install -g  nodemon\n   nodemon 文件名\n   ```\n\n   \n\n3. 本地右击打开html文件发送请求会形成跨域，使用cors解决后，再把app.use(cors())注释掉，重启node，get请求不会形成跨域，其它请求会跨域，然后再改变get请求里的req.send(),get，重启node,get就会跨域，这是网页的一种缓存机制吗？\n\n4. sublime的控制台\n\n5. express.urlencoded({extended:true}) true和false什么区别\n\n    ","source":"_posts/笔记/ocean/10-node.js总结/03-express/03-笔记.md","raw":"---\ntitle: node express\ndate: 2019-04-12 10:41:48\ncategories:\n- 笔记\n- node\ntags:\n- 前端\n- node\n---\n# 03-node.js\n\n## 服务端开发\n\n### 概述\n\n> 代码运行在服务端上，服务器端给客户端提供相应的服务，供客户端使用，就是服务端开发。\n\n+ 早期是服务端渲染（客户端发送请求给服务器，服务器返回渲染好的HTML页面，而不是数据）\n+ 现在主流是客户端渲染（客户端通过Ajax调用后端接口，后端接口返回JSON数据，客户端把数据渲染出来）\n\n## express\n\n###介绍\n\n> express是基于node.js的web应用框架，可快速搭建一个完整功能的网站。提供了强大的各种web应用和http工具\n\n+ 特性\n\n  1. 定义了路由表用于执行不同的http请求\n\n  2. 可以通过向模板传递参数动态渲染html页面\n\n  3. 可以用中间件来响应HTTP请求 \n\n     \n\n\n### 使用\n\n```js\n1.导入包\nconst express = require('express')\n2.创建express服务器\nvar app = express()\n\n3.监听一个get请求路径\napp.get('路径',function(req,res){\n    res.send('hello') \n    //req表示请求对象\n    //res表示响应对象\n})\n\n4.监听一个端口\napp.listen(端口号,function(){\n    console.log(\"运行了\")\n})\n```\n\n\n\n\n\n##express后端路由\n\n### 概念\n\n> 分发请求，根据客户端请求的路径执行不同的代码\n\n\n\n### 静态资源服务\n\n> 功能：根据客户端请求的地址，找到对应的文件，并读取内容，然后返回给客户端\n\n+ 把页面相关内容以网站方式去访问，启动以后，静态资源和后端接口请求地址就不会跨域了，从而方便ajax测试\n\n+ 使用\n\n  ```js\n  app.use(express.static('文件夹名称'))\n  ```\n\n\n### 后端路由方法\n\n1. app.get ()查询\n2. app.post ()添加\n3. app.delete() 删除\n4. app.put() 更新\n\n####获取get请求参数\n\n```js\nreq.query \n```\n\n#### 获取post请求参数\n\n```js\n1.获取application/x-www-form-urlencoded格式的参数\napp.use(express.urlencoded({extended:true})) //解析post提交的www格式的参数\nreq.body \n\n2.获取application/json格式,之前是给前端添加new URLSearchParams()方法处理的\napp.use(express.json()) //解析post提交的json格式的请求参数\nreq.body\n```\n\n#### Restful参数获取\n\n```js\napp.get('/路径/:id',function(req,res){\n    req.params\n})\n```\n\n\n\n#### 总结\n\n```js\n1.以？方式的url地址传参使用query获取\nreq.query\n\n2.通过请求体传参使用body获取\napp.use(express.urlencoded({extended:true})) \nreq.body\n\n3.Restful形式的参数，使用params\napp.use(express.json())\nreq.params\n```\n\n\n\n## Express中间件\n\n### 概念\n\n> 中间件的作用就是专门用来接收请求和处理请求的。对于同一个请求express可以设置多个中间件，这些中间件会按照顺序依次对请求进行处理。 \n\n### 功能\n\n我们可以将一个复杂的请求处理逻辑进行分开处理，也可以在请求到达路由之前做一些验证。比如查看用户是否登录，如果登录再向下继续执行。 \n\n\n\n### 分类\n\n1. 内置中间件，静态资源服务器中间件，表单参数处理中间件\n2. 自定义中间件\n3. 第三方中间件\n\n\n\n### 自定义中间件\n\n```js\napp.use(function(req,res,next){\n    req.salt = 数据 //将数据传入req\n    next() //交给下一个中间件进行处理\n})\n```\n\n+ 将自定义中间件放到最后，一般用于错误的返回\n\n  ```js\n  app.use(function(err,req,res,next){\n      console.error(err.stack)  //报错信息\n      res.status(500).send('服务器返回错误') //status用于设置http响应状态码\n  })\n  ```\n\n\n\n### 后端使用第三方中间件CORS解决跨域\n\n```js\n1.导入\nconst cors = require('cors')\n\n2.调用\napp.use(cors())\n```\n\n### 自定义中间件解决跨域\n\n```js\napp.all('*',function(req,res,next){ //.all所有请求方式都会被拦截\n    1.允许那个域名可以访问这个接口，*全部\n    res.header('Access-Control-Allow-Origin','*')\n    \n    2.允许的请求头\n    res.header('Access-Control-Allow-Headers','Content-Type')\n    \n    3.允许的请求方式，*全部\n    res.header('Access-Control-Allow-Methods','*')\n    \n    next()\n})\n```\n\n\n\n## 数据库\n\n### 概念\n\n> 用来存储，管理数据的仓库\n\n+ 常用数据库类型\n\n  1. 关系数据库\n\n     MySQL,Oracle,SQL server\n\n  2. MongoDB\n\n### mysql常用操作\n\n+ 查询\n\n  ```js\n  select * from 表 //查询表中所有数据\n  select * from 表 where 字段 like '呵呵%' //查询以呵呵开头的\n  select count(*) as 别名 from 表 // 查询表里有几条数据\n  select min(字段名)\tfrom 表 //查询最小\n  select avg(字段名)\tfrom 表 //查询平均\n  select sum(字段名)\tfrom 表 //查询总和\n  select max(字段名)\tfrom 表 //查询最大\n  select * from 表名 order by id desc/asc //排序,默认升序，降序desc\n  select * from 表名 limit 0，2 //分页查询limit 从第几条查询，一页显示几条,公式（n-1）*m,m\n  select * from 表 where age=(select max(字段名)\tfrom 表 ) //查询嵌套\n  select * from 表名1 left join 表2 on 表名1.cid=表名2.id where 表名1.cid = 2\n  ```\n\n+ 插入\n\n  ```js\n  insert into 表 (字段) values (要插入的数据) \n  ```\n\n+ 更新\n\n  ```js\n  update 表名 set 字段='要更新的数据'  where id=3 and/or \n  ```\n\n+ 删除\n\n  ```js\n  delete from 表名 where id=3   and/or\n  ```\n\n\n\n## 通过程序操作数据库\n\n+ MySQL模块\n\n>用来连接数据库并操作数据库的模块\n\n+ 使用\n\n  ```js\n  1.导入\n  const mysql = require('mysql')\n  \n  2.访问数据库\n  const cn = mysql.createConnection({\n      host:\"域名/ip\",\n      port:端口,\n      database:\"数据库名\"\n      user:\"数据库名\",\n      password:\"密码\"\n  })\n  \n  3.连接数据库\n  cn.connect()\n  \n  4.对数据库进行操作\n  var sql = 'SELECT * FROM dynamic_img'\n  cn.query(sql,function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  5.关闭连接,节省内存\n  cn.end()\n  ```\n\n+ 封装多个数据库函数,查询，添加，删除，插入\n\n+ 占位符\n\n  + ? ，一一对应动态数据\n\n  ```js\n  1.查询\n  var sql = 'SELECT * FROM dynamic_img where ?'\n  var pramas = {id:12,name:\"zpf\"}\n  cn.query(sql,pramas，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  \n  2.插入\n  var sql = 'insert info 表 set ?'\n  cn.query(sql,{name:'za',age:\"18\"}，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  3.更新\n  var sql = 'update 表 set ? where id=?'\n  cn.query(sql,[{name:'zs',pwd:\"mojap\"},id:2]，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  4.删除\n  var sql = 'delete from 表 where id=?'\n  cn.query(sql,1，function(err,res){\n      if(err){ 失败 }\n      res //获取到的数据库数据\n  })\n  \n  ```\n\n  \n\n\n\n\n\n## ？\n\n1. express()这个函数和express是什么\n\n   ```js\n   express的本身就是一个函数体\n   typeof express //function\n   调用函数后返回一个函数，函数里有很多方法和属性\n   var app = express()\n   typeof app //function\n   app.get() \n   ```\n\n   \n\n2. 使用插件修改node.js文件就重新运行一下\n\n   ```js\n   1.\n   npm install supervisor -g\n   supervisor 文件名\n   2.\n   cnpm install -g  nodemon\n   nodemon 文件名\n   ```\n\n   \n\n3. 本地右击打开html文件发送请求会形成跨域，使用cors解决后，再把app.use(cors())注释掉，重启node，get请求不会形成跨域，其它请求会跨域，然后再改变get请求里的req.send(),get，重启node,get就会跨域，这是网页的一种缓存机制吗？\n\n4. sublime的控制台\n\n5. express.urlencoded({extended:true}) true和false什么区别\n\n    ","slug":"笔记/ocean/10-node.js总结/03-express/03-笔记","published":1,"updated":"2023-03-01T07:11:50.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe600adawaf16ba0gcm","content":"<h1 id=\"03-node-js\"><a href=\"#03-node-js\" class=\"headerlink\" title=\"03-node.js\"></a>03-node.js</h1><h2 id=\"服务端开发\"><a href=\"#服务端开发\" class=\"headerlink\" title=\"服务端开发\"></a>服务端开发</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>代码运行在服务端上，服务器端给客户端提供相应的服务，供客户端使用，就是服务端开发。</p>\n</blockquote>\n<ul>\n<li>早期是服务端渲染（客户端发送请求给服务器，服务器返回渲染好的HTML页面，而不是数据）</li>\n<li>现在主流是客户端渲染（客户端通过Ajax调用后端接口，后端接口返回JSON数据，客户端把数据渲染出来）</li>\n</ul>\n<h2 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h2><p>###介绍</p>\n<blockquote>\n<p>express是基于node.js的web应用框架，可快速搭建一个完整功能的网站。提供了强大的各种web应用和http工具</p>\n</blockquote>\n<ul>\n<li><p>特性</p>\n<ol>\n<li><p>定义了路由表用于执行不同的http请求</p>\n</li>\n<li><p>可以通过向模板传递参数动态渲染html页面</p>\n</li>\n<li><p>可以用中间件来响应HTTP请求 </p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">1.导入包\nconst express = require(&#39;express&#39;)\n2.创建express服务器\nvar app = express()\n\n3.监听一个get请求路径\napp.get(&#39;路径&#39;,function(req,res)&#123;\n    res.send(&#39;hello&#39;) \n    //req表示请求对象\n    //res表示响应对象\n&#125;)\n\n4.监听一个端口\napp.listen(端口号,function()&#123;\n    console.log(&quot;运行了&quot;)\n&#125;)\n</code></pre>\n<p>##express后端路由</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>分发请求，根据客户端请求的路径执行不同的代码</p>\n</blockquote>\n<h3 id=\"静态资源服务\"><a href=\"#静态资源服务\" class=\"headerlink\" title=\"静态资源服务\"></a>静态资源服务</h3><blockquote>\n<p>功能：根据客户端请求的地址，找到对应的文件，并读取内容，然后返回给客户端</p>\n</blockquote>\n<ul>\n<li><p>把页面相关内容以网站方式去访问，启动以后，静态资源和后端接口请求地址就不会跨域了，从而方便ajax测试</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">app.use(express.static(&#39;文件夹名称&#39;))\n</code></pre>\n</li>\n</ul>\n<h3 id=\"后端路由方法\"><a href=\"#后端路由方法\" class=\"headerlink\" title=\"后端路由方法\"></a>后端路由方法</h3><ol>\n<li>app.get ()查询</li>\n<li>app.post ()添加</li>\n<li>app.delete() 删除</li>\n<li>app.put() 更新</li>\n</ol>\n<p>####获取get请求参数</p>\n<pre><code class=\"js\">req.query \n</code></pre>\n<h4 id=\"获取post请求参数\"><a href=\"#获取post请求参数\" class=\"headerlink\" title=\"获取post请求参数\"></a>获取post请求参数</h4><pre><code class=\"js\">1.获取application/x-www-form-urlencoded格式的参数\napp.use(express.urlencoded(&#123;extended:true&#125;)) //解析post提交的www格式的参数\nreq.body \n\n2.获取application/json格式,之前是给前端添加new URLSearchParams()方法处理的\napp.use(express.json()) //解析post提交的json格式的请求参数\nreq.body\n</code></pre>\n<h4 id=\"Restful参数获取\"><a href=\"#Restful参数获取\" class=\"headerlink\" title=\"Restful参数获取\"></a>Restful参数获取</h4><pre><code class=\"js\">app.get(&#39;/路径/:id&#39;,function(req,res)&#123;\n    req.params\n&#125;)\n</code></pre>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><pre><code class=\"js\">1.以？方式的url地址传参使用query获取\nreq.query\n\n2.通过请求体传参使用body获取\napp.use(express.urlencoded(&#123;extended:true&#125;)) \nreq.body\n\n3.Restful形式的参数，使用params\napp.use(express.json())\nreq.params\n</code></pre>\n<h2 id=\"Express中间件\"><a href=\"#Express中间件\" class=\"headerlink\" title=\"Express中间件\"></a>Express中间件</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>中间件的作用就是专门用来接收请求和处理请求的。对于同一个请求express可以设置多个中间件，这些中间件会按照顺序依次对请求进行处理。 </p>\n</blockquote>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>我们可以将一个复杂的请求处理逻辑进行分开处理，也可以在请求到达路由之前做一些验证。比如查看用户是否登录，如果登录再向下继续执行。 </p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ol>\n<li>内置中间件，静态资源服务器中间件，表单参数处理中间件</li>\n<li>自定义中间件</li>\n<li>第三方中间件</li>\n</ol>\n<h3 id=\"自定义中间件\"><a href=\"#自定义中间件\" class=\"headerlink\" title=\"自定义中间件\"></a>自定义中间件</h3><pre><code class=\"js\">app.use(function(req,res,next)&#123;\n    req.salt = 数据 //将数据传入req\n    next() //交给下一个中间件进行处理\n&#125;)\n</code></pre>\n<ul>\n<li><p>将自定义中间件放到最后，一般用于错误的返回</p>\n<pre><code class=\"js\">app.use(function(err,req,res,next)&#123;\n    console.error(err.stack)  //报错信息\n    res.status(500).send(&#39;服务器返回错误&#39;) //status用于设置http响应状态码\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"后端使用第三方中间件CORS解决跨域\"><a href=\"#后端使用第三方中间件CORS解决跨域\" class=\"headerlink\" title=\"后端使用第三方中间件CORS解决跨域\"></a>后端使用第三方中间件CORS解决跨域</h3><pre><code class=\"js\">1.导入\nconst cors = require(&#39;cors&#39;)\n\n2.调用\napp.use(cors())\n</code></pre>\n<h3 id=\"自定义中间件解决跨域\"><a href=\"#自定义中间件解决跨域\" class=\"headerlink\" title=\"自定义中间件解决跨域\"></a>自定义中间件解决跨域</h3><pre><code class=\"js\">app.all(&#39;*&#39;,function(req,res,next)&#123; //.all所有请求方式都会被拦截\n    1.允许那个域名可以访问这个接口，*全部\n    res.header(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)\n    \n    2.允许的请求头\n    res.header(&#39;Access-Control-Allow-Headers&#39;,&#39;Content-Type&#39;)\n    \n    3.允许的请求方式，*全部\n    res.header(&#39;Access-Control-Allow-Methods&#39;,&#39;*&#39;)\n    \n    next()\n&#125;)\n</code></pre>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>用来存储，管理数据的仓库</p>\n</blockquote>\n<ul>\n<li><p>常用数据库类型</p>\n<ol>\n<li><p>关系数据库</p>\n<p>MySQL,Oracle,SQL server</p>\n</li>\n<li><p>MongoDB</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"mysql常用操作\"><a href=\"#mysql常用操作\" class=\"headerlink\" title=\"mysql常用操作\"></a>mysql常用操作</h3><ul>\n<li><p>查询</p>\n<pre><code class=\"js\">select * from 表 //查询表中所有数据\nselect * from 表 where 字段 like &#39;呵呵%&#39; //查询以呵呵开头的\nselect count(*) as 别名 from 表 // 查询表里有几条数据\nselect min(字段名)    from 表 //查询最小\nselect avg(字段名)    from 表 //查询平均\nselect sum(字段名)    from 表 //查询总和\nselect max(字段名)    from 表 //查询最大\nselect * from 表名 order by id desc/asc //排序,默认升序，降序desc\nselect * from 表名 limit 0，2 //分页查询limit 从第几条查询，一页显示几条,公式（n-1）*m,m\nselect * from 表 where age=(select max(字段名)    from 表 ) //查询嵌套\nselect * from 表名1 left join 表2 on 表名1.cid=表名2.id where 表名1.cid = 2\n</code></pre>\n</li>\n<li><p>插入</p>\n<pre><code class=\"js\">insert into 表 (字段) values (要插入的数据) \n</code></pre>\n</li>\n<li><p>更新</p>\n<pre><code class=\"js\">update 表名 set 字段=&#39;要更新的数据&#39;  where id=3 and/or \n</code></pre>\n</li>\n<li><p>删除</p>\n<pre><code class=\"js\">delete from 表名 where id=3   and/or\n</code></pre>\n</li>\n</ul>\n<h2 id=\"通过程序操作数据库\"><a href=\"#通过程序操作数据库\" class=\"headerlink\" title=\"通过程序操作数据库\"></a>通过程序操作数据库</h2><ul>\n<li>MySQL模块</li>\n</ul>\n<blockquote>\n<p>用来连接数据库并操作数据库的模块</p>\n</blockquote>\n<ul>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nconst mysql = require(&#39;mysql&#39;)\n\n2.访问数据库\nconst cn = mysql.createConnection(&#123;\n    host:&quot;域名/ip&quot;,\n    port:端口,\n    database:&quot;数据库名&quot;\n    user:&quot;数据库名&quot;,\n    password:&quot;密码&quot;\n&#125;)\n\n3.连接数据库\ncn.connect()\n\n4.对数据库进行操作\nvar sql = &#39;SELECT * FROM dynamic_img&#39;\ncn.query(sql,function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n5.关闭连接,节省内存\ncn.end()\n</code></pre>\n</li>\n<li><p>封装多个数据库函数,查询，添加，删除，插入</p>\n</li>\n<li><p>占位符</p>\n<ul>\n<li>? ，一一对应动态数据</li>\n</ul>\n<pre><code class=\"js\">1.查询\nvar sql = &#39;SELECT * FROM dynamic_img where ?&#39;\nvar pramas = &#123;id:12,name:&quot;zpf&quot;&#125;\ncn.query(sql,pramas，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n\n2.插入\nvar sql = &#39;insert info 表 set ?&#39;\ncn.query(sql,&#123;name:&#39;za&#39;,age:&quot;18&quot;&#125;，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n3.更新\nvar sql = &#39;update 表 set ? where id=?&#39;\ncn.query(sql,[&#123;name:&#39;zs&#39;,pwd:&quot;mojap&quot;&#125;,id:2]，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n4.删除\nvar sql = &#39;delete from 表 where id=?&#39;\ncn.query(sql,1，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>express()这个函数和express是什么</p>\n<pre><code class=\"js\">express的本身就是一个函数体\ntypeof express //function\n调用函数后返回一个函数，函数里有很多方法和属性\nvar app = express()\ntypeof app //function\napp.get() \n</code></pre>\n</li>\n<li><p>使用插件修改node.js文件就重新运行一下</p>\n<pre><code class=\"js\">1.\nnpm install supervisor -g\nsupervisor 文件名\n2.\ncnpm install -g  nodemon\nnodemon 文件名\n</code></pre>\n</li>\n<li><p>本地右击打开html文件发送请求会形成跨域，使用cors解决后，再把app.use(cors())注释掉，重启node，get请求不会形成跨域，其它请求会跨域，然后再改变get请求里的req.send(),get，重启node,get就会跨域，这是网页的一种缓存机制吗？</p>\n</li>\n<li><p>sublime的控制台</p>\n</li>\n<li><p>express.urlencoded({extended:true}) true和false什么区别</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-node-js\"><a href=\"#03-node-js\" class=\"headerlink\" title=\"03-node.js\"></a>03-node.js</h1><h2 id=\"服务端开发\"><a href=\"#服务端开发\" class=\"headerlink\" title=\"服务端开发\"></a>服务端开发</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>代码运行在服务端上，服务器端给客户端提供相应的服务，供客户端使用，就是服务端开发。</p>\n</blockquote>\n<ul>\n<li>早期是服务端渲染（客户端发送请求给服务器，服务器返回渲染好的HTML页面，而不是数据）</li>\n<li>现在主流是客户端渲染（客户端通过Ajax调用后端接口，后端接口返回JSON数据，客户端把数据渲染出来）</li>\n</ul>\n<h2 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h2><p>###介绍</p>\n<blockquote>\n<p>express是基于node.js的web应用框架，可快速搭建一个完整功能的网站。提供了强大的各种web应用和http工具</p>\n</blockquote>\n<ul>\n<li><p>特性</p>\n<ol>\n<li><p>定义了路由表用于执行不同的http请求</p>\n</li>\n<li><p>可以通过向模板传递参数动态渲染html页面</p>\n</li>\n<li><p>可以用中间件来响应HTTP请求 </p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">1.导入包\nconst express = require(&#39;express&#39;)\n2.创建express服务器\nvar app = express()\n\n3.监听一个get请求路径\napp.get(&#39;路径&#39;,function(req,res)&#123;\n    res.send(&#39;hello&#39;) \n    //req表示请求对象\n    //res表示响应对象\n&#125;)\n\n4.监听一个端口\napp.listen(端口号,function()&#123;\n    console.log(&quot;运行了&quot;)\n&#125;)\n</code></pre>\n<p>##express后端路由</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>分发请求，根据客户端请求的路径执行不同的代码</p>\n</blockquote>\n<h3 id=\"静态资源服务\"><a href=\"#静态资源服务\" class=\"headerlink\" title=\"静态资源服务\"></a>静态资源服务</h3><blockquote>\n<p>功能：根据客户端请求的地址，找到对应的文件，并读取内容，然后返回给客户端</p>\n</blockquote>\n<ul>\n<li><p>把页面相关内容以网站方式去访问，启动以后，静态资源和后端接口请求地址就不会跨域了，从而方便ajax测试</p>\n</li>\n<li><p>使用</p>\n<pre><code class=\"js\">app.use(express.static(&#39;文件夹名称&#39;))\n</code></pre>\n</li>\n</ul>\n<h3 id=\"后端路由方法\"><a href=\"#后端路由方法\" class=\"headerlink\" title=\"后端路由方法\"></a>后端路由方法</h3><ol>\n<li>app.get ()查询</li>\n<li>app.post ()添加</li>\n<li>app.delete() 删除</li>\n<li>app.put() 更新</li>\n</ol>\n<p>####获取get请求参数</p>\n<pre><code class=\"js\">req.query \n</code></pre>\n<h4 id=\"获取post请求参数\"><a href=\"#获取post请求参数\" class=\"headerlink\" title=\"获取post请求参数\"></a>获取post请求参数</h4><pre><code class=\"js\">1.获取application/x-www-form-urlencoded格式的参数\napp.use(express.urlencoded(&#123;extended:true&#125;)) //解析post提交的www格式的参数\nreq.body \n\n2.获取application/json格式,之前是给前端添加new URLSearchParams()方法处理的\napp.use(express.json()) //解析post提交的json格式的请求参数\nreq.body\n</code></pre>\n<h4 id=\"Restful参数获取\"><a href=\"#Restful参数获取\" class=\"headerlink\" title=\"Restful参数获取\"></a>Restful参数获取</h4><pre><code class=\"js\">app.get(&#39;/路径/:id&#39;,function(req,res)&#123;\n    req.params\n&#125;)\n</code></pre>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><pre><code class=\"js\">1.以？方式的url地址传参使用query获取\nreq.query\n\n2.通过请求体传参使用body获取\napp.use(express.urlencoded(&#123;extended:true&#125;)) \nreq.body\n\n3.Restful形式的参数，使用params\napp.use(express.json())\nreq.params\n</code></pre>\n<h2 id=\"Express中间件\"><a href=\"#Express中间件\" class=\"headerlink\" title=\"Express中间件\"></a>Express中间件</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>中间件的作用就是专门用来接收请求和处理请求的。对于同一个请求express可以设置多个中间件，这些中间件会按照顺序依次对请求进行处理。 </p>\n</blockquote>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>我们可以将一个复杂的请求处理逻辑进行分开处理，也可以在请求到达路由之前做一些验证。比如查看用户是否登录，如果登录再向下继续执行。 </p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ol>\n<li>内置中间件，静态资源服务器中间件，表单参数处理中间件</li>\n<li>自定义中间件</li>\n<li>第三方中间件</li>\n</ol>\n<h3 id=\"自定义中间件\"><a href=\"#自定义中间件\" class=\"headerlink\" title=\"自定义中间件\"></a>自定义中间件</h3><pre><code class=\"js\">app.use(function(req,res,next)&#123;\n    req.salt = 数据 //将数据传入req\n    next() //交给下一个中间件进行处理\n&#125;)\n</code></pre>\n<ul>\n<li><p>将自定义中间件放到最后，一般用于错误的返回</p>\n<pre><code class=\"js\">app.use(function(err,req,res,next)&#123;\n    console.error(err.stack)  //报错信息\n    res.status(500).send(&#39;服务器返回错误&#39;) //status用于设置http响应状态码\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"后端使用第三方中间件CORS解决跨域\"><a href=\"#后端使用第三方中间件CORS解决跨域\" class=\"headerlink\" title=\"后端使用第三方中间件CORS解决跨域\"></a>后端使用第三方中间件CORS解决跨域</h3><pre><code class=\"js\">1.导入\nconst cors = require(&#39;cors&#39;)\n\n2.调用\napp.use(cors())\n</code></pre>\n<h3 id=\"自定义中间件解决跨域\"><a href=\"#自定义中间件解决跨域\" class=\"headerlink\" title=\"自定义中间件解决跨域\"></a>自定义中间件解决跨域</h3><pre><code class=\"js\">app.all(&#39;*&#39;,function(req,res,next)&#123; //.all所有请求方式都会被拦截\n    1.允许那个域名可以访问这个接口，*全部\n    res.header(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)\n    \n    2.允许的请求头\n    res.header(&#39;Access-Control-Allow-Headers&#39;,&#39;Content-Type&#39;)\n    \n    3.允许的请求方式，*全部\n    res.header(&#39;Access-Control-Allow-Methods&#39;,&#39;*&#39;)\n    \n    next()\n&#125;)\n</code></pre>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>用来存储，管理数据的仓库</p>\n</blockquote>\n<ul>\n<li><p>常用数据库类型</p>\n<ol>\n<li><p>关系数据库</p>\n<p>MySQL,Oracle,SQL server</p>\n</li>\n<li><p>MongoDB</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"mysql常用操作\"><a href=\"#mysql常用操作\" class=\"headerlink\" title=\"mysql常用操作\"></a>mysql常用操作</h3><ul>\n<li><p>查询</p>\n<pre><code class=\"js\">select * from 表 //查询表中所有数据\nselect * from 表 where 字段 like &#39;呵呵%&#39; //查询以呵呵开头的\nselect count(*) as 别名 from 表 // 查询表里有几条数据\nselect min(字段名)    from 表 //查询最小\nselect avg(字段名)    from 表 //查询平均\nselect sum(字段名)    from 表 //查询总和\nselect max(字段名)    from 表 //查询最大\nselect * from 表名 order by id desc/asc //排序,默认升序，降序desc\nselect * from 表名 limit 0，2 //分页查询limit 从第几条查询，一页显示几条,公式（n-1）*m,m\nselect * from 表 where age=(select max(字段名)    from 表 ) //查询嵌套\nselect * from 表名1 left join 表2 on 表名1.cid=表名2.id where 表名1.cid = 2\n</code></pre>\n</li>\n<li><p>插入</p>\n<pre><code class=\"js\">insert into 表 (字段) values (要插入的数据) \n</code></pre>\n</li>\n<li><p>更新</p>\n<pre><code class=\"js\">update 表名 set 字段=&#39;要更新的数据&#39;  where id=3 and/or \n</code></pre>\n</li>\n<li><p>删除</p>\n<pre><code class=\"js\">delete from 表名 where id=3   and/or\n</code></pre>\n</li>\n</ul>\n<h2 id=\"通过程序操作数据库\"><a href=\"#通过程序操作数据库\" class=\"headerlink\" title=\"通过程序操作数据库\"></a>通过程序操作数据库</h2><ul>\n<li>MySQL模块</li>\n</ul>\n<blockquote>\n<p>用来连接数据库并操作数据库的模块</p>\n</blockquote>\n<ul>\n<li><p>使用</p>\n<pre><code class=\"js\">1.导入\nconst mysql = require(&#39;mysql&#39;)\n\n2.访问数据库\nconst cn = mysql.createConnection(&#123;\n    host:&quot;域名/ip&quot;,\n    port:端口,\n    database:&quot;数据库名&quot;\n    user:&quot;数据库名&quot;,\n    password:&quot;密码&quot;\n&#125;)\n\n3.连接数据库\ncn.connect()\n\n4.对数据库进行操作\nvar sql = &#39;SELECT * FROM dynamic_img&#39;\ncn.query(sql,function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n5.关闭连接,节省内存\ncn.end()\n</code></pre>\n</li>\n<li><p>封装多个数据库函数,查询，添加，删除，插入</p>\n</li>\n<li><p>占位符</p>\n<ul>\n<li>? ，一一对应动态数据</li>\n</ul>\n<pre><code class=\"js\">1.查询\nvar sql = &#39;SELECT * FROM dynamic_img where ?&#39;\nvar pramas = &#123;id:12,name:&quot;zpf&quot;&#125;\ncn.query(sql,pramas，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n\n2.插入\nvar sql = &#39;insert info 表 set ?&#39;\ncn.query(sql,&#123;name:&#39;za&#39;,age:&quot;18&quot;&#125;，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n3.更新\nvar sql = &#39;update 表 set ? where id=?&#39;\ncn.query(sql,[&#123;name:&#39;zs&#39;,pwd:&quot;mojap&quot;&#125;,id:2]，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n\n4.删除\nvar sql = &#39;delete from 表 where id=?&#39;\ncn.query(sql,1，function(err,res)&#123;\n    if(err)&#123; 失败 &#125;\n    res //获取到的数据库数据\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>express()这个函数和express是什么</p>\n<pre><code class=\"js\">express的本身就是一个函数体\ntypeof express //function\n调用函数后返回一个函数，函数里有很多方法和属性\nvar app = express()\ntypeof app //function\napp.get() \n</code></pre>\n</li>\n<li><p>使用插件修改node.js文件就重新运行一下</p>\n<pre><code class=\"js\">1.\nnpm install supervisor -g\nsupervisor 文件名\n2.\ncnpm install -g  nodemon\nnodemon 文件名\n</code></pre>\n</li>\n<li><p>本地右击打开html文件发送请求会形成跨域，使用cors解决后，再把app.use(cors())注释掉，重启node，get请求不会形成跨域，其它请求会跨域，然后再改变get请求里的req.send(),get，重启node,get就会跨域，这是网页的一种缓存机制吗？</p>\n</li>\n<li><p>sublime的控制台</p>\n</li>\n<li><p>express.urlencoded({extended:true}) true和false什么区别</p>\n</li>\n</ol>\n"},{"title":"node promise","date":"2019-04-12T02:41:48.000Z","_content":"\n# 04-node.js\n\n## 异步编程\n\n> 如何获取异步结果?必须使用回调函数，那么就会形成函数嵌套，形成回调地狱，为了解决诞生了promise\n\n\n\n## Promise\n\n```js\n异步任务写到new Promise()回调函数里,随后使用res()将数据返回出来\n使用then()获取返回的正确结果\n\nvar pro = new Promise(function(res,rej){\n    \n    fs.readFile(filePath,'utf8',function(err,data){\n        if(err) return rej(err)\n        res(data)\n    })\n    \n})\n\npro.then(function(ret){ //正确执行\n\n}).catch(function(err){\t//错误执行\n    err\n})\n```\n\n+ 解决回调地狱\n\n  > promise是回调地狱的语法糖,仅仅提升代码可读性，功能没变\n\n  ```js\n  拿到第一个函数结果后，返回fun2(),然后在调用then\n  \n  fun1.then(function(res1){\n      \n      return fun2() //返回fun2()函数，里面是一个Promise对象\n  }).then(function(res2){\n      return fun3()\n  }).then(function(res3){\n      //如果这里没有return,then内部会默认生成一个新的promise,如果在then中直接返回具体数据，它会自动包装成Promise对象\n      \n  }).then(function(res4){\n      \n  })\n     .catch(function(err){ //任何一个then错误都执行catch\n      \n  })\n  ```\n\n\n\n### 案例\n\n1. 读取3个文件，并按顺序返回。\n2. 使用Promise封装数据库操作\n\n\n\n\n\n## Async\n\n> Promise虽然对代码进行了改进，但还不是最好的，所以诞生了Async/await函数，它是Promise的语法糖。\n\n\n\n-    async 是ES7新引入的关键字，放到函数前面，表示函数是一个异步函数\n-    await 是关键字,只能放在async函数内部使用\n\n\n\n### 使用\n\n```js\nasync function 函数名(){\n var ret = await 函数名() //使用await得到Promise返回的结果，必须在async函数中使用。\n console.log(ret) //\n}\n```\n\n\n\n\n\n## let和const\n\n+ ES3/5没有块级作用域\n+ ES6的块作用域必须有大括号\n\n### let\n\n1. let不可重新声明\n2. let会形成块作用域\n3. 使用`let命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 \n\n\n\n### const\n\n1. 声明常量，只读，不可修改，不可重复声明\n2. 不提升，没有预解析\n3. 必须在定义时初始化，名称最好大写\n\n\n\n\n\n##箭头函数\n\n+ 相当于是一个匿名函数\n+ 箭头函数本身没有this,它会尝试去父级查找this\n\n\n\n### 使用\n\n```js\nlet fo = ()=>{ }\nlet fo = n =>{ }\nlet fo = (n,m)=>{ }\nlet fo = n => return n\nlet fo = n => n  //只有一行代码默认会返回结果\n\n```\n\n\n\n\n\n##单独路由模块\n\n```js\nindex.js文件\n1.导入路由模块\nconst routers = require('./routers.js')\n\n2.添加路由的统一路径\napp.use('路径',routers)\n```\n\n```js\n创建routers.js文件\n1.导入模块\nconst express = require('express')\nconst routers = express.Router()\n\n\n2.挂载路由\nrouters.get('路径',(req,res)=>{\n    \n})\n\n3.导出\nmodule.exports = {\n    routers:routers\n}\n```\n\n\n\n\n\n## 图书接口\n\n###初始化\n\n1. 创建index.js文件 启动express服务器，跑起来后将路由模块分离至routers目录\n\n2. 创建db.js，连接数据库对数据库进行操作，然后将返回数据导出\n\n3. 拿到数据，进行路由处理\n\n   \n\n###注册\n\n1. 在routers文件目录下创建login.js文件\n2. 将监听请求放入路由，用户注册数据提交过来后，加密密码，使用mysql语言插入数据库，返回的是一个对象，判断该对象的affectedRows(影响行)大于0时注册成功。\n\n```js\nres.json(数据) //把对象数据转为json格式并返回给前端\nnew Promise().affectedRows > 0 //成功\n\n//单向加密，简单型密码会被破译\nreq.body.password = utility.md(密码)\n```\n\n###登录\n\n1. 客户端提交数据过来，把密码用md5加密。\n2. 然后和数据库密码对比，返回的数据是个数组，里面的一个对象就是数据库里的一行，然后判断它的长度>0时，说明查询成功有这个用户，登录成功了\n3. 登录成功后使用第三方包生成一个token，所有的token前面都要加'Bearer'，然后放入res.json里返回给前端\n\n\n\n\n\n\n\n\n\n### 用户信息\n\n1. 使用express-jwt包统一解析token，获取用户id\n\n2. 根据用户id查询用户信息\n\n   ```js\n   使用express-jwtexpress-jwt包解析token\n   \n   app.use(jwt({secret:'bigevent'}).unless({path:/^\\/api/ }))\n   ```\n\n\n\n\n### 更新用户信息\n\n1. 根据token的id更新用户信息\n\n### 重置密码\n\n1. 根据用户的id和旧密码更新密码\n\n## 单词\n\n```js\nresolve //\nreject //拒绝\nawait // 等\naffected //影响的\nverify //验证\n```\n\n## session,cookie,token\n\n> cookie存在于客户端（浏览器），session存在于服务端。session的主要信息存在于服务器，在客户端只存放一个sessionid（基于cookie的），每次请求，客户端都会自动把sessionid发送到服务端去（因为是通过cookie保存的sessionid，每次发送请求，客户端会自动发送cookie到服务端），服务端根据sessionid去session里获取信息，做相应的操作。 \n\n- cookie\n\n  > http协议是无状态的，实际上需要维持客户端和服务器直接的状态，为了实现状态就诞生了cookie\n\n  存储在浏览器中，每次请求都需要携带cookie\n\n  有安全问题，大小限制4k\n\n- session\n\n  > 为了解决cookie的问题，诞生了sesssion\n\n  - 存储在服务器中，更加安全,存储量更大\n  - sessionID 可以借助cookie的方式进行传递，还可以通过url地址传递（URL重写）\n  - session不方便服务端的扩展\n\n- token\n\n  > session也有问题，所以有了token机制\n\n  - token认证模式，服务器不需要存储相关数据。\n  - token也有问题，是否可以让token主动失效，可以基于双token方式解决\n\n\n\n\n\n## ？\n\n1. mysql.query(sql,[],function(res)) ，什么时候用对象，什么时候用数组\n\n   ```\n   一个问号是对象，多个问号是数组\n   ```\n\n   ","source":"_posts/笔记/ocean/10-node.js总结/04-promise/04-笔记.md","raw":"---\ntitle: node promise\ndate: 2019-04-12 10:41:48\ncategories:\n- 笔记\n- node\ntags:\n- 前端\n- node\n---\n\n# 04-node.js\n\n## 异步编程\n\n> 如何获取异步结果?必须使用回调函数，那么就会形成函数嵌套，形成回调地狱，为了解决诞生了promise\n\n\n\n## Promise\n\n```js\n异步任务写到new Promise()回调函数里,随后使用res()将数据返回出来\n使用then()获取返回的正确结果\n\nvar pro = new Promise(function(res,rej){\n    \n    fs.readFile(filePath,'utf8',function(err,data){\n        if(err) return rej(err)\n        res(data)\n    })\n    \n})\n\npro.then(function(ret){ //正确执行\n\n}).catch(function(err){\t//错误执行\n    err\n})\n```\n\n+ 解决回调地狱\n\n  > promise是回调地狱的语法糖,仅仅提升代码可读性，功能没变\n\n  ```js\n  拿到第一个函数结果后，返回fun2(),然后在调用then\n  \n  fun1.then(function(res1){\n      \n      return fun2() //返回fun2()函数，里面是一个Promise对象\n  }).then(function(res2){\n      return fun3()\n  }).then(function(res3){\n      //如果这里没有return,then内部会默认生成一个新的promise,如果在then中直接返回具体数据，它会自动包装成Promise对象\n      \n  }).then(function(res4){\n      \n  })\n     .catch(function(err){ //任何一个then错误都执行catch\n      \n  })\n  ```\n\n\n\n### 案例\n\n1. 读取3个文件，并按顺序返回。\n2. 使用Promise封装数据库操作\n\n\n\n\n\n## Async\n\n> Promise虽然对代码进行了改进，但还不是最好的，所以诞生了Async/await函数，它是Promise的语法糖。\n\n\n\n-    async 是ES7新引入的关键字，放到函数前面，表示函数是一个异步函数\n-    await 是关键字,只能放在async函数内部使用\n\n\n\n### 使用\n\n```js\nasync function 函数名(){\n var ret = await 函数名() //使用await得到Promise返回的结果，必须在async函数中使用。\n console.log(ret) //\n}\n```\n\n\n\n\n\n## let和const\n\n+ ES3/5没有块级作用域\n+ ES6的块作用域必须有大括号\n\n### let\n\n1. let不可重新声明\n2. let会形成块作用域\n3. 使用`let命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 \n\n\n\n### const\n\n1. 声明常量，只读，不可修改，不可重复声明\n2. 不提升，没有预解析\n3. 必须在定义时初始化，名称最好大写\n\n\n\n\n\n##箭头函数\n\n+ 相当于是一个匿名函数\n+ 箭头函数本身没有this,它会尝试去父级查找this\n\n\n\n### 使用\n\n```js\nlet fo = ()=>{ }\nlet fo = n =>{ }\nlet fo = (n,m)=>{ }\nlet fo = n => return n\nlet fo = n => n  //只有一行代码默认会返回结果\n\n```\n\n\n\n\n\n##单独路由模块\n\n```js\nindex.js文件\n1.导入路由模块\nconst routers = require('./routers.js')\n\n2.添加路由的统一路径\napp.use('路径',routers)\n```\n\n```js\n创建routers.js文件\n1.导入模块\nconst express = require('express')\nconst routers = express.Router()\n\n\n2.挂载路由\nrouters.get('路径',(req,res)=>{\n    \n})\n\n3.导出\nmodule.exports = {\n    routers:routers\n}\n```\n\n\n\n\n\n## 图书接口\n\n###初始化\n\n1. 创建index.js文件 启动express服务器，跑起来后将路由模块分离至routers目录\n\n2. 创建db.js，连接数据库对数据库进行操作，然后将返回数据导出\n\n3. 拿到数据，进行路由处理\n\n   \n\n###注册\n\n1. 在routers文件目录下创建login.js文件\n2. 将监听请求放入路由，用户注册数据提交过来后，加密密码，使用mysql语言插入数据库，返回的是一个对象，判断该对象的affectedRows(影响行)大于0时注册成功。\n\n```js\nres.json(数据) //把对象数据转为json格式并返回给前端\nnew Promise().affectedRows > 0 //成功\n\n//单向加密，简单型密码会被破译\nreq.body.password = utility.md(密码)\n```\n\n###登录\n\n1. 客户端提交数据过来，把密码用md5加密。\n2. 然后和数据库密码对比，返回的数据是个数组，里面的一个对象就是数据库里的一行，然后判断它的长度>0时，说明查询成功有这个用户，登录成功了\n3. 登录成功后使用第三方包生成一个token，所有的token前面都要加'Bearer'，然后放入res.json里返回给前端\n\n\n\n\n\n\n\n\n\n### 用户信息\n\n1. 使用express-jwt包统一解析token，获取用户id\n\n2. 根据用户id查询用户信息\n\n   ```js\n   使用express-jwtexpress-jwt包解析token\n   \n   app.use(jwt({secret:'bigevent'}).unless({path:/^\\/api/ }))\n   ```\n\n\n\n\n### 更新用户信息\n\n1. 根据token的id更新用户信息\n\n### 重置密码\n\n1. 根据用户的id和旧密码更新密码\n\n## 单词\n\n```js\nresolve //\nreject //拒绝\nawait // 等\naffected //影响的\nverify //验证\n```\n\n## session,cookie,token\n\n> cookie存在于客户端（浏览器），session存在于服务端。session的主要信息存在于服务器，在客户端只存放一个sessionid（基于cookie的），每次请求，客户端都会自动把sessionid发送到服务端去（因为是通过cookie保存的sessionid，每次发送请求，客户端会自动发送cookie到服务端），服务端根据sessionid去session里获取信息，做相应的操作。 \n\n- cookie\n\n  > http协议是无状态的，实际上需要维持客户端和服务器直接的状态，为了实现状态就诞生了cookie\n\n  存储在浏览器中，每次请求都需要携带cookie\n\n  有安全问题，大小限制4k\n\n- session\n\n  > 为了解决cookie的问题，诞生了sesssion\n\n  - 存储在服务器中，更加安全,存储量更大\n  - sessionID 可以借助cookie的方式进行传递，还可以通过url地址传递（URL重写）\n  - session不方便服务端的扩展\n\n- token\n\n  > session也有问题，所以有了token机制\n\n  - token认证模式，服务器不需要存储相关数据。\n  - token也有问题，是否可以让token主动失效，可以基于双token方式解决\n\n\n\n\n\n## ？\n\n1. mysql.query(sql,[],function(res)) ，什么时候用对象，什么时候用数组\n\n   ```\n   一个问号是对象，多个问号是数组\n   ```\n\n   ","slug":"笔记/ocean/10-node.js总结/04-promise/04-笔记","published":1,"updated":"2023-03-01T07:12:09.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe700ahawaf9tsu8jp9","content":"<h1 id=\"04-node-js\"><a href=\"#04-node-js\" class=\"headerlink\" title=\"04-node.js\"></a>04-node.js</h1><h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>如何获取异步结果?必须使用回调函数，那么就会形成函数嵌套，形成回调地狱，为了解决诞生了promise</p>\n</blockquote>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><pre><code class=\"js\">异步任务写到new Promise()回调函数里,随后使用res()将数据返回出来\n使用then()获取返回的正确结果\n\nvar pro = new Promise(function(res,rej)&#123;\n    \n    fs.readFile(filePath,&#39;utf8&#39;,function(err,data)&#123;\n        if(err) return rej(err)\n        res(data)\n    &#125;)\n    \n&#125;)\n\npro.then(function(ret)&#123; //正确执行\n\n&#125;).catch(function(err)&#123;    //错误执行\n    err\n&#125;)\n</code></pre>\n<ul>\n<li><p>解决回调地狱</p>\n<blockquote>\n<p>promise是回调地狱的语法糖,仅仅提升代码可读性，功能没变</p>\n</blockquote>\n<pre><code class=\"js\">拿到第一个函数结果后，返回fun2(),然后在调用then\n\nfun1.then(function(res1)&#123;\n    \n    return fun2() //返回fun2()函数，里面是一个Promise对象\n&#125;).then(function(res2)&#123;\n    return fun3()\n&#125;).then(function(res3)&#123;\n    //如果这里没有return,then内部会默认生成一个新的promise,如果在then中直接返回具体数据，它会自动包装成Promise对象\n    \n&#125;).then(function(res4)&#123;\n    \n&#125;)\n   .catch(function(err)&#123; //任何一个then错误都执行catch\n    \n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ol>\n<li>读取3个文件，并按顺序返回。</li>\n<li>使用Promise封装数据库操作</li>\n</ol>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><blockquote>\n<p>Promise虽然对代码进行了改进，但还不是最好的，所以诞生了Async/await函数，它是Promise的语法糖。</p>\n</blockquote>\n<ul>\n<li>   async 是ES7新引入的关键字，放到函数前面，表示函数是一个异步函数</li>\n<li>   await 是关键字,只能放在async函数内部使用</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">async function 函数名()&#123;\n var ret = await 函数名() //使用await得到Promise返回的结果，必须在async函数中使用。\n console.log(ret) //\n&#125;\n</code></pre>\n<h2 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h2><ul>\n<li>ES3/5没有块级作用域</li>\n<li>ES6的块作用域必须有大括号</li>\n</ul>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><ol>\n<li>let不可重新声明</li>\n<li>let会形成块作用域</li>\n<li>使用`let命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 </li>\n</ol>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><ol>\n<li>声明常量，只读，不可修改，不可重复声明</li>\n<li>不提升，没有预解析</li>\n<li>必须在定义时初始化，名称最好大写</li>\n</ol>\n<p>##箭头函数</p>\n<ul>\n<li>相当于是一个匿名函数</li>\n<li>箭头函数本身没有this,它会尝试去父级查找this</li>\n</ul>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">let fo = ()=&gt;&#123; &#125;\nlet fo = n =&gt;&#123; &#125;\nlet fo = (n,m)=&gt;&#123; &#125;\nlet fo = n =&gt; return n\nlet fo = n =&gt; n  //只有一行代码默认会返回结果\n</code></pre>\n<p>##单独路由模块</p>\n<pre><code class=\"js\">index.js文件\n1.导入路由模块\nconst routers = require(&#39;./routers.js&#39;)\n\n2.添加路由的统一路径\napp.use(&#39;路径&#39;,routers)\n</code></pre>\n<pre><code class=\"js\">创建routers.js文件\n1.导入模块\nconst express = require(&#39;express&#39;)\nconst routers = express.Router()\n\n\n2.挂载路由\nrouters.get(&#39;路径&#39;,(req,res)=&gt;&#123;\n    \n&#125;)\n\n3.导出\nmodule.exports = &#123;\n    routers:routers\n&#125;\n</code></pre>\n<h2 id=\"图书接口\"><a href=\"#图书接口\" class=\"headerlink\" title=\"图书接口\"></a>图书接口</h2><p>###初始化</p>\n<ol>\n<li><p>创建index.js文件 启动express服务器，跑起来后将路由模块分离至routers目录</p>\n</li>\n<li><p>创建db.js，连接数据库对数据库进行操作，然后将返回数据导出</p>\n</li>\n<li><p>拿到数据，进行路由处理</p>\n</li>\n</ol>\n<p>###注册</p>\n<ol>\n<li>在routers文件目录下创建login.js文件</li>\n<li>将监听请求放入路由，用户注册数据提交过来后，加密密码，使用mysql语言插入数据库，返回的是一个对象，判断该对象的affectedRows(影响行)大于0时注册成功。</li>\n</ol>\n<pre><code class=\"js\">res.json(数据) //把对象数据转为json格式并返回给前端\nnew Promise().affectedRows &gt; 0 //成功\n\n//单向加密，简单型密码会被破译\nreq.body.password = utility.md(密码)\n</code></pre>\n<p>###登录</p>\n<ol>\n<li>客户端提交数据过来，把密码用md5加密。</li>\n<li>然后和数据库密码对比，返回的数据是个数组，里面的一个对象就是数据库里的一行，然后判断它的长度&gt;0时，说明查询成功有这个用户，登录成功了</li>\n<li>登录成功后使用第三方包生成一个token，所有的token前面都要加’Bearer’，然后放入res.json里返回给前端</li>\n</ol>\n<h3 id=\"用户信息\"><a href=\"#用户信息\" class=\"headerlink\" title=\"用户信息\"></a>用户信息</h3><ol>\n<li><p>使用express-jwt包统一解析token，获取用户id</p>\n</li>\n<li><p>根据用户id查询用户信息</p>\n<pre><code class=\"js\">使用express-jwtexpress-jwt包解析token\n\napp.use(jwt(&#123;secret:&#39;bigevent&#39;&#125;).unless(&#123;path:/^\\/api/ &#125;))\n</code></pre>\n</li>\n</ol>\n<h3 id=\"更新用户信息\"><a href=\"#更新用户信息\" class=\"headerlink\" title=\"更新用户信息\"></a>更新用户信息</h3><ol>\n<li>根据token的id更新用户信息</li>\n</ol>\n<h3 id=\"重置密码\"><a href=\"#重置密码\" class=\"headerlink\" title=\"重置密码\"></a>重置密码</h3><ol>\n<li>根据用户的id和旧密码更新密码</li>\n</ol>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">resolve //\nreject //拒绝\nawait // 等\naffected //影响的\nverify //验证\n</code></pre>\n<h2 id=\"session-cookie-token\"><a href=\"#session-cookie-token\" class=\"headerlink\" title=\"session,cookie,token\"></a>session,cookie,token</h2><blockquote>\n<p>cookie存在于客户端（浏览器），session存在于服务端。session的主要信息存在于服务器，在客户端只存放一个sessionid（基于cookie的），每次请求，客户端都会自动把sessionid发送到服务端去（因为是通过cookie保存的sessionid，每次发送请求，客户端会自动发送cookie到服务端），服务端根据sessionid去session里获取信息，做相应的操作。 </p>\n</blockquote>\n<ul>\n<li><p>cookie</p>\n<blockquote>\n<p>http协议是无状态的，实际上需要维持客户端和服务器直接的状态，为了实现状态就诞生了cookie</p>\n</blockquote>\n<p>存储在浏览器中，每次请求都需要携带cookie</p>\n<p>有安全问题，大小限制4k</p>\n</li>\n<li><p>session</p>\n<blockquote>\n<p>为了解决cookie的问题，诞生了sesssion</p>\n</blockquote>\n<ul>\n<li>存储在服务器中，更加安全,存储量更大</li>\n<li>sessionID 可以借助cookie的方式进行传递，还可以通过url地址传递（URL重写）</li>\n<li>session不方便服务端的扩展</li>\n</ul>\n</li>\n<li><p>token</p>\n<blockquote>\n<p>session也有问题，所以有了token机制</p>\n</blockquote>\n<ul>\n<li>token认证模式，服务器不需要存储相关数据。</li>\n<li>token也有问题，是否可以让token主动失效，可以基于双token方式解决</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>mysql.query(sql,[],function(res)) ，什么时候用对象，什么时候用数组</p>\n<pre><code>一个问号是对象，多个问号是数组\n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"04-node-js\"><a href=\"#04-node-js\" class=\"headerlink\" title=\"04-node.js\"></a>04-node.js</h1><h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><blockquote>\n<p>如何获取异步结果?必须使用回调函数，那么就会形成函数嵌套，形成回调地狱，为了解决诞生了promise</p>\n</blockquote>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><pre><code class=\"js\">异步任务写到new Promise()回调函数里,随后使用res()将数据返回出来\n使用then()获取返回的正确结果\n\nvar pro = new Promise(function(res,rej)&#123;\n    \n    fs.readFile(filePath,&#39;utf8&#39;,function(err,data)&#123;\n        if(err) return rej(err)\n        res(data)\n    &#125;)\n    \n&#125;)\n\npro.then(function(ret)&#123; //正确执行\n\n&#125;).catch(function(err)&#123;    //错误执行\n    err\n&#125;)\n</code></pre>\n<ul>\n<li><p>解决回调地狱</p>\n<blockquote>\n<p>promise是回调地狱的语法糖,仅仅提升代码可读性，功能没变</p>\n</blockquote>\n<pre><code class=\"js\">拿到第一个函数结果后，返回fun2(),然后在调用then\n\nfun1.then(function(res1)&#123;\n    \n    return fun2() //返回fun2()函数，里面是一个Promise对象\n&#125;).then(function(res2)&#123;\n    return fun3()\n&#125;).then(function(res3)&#123;\n    //如果这里没有return,then内部会默认生成一个新的promise,如果在then中直接返回具体数据，它会自动包装成Promise对象\n    \n&#125;).then(function(res4)&#123;\n    \n&#125;)\n   .catch(function(err)&#123; //任何一个then错误都执行catch\n    \n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ol>\n<li>读取3个文件，并按顺序返回。</li>\n<li>使用Promise封装数据库操作</li>\n</ol>\n<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><blockquote>\n<p>Promise虽然对代码进行了改进，但还不是最好的，所以诞生了Async/await函数，它是Promise的语法糖。</p>\n</blockquote>\n<ul>\n<li>   async 是ES7新引入的关键字，放到函数前面，表示函数是一个异步函数</li>\n<li>   await 是关键字,只能放在async函数内部使用</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">async function 函数名()&#123;\n var ret = await 函数名() //使用await得到Promise返回的结果，必须在async函数中使用。\n console.log(ret) //\n&#125;\n</code></pre>\n<h2 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h2><ul>\n<li>ES3/5没有块级作用域</li>\n<li>ES6的块作用域必须有大括号</li>\n</ul>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><ol>\n<li>let不可重新声明</li>\n<li>let会形成块作用域</li>\n<li>使用`let命令声明变量之前，该变量都是不可用的。 这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 </li>\n</ol>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><ol>\n<li>声明常量，只读，不可修改，不可重复声明</li>\n<li>不提升，没有预解析</li>\n<li>必须在定义时初始化，名称最好大写</li>\n</ol>\n<p>##箭头函数</p>\n<ul>\n<li>相当于是一个匿名函数</li>\n<li>箭头函数本身没有this,它会尝试去父级查找this</li>\n</ul>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"js\">let fo = ()=&gt;&#123; &#125;\nlet fo = n =&gt;&#123; &#125;\nlet fo = (n,m)=&gt;&#123; &#125;\nlet fo = n =&gt; return n\nlet fo = n =&gt; n  //只有一行代码默认会返回结果\n</code></pre>\n<p>##单独路由模块</p>\n<pre><code class=\"js\">index.js文件\n1.导入路由模块\nconst routers = require(&#39;./routers.js&#39;)\n\n2.添加路由的统一路径\napp.use(&#39;路径&#39;,routers)\n</code></pre>\n<pre><code class=\"js\">创建routers.js文件\n1.导入模块\nconst express = require(&#39;express&#39;)\nconst routers = express.Router()\n\n\n2.挂载路由\nrouters.get(&#39;路径&#39;,(req,res)=&gt;&#123;\n    \n&#125;)\n\n3.导出\nmodule.exports = &#123;\n    routers:routers\n&#125;\n</code></pre>\n<h2 id=\"图书接口\"><a href=\"#图书接口\" class=\"headerlink\" title=\"图书接口\"></a>图书接口</h2><p>###初始化</p>\n<ol>\n<li><p>创建index.js文件 启动express服务器，跑起来后将路由模块分离至routers目录</p>\n</li>\n<li><p>创建db.js，连接数据库对数据库进行操作，然后将返回数据导出</p>\n</li>\n<li><p>拿到数据，进行路由处理</p>\n</li>\n</ol>\n<p>###注册</p>\n<ol>\n<li>在routers文件目录下创建login.js文件</li>\n<li>将监听请求放入路由，用户注册数据提交过来后，加密密码，使用mysql语言插入数据库，返回的是一个对象，判断该对象的affectedRows(影响行)大于0时注册成功。</li>\n</ol>\n<pre><code class=\"js\">res.json(数据) //把对象数据转为json格式并返回给前端\nnew Promise().affectedRows &gt; 0 //成功\n\n//单向加密，简单型密码会被破译\nreq.body.password = utility.md(密码)\n</code></pre>\n<p>###登录</p>\n<ol>\n<li>客户端提交数据过来，把密码用md5加密。</li>\n<li>然后和数据库密码对比，返回的数据是个数组，里面的一个对象就是数据库里的一行，然后判断它的长度&gt;0时，说明查询成功有这个用户，登录成功了</li>\n<li>登录成功后使用第三方包生成一个token，所有的token前面都要加’Bearer’，然后放入res.json里返回给前端</li>\n</ol>\n<h3 id=\"用户信息\"><a href=\"#用户信息\" class=\"headerlink\" title=\"用户信息\"></a>用户信息</h3><ol>\n<li><p>使用express-jwt包统一解析token，获取用户id</p>\n</li>\n<li><p>根据用户id查询用户信息</p>\n<pre><code class=\"js\">使用express-jwtexpress-jwt包解析token\n\napp.use(jwt(&#123;secret:&#39;bigevent&#39;&#125;).unless(&#123;path:/^\\/api/ &#125;))\n</code></pre>\n</li>\n</ol>\n<h3 id=\"更新用户信息\"><a href=\"#更新用户信息\" class=\"headerlink\" title=\"更新用户信息\"></a>更新用户信息</h3><ol>\n<li>根据token的id更新用户信息</li>\n</ol>\n<h3 id=\"重置密码\"><a href=\"#重置密码\" class=\"headerlink\" title=\"重置密码\"></a>重置密码</h3><ol>\n<li>根据用户的id和旧密码更新密码</li>\n</ol>\n<h2 id=\"单词\"><a href=\"#单词\" class=\"headerlink\" title=\"单词\"></a>单词</h2><pre><code class=\"js\">resolve //\nreject //拒绝\nawait // 等\naffected //影响的\nverify //验证\n</code></pre>\n<h2 id=\"session-cookie-token\"><a href=\"#session-cookie-token\" class=\"headerlink\" title=\"session,cookie,token\"></a>session,cookie,token</h2><blockquote>\n<p>cookie存在于客户端（浏览器），session存在于服务端。session的主要信息存在于服务器，在客户端只存放一个sessionid（基于cookie的），每次请求，客户端都会自动把sessionid发送到服务端去（因为是通过cookie保存的sessionid，每次发送请求，客户端会自动发送cookie到服务端），服务端根据sessionid去session里获取信息，做相应的操作。 </p>\n</blockquote>\n<ul>\n<li><p>cookie</p>\n<blockquote>\n<p>http协议是无状态的，实际上需要维持客户端和服务器直接的状态，为了实现状态就诞生了cookie</p>\n</blockquote>\n<p>存储在浏览器中，每次请求都需要携带cookie</p>\n<p>有安全问题，大小限制4k</p>\n</li>\n<li><p>session</p>\n<blockquote>\n<p>为了解决cookie的问题，诞生了sesssion</p>\n</blockquote>\n<ul>\n<li>存储在服务器中，更加安全,存储量更大</li>\n<li>sessionID 可以借助cookie的方式进行传递，还可以通过url地址传递（URL重写）</li>\n<li>session不方便服务端的扩展</li>\n</ul>\n</li>\n<li><p>token</p>\n<blockquote>\n<p>session也有问题，所以有了token机制</p>\n</blockquote>\n<ul>\n<li>token认证模式，服务器不需要存储相关数据。</li>\n<li>token也有问题，是否可以让token主动失效，可以基于双token方式解决</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>mysql.query(sql,[],function(res)) ，什么时候用对象，什么时候用数组</p>\n<pre><code>一个问号是对象，多个问号是数组\n</code></pre>\n</li>\n</ol>\n"},{"title":"vue基础-什么是vue","date":"2020-08-20T13:34:23.000Z","_content":"# 01-什么是vue\n\n## 概念\n\n> Vue 是一套用于构建用户界面的渐进式框架 \n\n### 特性\n\n1. 渐进式开发\n   \n+ 可针对不同大小的项目搭配不同的vue技术组合，可以以一个对原项目最小的侵入性使开发\n   \n2. 申明式渲染\n   \n+ 提前声明一个视图,等待渲染\n   \n3. 数据驱动视图（响应式）\n   \n+ 数据一旦变化，视图立即变化\n   \n4. 双向绑定(mvvm)\n\n   + 视图数据变化，响应式数据也会立即变化，数据一旦变化，视图立即变化，也就是当视图或者数据变化时，它们的数据会互相同步\n\n5. 组件系统\n\n    \n\n6. 路由\n\n   + 不会整体刷新网页，实现局部刷新\n\n### 功能\n\n1. 单页面应用(重点)\n2. 多页面/应用开发\n3. 混合应用开发\n\n\n\n## 语法\n\n```js\n<body>\n    <div id=\"app\">\n        {{name}}\n        {{fun()}}\n     </div>\n</body>\n\n<script>\n   const vm = new Vue({\n    el:\"#app\", //作用：作为vue实例的挂载点，申明一下vue框架可以控制的试图区域。可传入css选择器字符串和htmlElment对象\n    data:{ //作用：为试图提供响应式数据\n            name:'zs'，\n            age:18,\n            arr:[1,2]\n    \t},\n    methods:{\n        fun:function(){\n            return '返回'\n        },\n        fun2:function(){\n            this.fun //调用fun方法\n        }\n    }\n}) \n</script>\n```\n\n\n\n## 插值表达式\n\n> 将数据动态的渲染到页面中\n\n+ 支持字符串拼接，数学运算，三元运算符，原生js方法\n\n+ 注意\n  1. 不能使用js语法，声明变量，for渲染\n  2. 不能使用自增\n  3. 表达式尽量简单\n\n  ```js\n  {{表达式或者原始值}}\n  ```\n\n\n\n## 指令\n\n> 指令(Directives)是带有v-前缀的特殊attribute \n\n+ 作用\n\n  1. 响应式的控制dom元素内容的变化\n\n     ```js\n     <div v-text/v-html='属性名' > </div>\n     \n     \n     v-text/v-html //会完全交给它们控制\n     v-html//会厂生安全问题\n     ```\n\n  2. 响应式的控制dom元素的显示和隐藏\n\n     ```js\n     true显示，false隐藏\n     1.内部使用的控制css样式，适合切换频率高的场景\n     <div v-show='表达式(布尔值)' ></div>\n     \n     \n     2.内部使用的是原生的js控制dom操作，适合切换频率低的场景\n     //频繁使用，消耗性能较大\n     <div v-if='表达式(布尔值)' >true显示</div>\n     <div v-else>否则显示</div>\n     \n        // 注意：v-if和v-else之间不能有其他元素存在否则报错\n         //  v-else-if(2.0版本之后新增)\n     ```\n\n  3. 响应式控制元素attribute\n\n     ```js\n     <a  v-bind:href=\"js表达式(data中响应的数据)\"> \n     简写\n     <a :href=\"js表达式(data中响应的数据)\"> \n     ```\n\n  4. 为元素绑定事件 \n\n     ```js\n     <button v-on:事件=\"methods中的方法\"></button>\n     \n     \n     1.简写\n     <button @事件=\"methods中的方法\"></button>\n     <button @事件=\"num++\"></button> //每次点击都++\n     \n     \n     2.传参，不传参时不用写()\n     <button @事件=\"fun（参数）\"></button>\n     \n     3.传e，将e对象放入最后，只要e的时候不需要传参\n     <button @事件=\"fun(参1,$event)\"></button>\n     \n     methods:{\n         fun(参1,e){\n         }\n     }\n     \n     事件修饰符，使用时查文档\n     @click.prevent 阻止默认事件\n     @click.stop 阻止冒泡事件向上传递\n     @click.once 只触发一次事件\n     @keydown.enter 回车触发函数 （各种按键，可自定义键值触发）\n     ```\n\n     ​\t\n\n  5. 循环\n\n     + 在使用v-for时，经常需要配合一个自定义属性添加:key会提升性能，key的值是一个唯一的字符串或number\n\n     ```js\n     1.循环数组\n     <div v-for=\"(item,index) in list\" :key='唯一标志'>\n         {{item}}\n     </div>\n     \n     <script>\n         data:{\n             list:['a','b']\n         }\n     </script>\n     \n     \n     2.循环对象\n     <div v-for=\"(value,name,index) in obj\" :key='唯一标志'>\n         {{value}}值\n         {{name}}键\n         {{index}}遍历的第几个键值对\n         它们的名字是自定义的。\n     </div>\n     <script>\n         data:{\n             obj:{\n                 name:12,\n                 age:23\n             }\n         }\n     </script>\n     \n     \n     3.循环数值\n     <div v-for=\"(item) in num\" :key='唯一标志'>\n         {{item}} //从1开始重复几次\n     </div>\n     <script>\n         data:{\n            num:5\n         }\n     </script>\n     ```\n\n     ","source":"_posts/笔记/ocean/12-Vue总结/01-什么是vue/01-笔记.md","raw":"---\ntitle: vue基础-什么是vue\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n# 01-什么是vue\n\n## 概念\n\n> Vue 是一套用于构建用户界面的渐进式框架 \n\n### 特性\n\n1. 渐进式开发\n   \n+ 可针对不同大小的项目搭配不同的vue技术组合，可以以一个对原项目最小的侵入性使开发\n   \n2. 申明式渲染\n   \n+ 提前声明一个视图,等待渲染\n   \n3. 数据驱动视图（响应式）\n   \n+ 数据一旦变化，视图立即变化\n   \n4. 双向绑定(mvvm)\n\n   + 视图数据变化，响应式数据也会立即变化，数据一旦变化，视图立即变化，也就是当视图或者数据变化时，它们的数据会互相同步\n\n5. 组件系统\n\n    \n\n6. 路由\n\n   + 不会整体刷新网页，实现局部刷新\n\n### 功能\n\n1. 单页面应用(重点)\n2. 多页面/应用开发\n3. 混合应用开发\n\n\n\n## 语法\n\n```js\n<body>\n    <div id=\"app\">\n        {{name}}\n        {{fun()}}\n     </div>\n</body>\n\n<script>\n   const vm = new Vue({\n    el:\"#app\", //作用：作为vue实例的挂载点，申明一下vue框架可以控制的试图区域。可传入css选择器字符串和htmlElment对象\n    data:{ //作用：为试图提供响应式数据\n            name:'zs'，\n            age:18,\n            arr:[1,2]\n    \t},\n    methods:{\n        fun:function(){\n            return '返回'\n        },\n        fun2:function(){\n            this.fun //调用fun方法\n        }\n    }\n}) \n</script>\n```\n\n\n\n## 插值表达式\n\n> 将数据动态的渲染到页面中\n\n+ 支持字符串拼接，数学运算，三元运算符，原生js方法\n\n+ 注意\n  1. 不能使用js语法，声明变量，for渲染\n  2. 不能使用自增\n  3. 表达式尽量简单\n\n  ```js\n  {{表达式或者原始值}}\n  ```\n\n\n\n## 指令\n\n> 指令(Directives)是带有v-前缀的特殊attribute \n\n+ 作用\n\n  1. 响应式的控制dom元素内容的变化\n\n     ```js\n     <div v-text/v-html='属性名' > </div>\n     \n     \n     v-text/v-html //会完全交给它们控制\n     v-html//会厂生安全问题\n     ```\n\n  2. 响应式的控制dom元素的显示和隐藏\n\n     ```js\n     true显示，false隐藏\n     1.内部使用的控制css样式，适合切换频率高的场景\n     <div v-show='表达式(布尔值)' ></div>\n     \n     \n     2.内部使用的是原生的js控制dom操作，适合切换频率低的场景\n     //频繁使用，消耗性能较大\n     <div v-if='表达式(布尔值)' >true显示</div>\n     <div v-else>否则显示</div>\n     \n        // 注意：v-if和v-else之间不能有其他元素存在否则报错\n         //  v-else-if(2.0版本之后新增)\n     ```\n\n  3. 响应式控制元素attribute\n\n     ```js\n     <a  v-bind:href=\"js表达式(data中响应的数据)\"> \n     简写\n     <a :href=\"js表达式(data中响应的数据)\"> \n     ```\n\n  4. 为元素绑定事件 \n\n     ```js\n     <button v-on:事件=\"methods中的方法\"></button>\n     \n     \n     1.简写\n     <button @事件=\"methods中的方法\"></button>\n     <button @事件=\"num++\"></button> //每次点击都++\n     \n     \n     2.传参，不传参时不用写()\n     <button @事件=\"fun（参数）\"></button>\n     \n     3.传e，将e对象放入最后，只要e的时候不需要传参\n     <button @事件=\"fun(参1,$event)\"></button>\n     \n     methods:{\n         fun(参1,e){\n         }\n     }\n     \n     事件修饰符，使用时查文档\n     @click.prevent 阻止默认事件\n     @click.stop 阻止冒泡事件向上传递\n     @click.once 只触发一次事件\n     @keydown.enter 回车触发函数 （各种按键，可自定义键值触发）\n     ```\n\n     ​\t\n\n  5. 循环\n\n     + 在使用v-for时，经常需要配合一个自定义属性添加:key会提升性能，key的值是一个唯一的字符串或number\n\n     ```js\n     1.循环数组\n     <div v-for=\"(item,index) in list\" :key='唯一标志'>\n         {{item}}\n     </div>\n     \n     <script>\n         data:{\n             list:['a','b']\n         }\n     </script>\n     \n     \n     2.循环对象\n     <div v-for=\"(value,name,index) in obj\" :key='唯一标志'>\n         {{value}}值\n         {{name}}键\n         {{index}}遍历的第几个键值对\n         它们的名字是自定义的。\n     </div>\n     <script>\n         data:{\n             obj:{\n                 name:12,\n                 age:23\n             }\n         }\n     </script>\n     \n     \n     3.循环数值\n     <div v-for=\"(item) in num\" :key='唯一标志'>\n         {{item}} //从1开始重复几次\n     </div>\n     <script>\n         data:{\n            num:5\n         }\n     </script>\n     ```\n\n     ","slug":"笔记/ocean/12-Vue总结/01-什么是vue/01-笔记","published":1,"updated":"2023-03-01T07:27:38.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe700akawaf55r6aeh2","content":"<h1 id=\"01-什么是vue\"><a href=\"#01-什么是vue\" class=\"headerlink\" title=\"01-什么是vue\"></a>01-什么是vue</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>Vue 是一套用于构建用户界面的渐进式框架 </p>\n</blockquote>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li>渐进式开发</li>\n</ol>\n<ul>\n<li>可针对不同大小的项目搭配不同的vue技术组合，可以以一个对原项目最小的侵入性使开发</li>\n</ul>\n<ol start=\"2\">\n<li>申明式渲染</li>\n</ol>\n<ul>\n<li>提前声明一个视图,等待渲染</li>\n</ul>\n<ol start=\"3\">\n<li>数据驱动视图（响应式）</li>\n</ol>\n<ul>\n<li>数据一旦变化，视图立即变化</li>\n</ul>\n<ol start=\"4\">\n<li><p>双向绑定(mvvm)</p>\n<ul>\n<li>视图数据变化，响应式数据也会立即变化，数据一旦变化，视图立即变化，也就是当视图或者数据变化时，它们的数据会互相同步</li>\n</ul>\n</li>\n<li><p>组件系统</p>\n</li>\n<li><p>路由</p>\n<ul>\n<li>不会整体刷新网页，实现局部刷新</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>单页面应用(重点)</li>\n<li>多页面/应用开发</li>\n<li>混合应用开发</li>\n</ol>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre><code class=\"js\">&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &#123;&#123;name&#125;&#125;\n        &#123;&#123;fun()&#125;&#125;\n     &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n   const vm = new Vue(&#123;\n    el:&quot;#app&quot;, //作用：作为vue实例的挂载点，申明一下vue框架可以控制的试图区域。可传入css选择器字符串和htmlElment对象\n    data:&#123; //作用：为试图提供响应式数据\n            name:&#39;zs&#39;，\n            age:18,\n            arr:[1,2]\n        &#125;,\n    methods:&#123;\n        fun:function()&#123;\n            return &#39;返回&#39;\n        &#125;,\n        fun2:function()&#123;\n            this.fun //调用fun方法\n        &#125;\n    &#125;\n&#125;) \n&lt;/script&gt;\n</code></pre>\n<h2 id=\"插值表达式\"><a href=\"#插值表达式\" class=\"headerlink\" title=\"插值表达式\"></a>插值表达式</h2><blockquote>\n<p>将数据动态的渲染到页面中</p>\n</blockquote>\n<ul>\n<li><p>支持字符串拼接，数学运算，三元运算符，原生js方法</p>\n</li>\n<li><p>注意</p>\n<ol>\n<li>不能使用js语法，声明变量，for渲染</li>\n<li>不能使用自增</li>\n<li>表达式尽量简单</li>\n</ol>\n<pre><code class=\"js\">&#123;&#123;表达式或者原始值&#125;&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><blockquote>\n<p>指令(Directives)是带有v-前缀的特殊attribute </p>\n</blockquote>\n<ul>\n<li><p>作用</p>\n<ol>\n<li><p>响应式的控制dom元素内容的变化</p>\n<pre><code class=\"js\">&lt;div v-text/v-html=&#39;属性名&#39; &gt; &lt;/div&gt;\n\n\nv-text/v-html //会完全交给它们控制\nv-html//会厂生安全问题\n</code></pre>\n</li>\n<li><p>响应式的控制dom元素的显示和隐藏</p>\n<pre><code class=\"js\">true显示，false隐藏\n1.内部使用的控制css样式，适合切换频率高的场景\n&lt;div v-show=&#39;表达式(布尔值)&#39; &gt;&lt;/div&gt;\n\n\n2.内部使用的是原生的js控制dom操作，适合切换频率低的场景\n//频繁使用，消耗性能较大\n&lt;div v-if=&#39;表达式(布尔值)&#39; &gt;true显示&lt;/div&gt;\n&lt;div v-else&gt;否则显示&lt;/div&gt;\n\n   // 注意：v-if和v-else之间不能有其他元素存在否则报错\n    //  v-else-if(2.0版本之后新增)\n</code></pre>\n</li>\n<li><p>响应式控制元素attribute</p>\n<pre><code class=\"js\">&lt;a  v-bind:href=&quot;js表达式(data中响应的数据)&quot;&gt; \n简写\n&lt;a :href=&quot;js表达式(data中响应的数据)&quot;&gt; \n</code></pre>\n</li>\n<li><p>为元素绑定事件 </p>\n<pre><code class=\"js\">&lt;button v-on:事件=&quot;methods中的方法&quot;&gt;&lt;/button&gt;\n\n\n1.简写\n&lt;button @事件=&quot;methods中的方法&quot;&gt;&lt;/button&gt;\n&lt;button @事件=&quot;num++&quot;&gt;&lt;/button&gt; //每次点击都++\n\n\n2.传参，不传参时不用写()\n&lt;button @事件=&quot;fun（参数）&quot;&gt;&lt;/button&gt;\n\n3.传e，将e对象放入最后，只要e的时候不需要传参\n&lt;button @事件=&quot;fun(参1,$event)&quot;&gt;&lt;/button&gt;\n\nmethods:&#123;\n    fun(参1,e)&#123;\n    &#125;\n&#125;\n\n事件修饰符，使用时查文档\n@click.prevent 阻止默认事件\n@click.stop 阻止冒泡事件向上传递\n@click.once 只触发一次事件\n@keydown.enter 回车触发函数 （各种按键，可自定义键值触发）\n</code></pre>\n<p>​    </p>\n</li>\n<li><p>循环</p>\n<ul>\n<li>在使用v-for时，经常需要配合一个自定义属性添加:key会提升性能，key的值是一个唯一的字符串或number</li>\n</ul>\n<pre><code class=\"js\">1.循环数组\n&lt;div v-for=&quot;(item,index) in list&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;item&#125;&#125;\n&lt;/div&gt;\n\n&lt;script&gt;\n    data:&#123;\n        list:[&#39;a&#39;,&#39;b&#39;]\n    &#125;\n&lt;/script&gt;\n\n\n2.循环对象\n&lt;div v-for=&quot;(value,name,index) in obj&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;value&#125;&#125;值\n    &#123;&#123;name&#125;&#125;键\n    &#123;&#123;index&#125;&#125;遍历的第几个键值对\n    它们的名字是自定义的。\n&lt;/div&gt;\n&lt;script&gt;\n    data:&#123;\n        obj:&#123;\n            name:12,\n            age:23\n        &#125;\n    &#125;\n&lt;/script&gt;\n\n\n3.循环数值\n&lt;div v-for=&quot;(item) in num&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;item&#125;&#125; //从1开始重复几次\n&lt;/div&gt;\n&lt;script&gt;\n    data:&#123;\n       num:5\n    &#125;\n&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-什么是vue\"><a href=\"#01-什么是vue\" class=\"headerlink\" title=\"01-什么是vue\"></a>01-什么是vue</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>Vue 是一套用于构建用户界面的渐进式框架 </p>\n</blockquote>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li>渐进式开发</li>\n</ol>\n<ul>\n<li>可针对不同大小的项目搭配不同的vue技术组合，可以以一个对原项目最小的侵入性使开发</li>\n</ul>\n<ol start=\"2\">\n<li>申明式渲染</li>\n</ol>\n<ul>\n<li>提前声明一个视图,等待渲染</li>\n</ul>\n<ol start=\"3\">\n<li>数据驱动视图（响应式）</li>\n</ol>\n<ul>\n<li>数据一旦变化，视图立即变化</li>\n</ul>\n<ol start=\"4\">\n<li><p>双向绑定(mvvm)</p>\n<ul>\n<li>视图数据变化，响应式数据也会立即变化，数据一旦变化，视图立即变化，也就是当视图或者数据变化时，它们的数据会互相同步</li>\n</ul>\n</li>\n<li><p>组件系统</p>\n</li>\n<li><p>路由</p>\n<ul>\n<li>不会整体刷新网页，实现局部刷新</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>单页面应用(重点)</li>\n<li>多页面/应用开发</li>\n<li>混合应用开发</li>\n</ol>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre><code class=\"js\">&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &#123;&#123;name&#125;&#125;\n        &#123;&#123;fun()&#125;&#125;\n     &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n   const vm = new Vue(&#123;\n    el:&quot;#app&quot;, //作用：作为vue实例的挂载点，申明一下vue框架可以控制的试图区域。可传入css选择器字符串和htmlElment对象\n    data:&#123; //作用：为试图提供响应式数据\n            name:&#39;zs&#39;，\n            age:18,\n            arr:[1,2]\n        &#125;,\n    methods:&#123;\n        fun:function()&#123;\n            return &#39;返回&#39;\n        &#125;,\n        fun2:function()&#123;\n            this.fun //调用fun方法\n        &#125;\n    &#125;\n&#125;) \n&lt;/script&gt;\n</code></pre>\n<h2 id=\"插值表达式\"><a href=\"#插值表达式\" class=\"headerlink\" title=\"插值表达式\"></a>插值表达式</h2><blockquote>\n<p>将数据动态的渲染到页面中</p>\n</blockquote>\n<ul>\n<li><p>支持字符串拼接，数学运算，三元运算符，原生js方法</p>\n</li>\n<li><p>注意</p>\n<ol>\n<li>不能使用js语法，声明变量，for渲染</li>\n<li>不能使用自增</li>\n<li>表达式尽量简单</li>\n</ol>\n<pre><code class=\"js\">&#123;&#123;表达式或者原始值&#125;&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><blockquote>\n<p>指令(Directives)是带有v-前缀的特殊attribute </p>\n</blockquote>\n<ul>\n<li><p>作用</p>\n<ol>\n<li><p>响应式的控制dom元素内容的变化</p>\n<pre><code class=\"js\">&lt;div v-text/v-html=&#39;属性名&#39; &gt; &lt;/div&gt;\n\n\nv-text/v-html //会完全交给它们控制\nv-html//会厂生安全问题\n</code></pre>\n</li>\n<li><p>响应式的控制dom元素的显示和隐藏</p>\n<pre><code class=\"js\">true显示，false隐藏\n1.内部使用的控制css样式，适合切换频率高的场景\n&lt;div v-show=&#39;表达式(布尔值)&#39; &gt;&lt;/div&gt;\n\n\n2.内部使用的是原生的js控制dom操作，适合切换频率低的场景\n//频繁使用，消耗性能较大\n&lt;div v-if=&#39;表达式(布尔值)&#39; &gt;true显示&lt;/div&gt;\n&lt;div v-else&gt;否则显示&lt;/div&gt;\n\n   // 注意：v-if和v-else之间不能有其他元素存在否则报错\n    //  v-else-if(2.0版本之后新增)\n</code></pre>\n</li>\n<li><p>响应式控制元素attribute</p>\n<pre><code class=\"js\">&lt;a  v-bind:href=&quot;js表达式(data中响应的数据)&quot;&gt; \n简写\n&lt;a :href=&quot;js表达式(data中响应的数据)&quot;&gt; \n</code></pre>\n</li>\n<li><p>为元素绑定事件 </p>\n<pre><code class=\"js\">&lt;button v-on:事件=&quot;methods中的方法&quot;&gt;&lt;/button&gt;\n\n\n1.简写\n&lt;button @事件=&quot;methods中的方法&quot;&gt;&lt;/button&gt;\n&lt;button @事件=&quot;num++&quot;&gt;&lt;/button&gt; //每次点击都++\n\n\n2.传参，不传参时不用写()\n&lt;button @事件=&quot;fun（参数）&quot;&gt;&lt;/button&gt;\n\n3.传e，将e对象放入最后，只要e的时候不需要传参\n&lt;button @事件=&quot;fun(参1,$event)&quot;&gt;&lt;/button&gt;\n\nmethods:&#123;\n    fun(参1,e)&#123;\n    &#125;\n&#125;\n\n事件修饰符，使用时查文档\n@click.prevent 阻止默认事件\n@click.stop 阻止冒泡事件向上传递\n@click.once 只触发一次事件\n@keydown.enter 回车触发函数 （各种按键，可自定义键值触发）\n</code></pre>\n<p>​    </p>\n</li>\n<li><p>循环</p>\n<ul>\n<li>在使用v-for时，经常需要配合一个自定义属性添加:key会提升性能，key的值是一个唯一的字符串或number</li>\n</ul>\n<pre><code class=\"js\">1.循环数组\n&lt;div v-for=&quot;(item,index) in list&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;item&#125;&#125;\n&lt;/div&gt;\n\n&lt;script&gt;\n    data:&#123;\n        list:[&#39;a&#39;,&#39;b&#39;]\n    &#125;\n&lt;/script&gt;\n\n\n2.循环对象\n&lt;div v-for=&quot;(value,name,index) in obj&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;value&#125;&#125;值\n    &#123;&#123;name&#125;&#125;键\n    &#123;&#123;index&#125;&#125;遍历的第几个键值对\n    它们的名字是自定义的。\n&lt;/div&gt;\n&lt;script&gt;\n    data:&#123;\n        obj:&#123;\n            name:12,\n            age:23\n        &#125;\n    &#125;\n&lt;/script&gt;\n\n\n3.循环数值\n&lt;div v-for=&quot;(item) in num&quot; :key=&#39;唯一标志&#39;&gt;\n    &#123;&#123;item&#125;&#125; //从1开始重复几次\n&lt;/div&gt;\n&lt;script&gt;\n    data:&#123;\n       num:5\n    &#125;\n&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"vue基础-生命周期","date":"2020-08-20T13:34:23.000Z","_content":"# 03-vue\n\n## computed计算属性\n\n> 当其依赖的属性值发生变化时，计算属性会重新计算，反之则使用缓存中的属性值\n\n###为什么需要computed\n\n当模板中的表达式放入太多逻辑时，会让模板变重，难于维护，所以需要computed来解决逻辑。\n\n###特性\n\n1. 虽然定义的是一个函数,但是它叫做计算属性所以使用时不加()\n\n2. computed属性中依赖的属性只要发生改变，就会重新计算\n\n3. computed属性是响应式的，计算属性重新计算后，会渲染到视图模板\n\n4. computed属性是有 缓存特性的只有第一次使用会调用函数，以后在遇到会使用缓存\n\n5. computed属性不适合做大开销操作，经常和模板进行配合使用\n\n   watch灵活，可以做大开销操作，一般不和模板配合\n\n###语法\n\n```js\n<div>{{c}}</div>\n{\n    computed:{\n        c(){ \n            return this.a +this.b\n        }\n    }\n}\n```\n\n\n## watch监听器\n\n> 监听实例化属性的变化，一旦属性发生变化之后立即执行绑定的回调函数，经常用来做ajax调用接口\n\n+ 不要滥用用watch，多用computed\n\n###语法\n\n```js\n{\n    watch:{\n        '要监听的数据名':function(){ //这里不支持箭头函数\n        }\n    }   \n}\n```\n\n\n\n## vue的生命周期\n\n>  vue实例从**创建、初始化数据、挂载、更新、销毁**，这就是一个组件所谓的生命周期。 每一个期间都有一个生命周期钩子函数\n\n\n\n### vue的执行阶段生命周期函数\n\n```js\n    new Vue()实例化vue对象\n1.beforeCreate() //data和methods中的数据和方法都还没有初始化\n\t初始化data和methods\n2.Created() //data和methods都已经初始化好了，如果要操作data中的数据或是调用methods中的方法，最早只能在created中操作\n\t检查el，检查是否有template属性,无则等手动绑定vm.$mount\n3.beforeMount() //模板已经在内存中编译好了，但尚未挂载到页面中去，此时，页面还是旧的\n\t将内存中编译好的模板，真实的替换到浏览器的页面中区\n4.mounted() //数据和DOM都已被挂载到了视图\n\n\n5.beforeUpdate() //页面中显示的数据还是旧的，此时data中的数据是最新的，页面尚未和最新数据同步\n6.updated() //vue（组件）对象对应的dom中的内部（innerHTML）改变了\n\n7.activated() //keep-alive组件激活时调用\n8.deactivated() //keep-alive组件停用时调用\n\n9.beforeDestroy() //vue（组件）对象销毁之前\n\tvm.$destroy() 销毁\n10.destroyed() //vue组件销毁后\n\n```\n\n\n\n\n\n## vue component\n\n> 每一个独立的功能区域都可以构成一个组件，一个完整的页面往往是有多个组件搭建出来的，组件的优点是复用性\n\n+ data为什么是函数？\n\n  因为只有声明为函数，才能渲染一次调用一次函数，且不会影响不同实例化中的数据。\n\n### 全局component\n\n```js\n<name-component></name-component>\n\nVue.component('name-component',{\n    //组件所有配置\n    template:` \n\t\t要渲染的html\n\t`,\n    data(){ //data是一个函数，在函数返回中定义响应式数据\n        return:{\n            属性\n        }\n    },\n    methods:{\n        方法\n    }\n}\n})\n```\n\n### 局部component\n\n```js\nconst Module = {\t//vue会识别驼峰，并自动转为-\n    data(){\n        return {\n            属性\n        }\n    },\n    template:`html`,\n    ..\n}\n\nconst vm = new Vue({\n    el:\"\",\n    data:{},\n    components:{\n        Module\n    }\n})\n```\n\n### component的嵌套\n\n1. 要避免循环嵌套\n2. 组件嵌套不限制组件类型，全局和局部之间可以互相嵌套\n3. template中只能有一个根元素\n\n+ 全局的嵌套\n\n  ```js\n  <component-name><component-name>\n      \n  Vue.component('component-name',{\n  \ttemplate:`\n  \t<component-name2></component-name2>\n  \t`\n  })\n  \n  \n  Vue.component('component-name2',{\n  \t\t    \n  }) \n  \n  \n  --默认状态下组件内部的内容会被忽略，比如组件嵌套，组件2不会生效\n  <componente1>\n      <componente2></component2>\n  </component1>\n  ```\n\n  \n\n+ 全局内嵌套局部\n\n+ 局部内嵌套全局\n+ 局部内嵌套局部\n\n\n\n\n\n\n\n## 工具\n\n### mock数据\n\n+ 为了提高前端开发速度，降低对后端的依赖，自己造数据\n\n### json-server包\n\n```js\n1.下载json-server\nnpm install json-server -g\n\n\n2.启动一个json服务器文件\njson-server --port 端口 json文件\n```\n\n\n\n## ？\n\n1. 计算属性可以传参吗？\n\n   不能\n\n2. computed属性和watch的区别\n\n   computed：适合多个数据或对象进行计算处理后返回一个结果，\n\n   watch监听一个data中属性的改变。\n\n3. computed属性和methods的区别\n\n   ```js\n   1.computed有缓存，methods没有缓存，\n   2.computed是响应式的，methods并非响应式。\n   3.computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 \n   ```\n\n   \n\n","source":"_posts/笔记/ocean/12-Vue总结/03-component-生命周期-computed/03-笔记.md","raw":"---\ntitle: vue基础-生命周期\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n# 03-vue\n\n## computed计算属性\n\n> 当其依赖的属性值发生变化时，计算属性会重新计算，反之则使用缓存中的属性值\n\n###为什么需要computed\n\n当模板中的表达式放入太多逻辑时，会让模板变重，难于维护，所以需要computed来解决逻辑。\n\n###特性\n\n1. 虽然定义的是一个函数,但是它叫做计算属性所以使用时不加()\n\n2. computed属性中依赖的属性只要发生改变，就会重新计算\n\n3. computed属性是响应式的，计算属性重新计算后，会渲染到视图模板\n\n4. computed属性是有 缓存特性的只有第一次使用会调用函数，以后在遇到会使用缓存\n\n5. computed属性不适合做大开销操作，经常和模板进行配合使用\n\n   watch灵活，可以做大开销操作，一般不和模板配合\n\n###语法\n\n```js\n<div>{{c}}</div>\n{\n    computed:{\n        c(){ \n            return this.a +this.b\n        }\n    }\n}\n```\n\n\n## watch监听器\n\n> 监听实例化属性的变化，一旦属性发生变化之后立即执行绑定的回调函数，经常用来做ajax调用接口\n\n+ 不要滥用用watch，多用computed\n\n###语法\n\n```js\n{\n    watch:{\n        '要监听的数据名':function(){ //这里不支持箭头函数\n        }\n    }   \n}\n```\n\n\n\n## vue的生命周期\n\n>  vue实例从**创建、初始化数据、挂载、更新、销毁**，这就是一个组件所谓的生命周期。 每一个期间都有一个生命周期钩子函数\n\n\n\n### vue的执行阶段生命周期函数\n\n```js\n    new Vue()实例化vue对象\n1.beforeCreate() //data和methods中的数据和方法都还没有初始化\n\t初始化data和methods\n2.Created() //data和methods都已经初始化好了，如果要操作data中的数据或是调用methods中的方法，最早只能在created中操作\n\t检查el，检查是否有template属性,无则等手动绑定vm.$mount\n3.beforeMount() //模板已经在内存中编译好了，但尚未挂载到页面中去，此时，页面还是旧的\n\t将内存中编译好的模板，真实的替换到浏览器的页面中区\n4.mounted() //数据和DOM都已被挂载到了视图\n\n\n5.beforeUpdate() //页面中显示的数据还是旧的，此时data中的数据是最新的，页面尚未和最新数据同步\n6.updated() //vue（组件）对象对应的dom中的内部（innerHTML）改变了\n\n7.activated() //keep-alive组件激活时调用\n8.deactivated() //keep-alive组件停用时调用\n\n9.beforeDestroy() //vue（组件）对象销毁之前\n\tvm.$destroy() 销毁\n10.destroyed() //vue组件销毁后\n\n```\n\n\n\n\n\n## vue component\n\n> 每一个独立的功能区域都可以构成一个组件，一个完整的页面往往是有多个组件搭建出来的，组件的优点是复用性\n\n+ data为什么是函数？\n\n  因为只有声明为函数，才能渲染一次调用一次函数，且不会影响不同实例化中的数据。\n\n### 全局component\n\n```js\n<name-component></name-component>\n\nVue.component('name-component',{\n    //组件所有配置\n    template:` \n\t\t要渲染的html\n\t`,\n    data(){ //data是一个函数，在函数返回中定义响应式数据\n        return:{\n            属性\n        }\n    },\n    methods:{\n        方法\n    }\n}\n})\n```\n\n### 局部component\n\n```js\nconst Module = {\t//vue会识别驼峰，并自动转为-\n    data(){\n        return {\n            属性\n        }\n    },\n    template:`html`,\n    ..\n}\n\nconst vm = new Vue({\n    el:\"\",\n    data:{},\n    components:{\n        Module\n    }\n})\n```\n\n### component的嵌套\n\n1. 要避免循环嵌套\n2. 组件嵌套不限制组件类型，全局和局部之间可以互相嵌套\n3. template中只能有一个根元素\n\n+ 全局的嵌套\n\n  ```js\n  <component-name><component-name>\n      \n  Vue.component('component-name',{\n  \ttemplate:`\n  \t<component-name2></component-name2>\n  \t`\n  })\n  \n  \n  Vue.component('component-name2',{\n  \t\t    \n  }) \n  \n  \n  --默认状态下组件内部的内容会被忽略，比如组件嵌套，组件2不会生效\n  <componente1>\n      <componente2></component2>\n  </component1>\n  ```\n\n  \n\n+ 全局内嵌套局部\n\n+ 局部内嵌套全局\n+ 局部内嵌套局部\n\n\n\n\n\n\n\n## 工具\n\n### mock数据\n\n+ 为了提高前端开发速度，降低对后端的依赖，自己造数据\n\n### json-server包\n\n```js\n1.下载json-server\nnpm install json-server -g\n\n\n2.启动一个json服务器文件\njson-server --port 端口 json文件\n```\n\n\n\n## ？\n\n1. 计算属性可以传参吗？\n\n   不能\n\n2. computed属性和watch的区别\n\n   computed：适合多个数据或对象进行计算处理后返回一个结果，\n\n   watch监听一个data中属性的改变。\n\n3. computed属性和methods的区别\n\n   ```js\n   1.computed有缓存，methods没有缓存，\n   2.computed是响应式的，methods并非响应式。\n   3.computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 \n   ```\n\n   \n\n","slug":"笔记/ocean/12-Vue总结/03-component-生命周期-computed/03-笔记","published":1,"updated":"2023-03-01T07:28:04.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe800apawaf845o7b2d","content":"<h1 id=\"03-vue\"><a href=\"#03-vue\" class=\"headerlink\" title=\"03-vue\"></a>03-vue</h1><h2 id=\"computed计算属性\"><a href=\"#computed计算属性\" class=\"headerlink\" title=\"computed计算属性\"></a>computed计算属性</h2><blockquote>\n<p>当其依赖的属性值发生变化时，计算属性会重新计算，反之则使用缓存中的属性值</p>\n</blockquote>\n<p>###为什么需要computed</p>\n<p>当模板中的表达式放入太多逻辑时，会让模板变重，难于维护，所以需要computed来解决逻辑。</p>\n<p>###特性</p>\n<ol>\n<li><p>虽然定义的是一个函数,但是它叫做计算属性所以使用时不加()</p>\n</li>\n<li><p>computed属性中依赖的属性只要发生改变，就会重新计算</p>\n</li>\n<li><p>computed属性是响应式的，计算属性重新计算后，会渲染到视图模板</p>\n</li>\n<li><p>computed属性是有 缓存特性的只有第一次使用会调用函数，以后在遇到会使用缓存</p>\n</li>\n<li><p>computed属性不适合做大开销操作，经常和模板进行配合使用</p>\n<p>watch灵活，可以做大开销操作，一般不和模板配合</p>\n</li>\n</ol>\n<p>###语法</p>\n<pre><code class=\"js\">&lt;div&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt;\n&#123;\n    computed:&#123;\n        c()&#123; \n            return this.a +this.b\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"watch监听器\"><a href=\"#watch监听器\" class=\"headerlink\" title=\"watch监听器\"></a>watch监听器</h2><blockquote>\n<p>监听实例化属性的变化，一旦属性发生变化之后立即执行绑定的回调函数，经常用来做ajax调用接口</p>\n</blockquote>\n<ul>\n<li>不要滥用用watch，多用computed</li>\n</ul>\n<p>###语法</p>\n<pre><code class=\"js\">&#123;\n    watch:&#123;\n        &#39;要监听的数据名&#39;:function()&#123; //这里不支持箭头函数\n        &#125;\n    &#125;   \n&#125;\n</code></pre>\n<h2 id=\"vue的生命周期\"><a href=\"#vue的生命周期\" class=\"headerlink\" title=\"vue的生命周期\"></a>vue的生命周期</h2><blockquote>\n<p> vue实例从<strong>创建、初始化数据、挂载、更新、销毁</strong>，这就是一个组件所谓的生命周期。 每一个期间都有一个生命周期钩子函数</p>\n</blockquote>\n<h3 id=\"vue的执行阶段生命周期函数\"><a href=\"#vue的执行阶段生命周期函数\" class=\"headerlink\" title=\"vue的执行阶段生命周期函数\"></a>vue的执行阶段生命周期函数</h3><pre><code class=\"js\">    new Vue()实例化vue对象\n1.beforeCreate() //data和methods中的数据和方法都还没有初始化\n    初始化data和methods\n2.Created() //data和methods都已经初始化好了，如果要操作data中的数据或是调用methods中的方法，最早只能在created中操作\n    检查el，检查是否有template属性,无则等手动绑定vm.$mount\n3.beforeMount() //模板已经在内存中编译好了，但尚未挂载到页面中去，此时，页面还是旧的\n    将内存中编译好的模板，真实的替换到浏览器的页面中区\n4.mounted() //数据和DOM都已被挂载到了视图\n\n\n5.beforeUpdate() //页面中显示的数据还是旧的，此时data中的数据是最新的，页面尚未和最新数据同步\n6.updated() //vue（组件）对象对应的dom中的内部（innerHTML）改变了\n\n7.activated() //keep-alive组件激活时调用\n8.deactivated() //keep-alive组件停用时调用\n\n9.beforeDestroy() //vue（组件）对象销毁之前\n    vm.$destroy() 销毁\n10.destroyed() //vue组件销毁后\n</code></pre>\n<h2 id=\"vue-component\"><a href=\"#vue-component\" class=\"headerlink\" title=\"vue component\"></a>vue component</h2><blockquote>\n<p>每一个独立的功能区域都可以构成一个组件，一个完整的页面往往是有多个组件搭建出来的，组件的优点是复用性</p>\n</blockquote>\n<ul>\n<li><p>data为什么是函数？</p>\n<p>因为只有声明为函数，才能渲染一次调用一次函数，且不会影响不同实例化中的数据。</p>\n</li>\n</ul>\n<h3 id=\"全局component\"><a href=\"#全局component\" class=\"headerlink\" title=\"全局component\"></a>全局component</h3><pre><code class=\"js\">&lt;name-component&gt;&lt;/name-component&gt;\n\nVue.component(&#39;name-component&#39;,&#123;\n    //组件所有配置\n    template:` \n        要渲染的html\n    `,\n    data()&#123; //data是一个函数，在函数返回中定义响应式数据\n        return:&#123;\n            属性\n        &#125;\n    &#125;,\n    methods:&#123;\n        方法\n    &#125;\n&#125;\n&#125;)\n</code></pre>\n<h3 id=\"局部component\"><a href=\"#局部component\" class=\"headerlink\" title=\"局部component\"></a>局部component</h3><pre><code class=\"js\">const Module = &#123;    //vue会识别驼峰，并自动转为-\n    data()&#123;\n        return &#123;\n            属性\n        &#125;\n    &#125;,\n    template:`html`,\n    ..\n&#125;\n\nconst vm = new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;&#125;,\n    components:&#123;\n        Module\n    &#125;\n&#125;)\n</code></pre>\n<h3 id=\"component的嵌套\"><a href=\"#component的嵌套\" class=\"headerlink\" title=\"component的嵌套\"></a>component的嵌套</h3><ol>\n<li>要避免循环嵌套</li>\n<li>组件嵌套不限制组件类型，全局和局部之间可以互相嵌套</li>\n<li>template中只能有一个根元素</li>\n</ol>\n<ul>\n<li><p>全局的嵌套</p>\n<pre><code class=\"js\">&lt;component-name&gt;&lt;component-name&gt;\n    \nVue.component(&#39;component-name&#39;,&#123;\n    template:`\n    &lt;component-name2&gt;&lt;/component-name2&gt;\n    `\n&#125;)\n\n\nVue.component(&#39;component-name2&#39;,&#123;\n            \n&#125;) \n\n\n--默认状态下组件内部的内容会被忽略，比如组件嵌套，组件2不会生效\n&lt;componente1&gt;\n    &lt;componente2&gt;&lt;/component2&gt;\n&lt;/component1&gt;\n</code></pre>\n</li>\n<li><p>全局内嵌套局部</p>\n</li>\n<li><p>局部内嵌套全局</p>\n</li>\n<li><p>局部内嵌套局部</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a>mock数据</h3><ul>\n<li>为了提高前端开发速度，降低对后端的依赖，自己造数据</li>\n</ul>\n<h3 id=\"json-server包\"><a href=\"#json-server包\" class=\"headerlink\" title=\"json-server包\"></a>json-server包</h3><pre><code class=\"js\">1.下载json-server\nnpm install json-server -g\n\n\n2.启动一个json服务器文件\njson-server --port 端口 json文件\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>计算属性可以传参吗？</p>\n<p>不能</p>\n</li>\n<li><p>computed属性和watch的区别</p>\n<p>computed：适合多个数据或对象进行计算处理后返回一个结果，</p>\n<p>watch监听一个data中属性的改变。</p>\n</li>\n<li><p>computed属性和methods的区别</p>\n<pre><code class=\"js\">1.computed有缓存，methods没有缓存，\n2.computed是响应式的，methods并非响应式。\n3.computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 \n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"03-vue\"><a href=\"#03-vue\" class=\"headerlink\" title=\"03-vue\"></a>03-vue</h1><h2 id=\"computed计算属性\"><a href=\"#computed计算属性\" class=\"headerlink\" title=\"computed计算属性\"></a>computed计算属性</h2><blockquote>\n<p>当其依赖的属性值发生变化时，计算属性会重新计算，反之则使用缓存中的属性值</p>\n</blockquote>\n<p>###为什么需要computed</p>\n<p>当模板中的表达式放入太多逻辑时，会让模板变重，难于维护，所以需要computed来解决逻辑。</p>\n<p>###特性</p>\n<ol>\n<li><p>虽然定义的是一个函数,但是它叫做计算属性所以使用时不加()</p>\n</li>\n<li><p>computed属性中依赖的属性只要发生改变，就会重新计算</p>\n</li>\n<li><p>computed属性是响应式的，计算属性重新计算后，会渲染到视图模板</p>\n</li>\n<li><p>computed属性是有 缓存特性的只有第一次使用会调用函数，以后在遇到会使用缓存</p>\n</li>\n<li><p>computed属性不适合做大开销操作，经常和模板进行配合使用</p>\n<p>watch灵活，可以做大开销操作，一般不和模板配合</p>\n</li>\n</ol>\n<p>###语法</p>\n<pre><code class=\"js\">&lt;div&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt;\n&#123;\n    computed:&#123;\n        c()&#123; \n            return this.a +this.b\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"watch监听器\"><a href=\"#watch监听器\" class=\"headerlink\" title=\"watch监听器\"></a>watch监听器</h2><blockquote>\n<p>监听实例化属性的变化，一旦属性发生变化之后立即执行绑定的回调函数，经常用来做ajax调用接口</p>\n</blockquote>\n<ul>\n<li>不要滥用用watch，多用computed</li>\n</ul>\n<p>###语法</p>\n<pre><code class=\"js\">&#123;\n    watch:&#123;\n        &#39;要监听的数据名&#39;:function()&#123; //这里不支持箭头函数\n        &#125;\n    &#125;   \n&#125;\n</code></pre>\n<h2 id=\"vue的生命周期\"><a href=\"#vue的生命周期\" class=\"headerlink\" title=\"vue的生命周期\"></a>vue的生命周期</h2><blockquote>\n<p> vue实例从<strong>创建、初始化数据、挂载、更新、销毁</strong>，这就是一个组件所谓的生命周期。 每一个期间都有一个生命周期钩子函数</p>\n</blockquote>\n<h3 id=\"vue的执行阶段生命周期函数\"><a href=\"#vue的执行阶段生命周期函数\" class=\"headerlink\" title=\"vue的执行阶段生命周期函数\"></a>vue的执行阶段生命周期函数</h3><pre><code class=\"js\">    new Vue()实例化vue对象\n1.beforeCreate() //data和methods中的数据和方法都还没有初始化\n    初始化data和methods\n2.Created() //data和methods都已经初始化好了，如果要操作data中的数据或是调用methods中的方法，最早只能在created中操作\n    检查el，检查是否有template属性,无则等手动绑定vm.$mount\n3.beforeMount() //模板已经在内存中编译好了，但尚未挂载到页面中去，此时，页面还是旧的\n    将内存中编译好的模板，真实的替换到浏览器的页面中区\n4.mounted() //数据和DOM都已被挂载到了视图\n\n\n5.beforeUpdate() //页面中显示的数据还是旧的，此时data中的数据是最新的，页面尚未和最新数据同步\n6.updated() //vue（组件）对象对应的dom中的内部（innerHTML）改变了\n\n7.activated() //keep-alive组件激活时调用\n8.deactivated() //keep-alive组件停用时调用\n\n9.beforeDestroy() //vue（组件）对象销毁之前\n    vm.$destroy() 销毁\n10.destroyed() //vue组件销毁后\n</code></pre>\n<h2 id=\"vue-component\"><a href=\"#vue-component\" class=\"headerlink\" title=\"vue component\"></a>vue component</h2><blockquote>\n<p>每一个独立的功能区域都可以构成一个组件，一个完整的页面往往是有多个组件搭建出来的，组件的优点是复用性</p>\n</blockquote>\n<ul>\n<li><p>data为什么是函数？</p>\n<p>因为只有声明为函数，才能渲染一次调用一次函数，且不会影响不同实例化中的数据。</p>\n</li>\n</ul>\n<h3 id=\"全局component\"><a href=\"#全局component\" class=\"headerlink\" title=\"全局component\"></a>全局component</h3><pre><code class=\"js\">&lt;name-component&gt;&lt;/name-component&gt;\n\nVue.component(&#39;name-component&#39;,&#123;\n    //组件所有配置\n    template:` \n        要渲染的html\n    `,\n    data()&#123; //data是一个函数，在函数返回中定义响应式数据\n        return:&#123;\n            属性\n        &#125;\n    &#125;,\n    methods:&#123;\n        方法\n    &#125;\n&#125;\n&#125;)\n</code></pre>\n<h3 id=\"局部component\"><a href=\"#局部component\" class=\"headerlink\" title=\"局部component\"></a>局部component</h3><pre><code class=\"js\">const Module = &#123;    //vue会识别驼峰，并自动转为-\n    data()&#123;\n        return &#123;\n            属性\n        &#125;\n    &#125;,\n    template:`html`,\n    ..\n&#125;\n\nconst vm = new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;&#125;,\n    components:&#123;\n        Module\n    &#125;\n&#125;)\n</code></pre>\n<h3 id=\"component的嵌套\"><a href=\"#component的嵌套\" class=\"headerlink\" title=\"component的嵌套\"></a>component的嵌套</h3><ol>\n<li>要避免循环嵌套</li>\n<li>组件嵌套不限制组件类型，全局和局部之间可以互相嵌套</li>\n<li>template中只能有一个根元素</li>\n</ol>\n<ul>\n<li><p>全局的嵌套</p>\n<pre><code class=\"js\">&lt;component-name&gt;&lt;component-name&gt;\n    \nVue.component(&#39;component-name&#39;,&#123;\n    template:`\n    &lt;component-name2&gt;&lt;/component-name2&gt;\n    `\n&#125;)\n\n\nVue.component(&#39;component-name2&#39;,&#123;\n            \n&#125;) \n\n\n--默认状态下组件内部的内容会被忽略，比如组件嵌套，组件2不会生效\n&lt;componente1&gt;\n    &lt;componente2&gt;&lt;/component2&gt;\n&lt;/component1&gt;\n</code></pre>\n</li>\n<li><p>全局内嵌套局部</p>\n</li>\n<li><p>局部内嵌套全局</p>\n</li>\n<li><p>局部内嵌套局部</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a>mock数据</h3><ul>\n<li>为了提高前端开发速度，降低对后端的依赖，自己造数据</li>\n</ul>\n<h3 id=\"json-server包\"><a href=\"#json-server包\" class=\"headerlink\" title=\"json-server包\"></a>json-server包</h3><pre><code class=\"js\">1.下载json-server\nnpm install json-server -g\n\n\n2.启动一个json服务器文件\njson-server --port 端口 json文件\n</code></pre>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li><p>计算属性可以传参吗？</p>\n<p>不能</p>\n</li>\n<li><p>computed属性和watch的区别</p>\n<p>computed：适合多个数据或对象进行计算处理后返回一个结果，</p>\n<p>watch监听一个data中属性的改变。</p>\n</li>\n<li><p>computed属性和methods的区别</p>\n<pre><code class=\"js\">1.computed有缓存，methods没有缓存，\n2.computed是响应式的，methods并非响应式。\n3.computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 \n</code></pre>\n</li>\n</ol>\n"},{"title":"vue基础-指令","date":"2020-08-20T13:34:23.000Z","_content":"# 02-vue\n\n## 高频进阶指令\n\n###响应式绑定的类名\n\n+ vue响应式绑定的class不会影响dom元素自身就有的class\n\n```js\n1.绑定多个类名\n<div :class=\"[curclass,fooclass]\"> </div> //这里可以直接放一个数组或者字符串\n\ndata:{\n    strclass:'class1 class2'\n    arrclass:['class1'，'class2']\n    curclass:'abc',\n   \tfooclass:'cla'\n}\n\n\n2.控制渲染类名的显示隐藏\n<div :class=\"{curclass:flag，curclasstow:flag}\"> </div> //这里可以直接放对象\ndata:{\n    arrclass:{curclass:'true'，curclasstow:'true'}\n    curclass:fooclass,\n    flag:true //如果是true就显示类名，false不显示\n}\n```\n\n### 响应式控制元素的内联样式\n\n+ 在:style中，所有属性名必须是驼峰形式，不能使用-\n\n```js\n1.对象语法(推荐语法)\n<div :style=\"{color:curColor}\"> </div>\ndata:{\n    curColor:'red'\n}\n\n2.字符串拼接语法\n<div :style=\"`backgroundColor:rgb(${r},${g},${b})`> </div>\ndata:{\n    r:100,\n    g:200,\n    b:100\n}\n```\n\n\n\n## 双向绑定directive\n\n> 当视图或者数据变化时，它们的数据会互相同步\n>\n> 为表单元素提供数据的双向绑定\n\n+ 语法\n\n  1. 单个复选框绑定的数据类型是  Boolean\n  2. 多个复选框绑定的数据类型是  同一个响应式数据数组，选中后会添加到数组中，如果这个数据是字符串的形式，那么只有true和false，全选和全不选。\n  3. 多个单选框绑定的数据类型是字符串，选谁就是谁\n\n  ```html\n  <input type=\"text\" v-model=\"data中响应式属性\" />\n  \n  将字符串装换为数字：v-model.number\n  鼠标离开后改变提升性能：v-model.lazy\n  自动删除首尾空白去掉：v-model.trim\n  ```\n\n\n\n## 自定义directive\n\n> 当内置的指令不满足我们的需求时，可是使用自定义directive\n\n+ 语法\n\n  1. 定义指令的位置要定义在实例化之前\n  2. 定义指令名称不需要加v-，使用时添加.\n  3. 全局的自定义指令可以在任何vue实例化对象中使用\n\n  + 全局自定义指令\n\n    ```js\n  Vue.directive('指令名称',{\n        inserted(el){\n           \n        }\n    })\n    ```\n  \n  + 局部自定义指令\n\n    ```js\n  new Vue({\n        el:\"\",\n        data:{\n            \n        },\n        directives:{\n            指令名称:{\n                    inserted(el){\n    \t\t\t\t\n                }\n            }\n        }  \n    })\n    ```\n  \n    \n\n## filter\n\n> fiter作用是把原数据经过一系列处理后返回\n\n###语法\n\n1. filter应该是一个纯函数，不应该有副作用，不应该去改变其它域的东西\n\n2. 保证每一个filter都应该只完成一个功能\n\n3. 在vue3.0中，已将过滤器移除\n\n   \n\n+ 全局filter\n\n  ```js\n  {{meages|filter名称}}\n  Vue.filter('名称',function(value){\n      value表示传入的数据\n      return 处理过的数据 //如果不return就会什么都不显示\n  })\n  ```\n\n+ 局部filter\n\n  ```js\n  new Vue({\n      el:\"\",\n      data:{\n      },\n      filters:{\n          名称:function(val){\n              return 处理过的数据\n          }\n      }\n  })\n  ```\n\n### 传参\n\n```js\n{{meages|过滤器名称('自定义参数')}}\nVue.filter('名称',function(value,参1){\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n})\n```\n\n### 串联使用\n\n```js\n{{meages|名称1|名称2}} // 后一个filter的数据来自上一个filter处理过的数据\nnew Vue({\n    el:\"\",\n    data:{\n    },\n    filters:{\n        名称:function(val){\n            return 处理过的数据\n        },\n        名称2:function(val){\n            return 处理过的数据\n        }\n    }\n})\n```\n\n\n\n## 低频进阶指令\n\n1. 当网络不佳时可能会出现{{message}} ，这种加载不出来的情况，使用__v-cloak__将其隐藏，然后加载完毕后在显示\n\n   ```js\n   [v-cloak]{\n    \tdisplay:none;   \n   }\n   \n   <div v-cloak> {{message}} </div>\n   ```\n\n2. 添加了v-once会把响应式数据转为静态数据\n\n   ```js\n   <div>v-once{{响应式数据}}</div>\n   ```\n\n\n\n\n\n## dayjs\n\n> 用来处理时间日期的插件\n\n## ？ \n\n1. 如果是互相影响的话，那么这个不就是响应式数据的特性吗？\n   + 响应式数据的特性是单向的：响应式数据变化时，视图立即变化，而视图中的数据如果不是响应式的那么就不会影响到响应式数据，所有就有了v-model，可实现双向绑定\n2. 单选和复选不使用checked，怎么在加载页面时默认是选中的？直接在响应式数据中写死吗？点击单选和复选时v-model获取的是value还是id?\n   + 把input的value直接写在响应式数据中，v-model获取的是value","source":"_posts/笔记/ocean/12-Vue总结/02-进阶directive-双向绑定/02-笔记.md","raw":"---\ntitle: vue基础-指令\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n# 02-vue\n\n## 高频进阶指令\n\n###响应式绑定的类名\n\n+ vue响应式绑定的class不会影响dom元素自身就有的class\n\n```js\n1.绑定多个类名\n<div :class=\"[curclass,fooclass]\"> </div> //这里可以直接放一个数组或者字符串\n\ndata:{\n    strclass:'class1 class2'\n    arrclass:['class1'，'class2']\n    curclass:'abc',\n   \tfooclass:'cla'\n}\n\n\n2.控制渲染类名的显示隐藏\n<div :class=\"{curclass:flag，curclasstow:flag}\"> </div> //这里可以直接放对象\ndata:{\n    arrclass:{curclass:'true'，curclasstow:'true'}\n    curclass:fooclass,\n    flag:true //如果是true就显示类名，false不显示\n}\n```\n\n### 响应式控制元素的内联样式\n\n+ 在:style中，所有属性名必须是驼峰形式，不能使用-\n\n```js\n1.对象语法(推荐语法)\n<div :style=\"{color:curColor}\"> </div>\ndata:{\n    curColor:'red'\n}\n\n2.字符串拼接语法\n<div :style=\"`backgroundColor:rgb(${r},${g},${b})`> </div>\ndata:{\n    r:100,\n    g:200,\n    b:100\n}\n```\n\n\n\n## 双向绑定directive\n\n> 当视图或者数据变化时，它们的数据会互相同步\n>\n> 为表单元素提供数据的双向绑定\n\n+ 语法\n\n  1. 单个复选框绑定的数据类型是  Boolean\n  2. 多个复选框绑定的数据类型是  同一个响应式数据数组，选中后会添加到数组中，如果这个数据是字符串的形式，那么只有true和false，全选和全不选。\n  3. 多个单选框绑定的数据类型是字符串，选谁就是谁\n\n  ```html\n  <input type=\"text\" v-model=\"data中响应式属性\" />\n  \n  将字符串装换为数字：v-model.number\n  鼠标离开后改变提升性能：v-model.lazy\n  自动删除首尾空白去掉：v-model.trim\n  ```\n\n\n\n## 自定义directive\n\n> 当内置的指令不满足我们的需求时，可是使用自定义directive\n\n+ 语法\n\n  1. 定义指令的位置要定义在实例化之前\n  2. 定义指令名称不需要加v-，使用时添加.\n  3. 全局的自定义指令可以在任何vue实例化对象中使用\n\n  + 全局自定义指令\n\n    ```js\n  Vue.directive('指令名称',{\n        inserted(el){\n           \n        }\n    })\n    ```\n  \n  + 局部自定义指令\n\n    ```js\n  new Vue({\n        el:\"\",\n        data:{\n            \n        },\n        directives:{\n            指令名称:{\n                    inserted(el){\n    \t\t\t\t\n                }\n            }\n        }  \n    })\n    ```\n  \n    \n\n## filter\n\n> fiter作用是把原数据经过一系列处理后返回\n\n###语法\n\n1. filter应该是一个纯函数，不应该有副作用，不应该去改变其它域的东西\n\n2. 保证每一个filter都应该只完成一个功能\n\n3. 在vue3.0中，已将过滤器移除\n\n   \n\n+ 全局filter\n\n  ```js\n  {{meages|filter名称}}\n  Vue.filter('名称',function(value){\n      value表示传入的数据\n      return 处理过的数据 //如果不return就会什么都不显示\n  })\n  ```\n\n+ 局部filter\n\n  ```js\n  new Vue({\n      el:\"\",\n      data:{\n      },\n      filters:{\n          名称:function(val){\n              return 处理过的数据\n          }\n      }\n  })\n  ```\n\n### 传参\n\n```js\n{{meages|过滤器名称('自定义参数')}}\nVue.filter('名称',function(value,参1){\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n})\n```\n\n### 串联使用\n\n```js\n{{meages|名称1|名称2}} // 后一个filter的数据来自上一个filter处理过的数据\nnew Vue({\n    el:\"\",\n    data:{\n    },\n    filters:{\n        名称:function(val){\n            return 处理过的数据\n        },\n        名称2:function(val){\n            return 处理过的数据\n        }\n    }\n})\n```\n\n\n\n## 低频进阶指令\n\n1. 当网络不佳时可能会出现{{message}} ，这种加载不出来的情况，使用__v-cloak__将其隐藏，然后加载完毕后在显示\n\n   ```js\n   [v-cloak]{\n    \tdisplay:none;   \n   }\n   \n   <div v-cloak> {{message}} </div>\n   ```\n\n2. 添加了v-once会把响应式数据转为静态数据\n\n   ```js\n   <div>v-once{{响应式数据}}</div>\n   ```\n\n\n\n\n\n## dayjs\n\n> 用来处理时间日期的插件\n\n## ？ \n\n1. 如果是互相影响的话，那么这个不就是响应式数据的特性吗？\n   + 响应式数据的特性是单向的：响应式数据变化时，视图立即变化，而视图中的数据如果不是响应式的那么就不会影响到响应式数据，所有就有了v-model，可实现双向绑定\n2. 单选和复选不使用checked，怎么在加载页面时默认是选中的？直接在响应式数据中写死吗？点击单选和复选时v-model获取的是value还是id?\n   + 把input的value直接写在响应式数据中，v-model获取的是value","slug":"笔记/ocean/12-Vue总结/02-进阶directive-双向绑定/02-笔记","published":1,"updated":"2023-03-01T07:27:52.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe900asawaf0ihs1tnq","content":"<h1 id=\"02-vue\"><a href=\"#02-vue\" class=\"headerlink\" title=\"02-vue\"></a>02-vue</h1><h2 id=\"高频进阶指令\"><a href=\"#高频进阶指令\" class=\"headerlink\" title=\"高频进阶指令\"></a>高频进阶指令</h2><p>###响应式绑定的类名</p>\n<ul>\n<li>vue响应式绑定的class不会影响dom元素自身就有的class</li>\n</ul>\n<pre><code class=\"js\">1.绑定多个类名\n&lt;div :class=&quot;[curclass,fooclass]&quot;&gt; &lt;/div&gt; //这里可以直接放一个数组或者字符串\n\ndata:&#123;\n    strclass:&#39;class1 class2&#39;\n    arrclass:[&#39;class1&#39;，&#39;class2&#39;]\n    curclass:&#39;abc&#39;,\n       fooclass:&#39;cla&#39;\n&#125;\n\n\n2.控制渲染类名的显示隐藏\n&lt;div :class=&quot;&#123;curclass:flag，curclasstow:flag&#125;&quot;&gt; &lt;/div&gt; //这里可以直接放对象\ndata:&#123;\n    arrclass:&#123;curclass:&#39;true&#39;，curclasstow:&#39;true&#39;&#125;\n    curclass:fooclass,\n    flag:true //如果是true就显示类名，false不显示\n&#125;\n</code></pre>\n<h3 id=\"响应式控制元素的内联样式\"><a href=\"#响应式控制元素的内联样式\" class=\"headerlink\" title=\"响应式控制元素的内联样式\"></a>响应式控制元素的内联样式</h3><ul>\n<li>在:style中，所有属性名必须是驼峰形式，不能使用-</li>\n</ul>\n<pre><code class=\"js\">1.对象语法(推荐语法)\n&lt;div :style=&quot;&#123;color:curColor&#125;&quot;&gt; &lt;/div&gt;\ndata:&#123;\n    curColor:&#39;red&#39;\n&#125;\n\n2.字符串拼接语法\n&lt;div :style=&quot;`backgroundColor:rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`&gt; &lt;/div&gt;\ndata:&#123;\n    r:100,\n    g:200,\n    b:100\n&#125;\n</code></pre>\n<h2 id=\"双向绑定directive\"><a href=\"#双向绑定directive\" class=\"headerlink\" title=\"双向绑定directive\"></a>双向绑定directive</h2><blockquote>\n<p>当视图或者数据变化时，它们的数据会互相同步</p>\n<p>为表单元素提供数据的双向绑定</p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<ol>\n<li>单个复选框绑定的数据类型是  Boolean</li>\n<li>多个复选框绑定的数据类型是  同一个响应式数据数组，选中后会添加到数组中，如果这个数据是字符串的形式，那么只有true和false，全选和全不选。</li>\n<li>多个单选框绑定的数据类型是字符串，选谁就是谁</li>\n</ol>\n<pre><code class=\"html\">&lt;input type=&quot;text&quot; v-model=&quot;data中响应式属性&quot; /&gt;\n\n将字符串装换为数字：v-model.number\n鼠标离开后改变提升性能：v-model.lazy\n自动删除首尾空白去掉：v-model.trim\n</code></pre>\n</li>\n</ul>\n<h2 id=\"自定义directive\"><a href=\"#自定义directive\" class=\"headerlink\" title=\"自定义directive\"></a>自定义directive</h2><blockquote>\n<p>当内置的指令不满足我们的需求时，可是使用自定义directive</p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<ol>\n<li>定义指令的位置要定义在实例化之前</li>\n<li>定义指令名称不需要加v-，使用时添加.</li>\n<li>全局的自定义指令可以在任何vue实例化对象中使用</li>\n</ol>\n<ul>\n<li><p>全局自定义指令</p>\n<pre><code class=\"js\">Vue.directive(&#39;指令名称&#39;,&#123;\n    inserted(el)&#123;\n       \n    &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>局部自定义指令</p>\n<pre><code class=\"js\">new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n        \n    &#125;,\n    directives:&#123;\n        指令名称:&#123;\n                inserted(el)&#123;\n                \n            &#125;\n        &#125;\n    &#125;  \n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><blockquote>\n<p>fiter作用是把原数据经过一系列处理后返回</p>\n</blockquote>\n<p>###语法</p>\n<ol>\n<li><p>filter应该是一个纯函数，不应该有副作用，不应该去改变其它域的东西</p>\n</li>\n<li><p>保证每一个filter都应该只完成一个功能</p>\n</li>\n<li><p>在vue3.0中，已将过滤器移除</p>\n</li>\n</ol>\n<ul>\n<li><p>全局filter</p>\n<pre><code class=\"js\">&#123;&#123;meages|filter名称&#125;&#125;\nVue.filter(&#39;名称&#39;,function(value)&#123;\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n&#125;)\n</code></pre>\n</li>\n<li><p>局部filter</p>\n<pre><code class=\"js\">new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n    &#125;,\n    filters:&#123;\n        名称:function(val)&#123;\n            return 处理过的数据\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"传参\"><a href=\"#传参\" class=\"headerlink\" title=\"传参\"></a>传参</h3><pre><code class=\"js\">&#123;&#123;meages|过滤器名称('自定义参数')&#125;&#125;\nVue.filter(&#39;名称&#39;,function(value,参1)&#123;\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n&#125;)\n</code></pre>\n<h3 id=\"串联使用\"><a href=\"#串联使用\" class=\"headerlink\" title=\"串联使用\"></a>串联使用</h3><pre><code class=\"js\">&#123;&#123;meages|名称1|名称2&#125;&#125; // 后一个filter的数据来自上一个filter处理过的数据\nnew Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n    &#125;,\n    filters:&#123;\n        名称:function(val)&#123;\n            return 处理过的数据\n        &#125;,\n        名称2:function(val)&#123;\n            return 处理过的数据\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"低频进阶指令\"><a href=\"#低频进阶指令\" class=\"headerlink\" title=\"低频进阶指令\"></a>低频进阶指令</h2><ol>\n<li><p>当网络不佳时可能会出现 ，这种加载不出来的情况，使用__v-cloak__将其隐藏，然后加载完毕后在显示</p>\n<pre><code class=\"js\">[v-cloak]&#123;\n     display:none;   \n&#125;\n\n&lt;div v-cloak&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;\n</code></pre>\n</li>\n<li><p>添加了v-once会把响应式数据转为静态数据</p>\n<pre><code class=\"js\">&lt;div&gt;v-once&#123;&#123;响应式数据&#125;&#125;&lt;/div&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"dayjs\"><a href=\"#dayjs\" class=\"headerlink\" title=\"dayjs\"></a>dayjs</h2><blockquote>\n<p>用来处理时间日期的插件</p>\n</blockquote>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li>如果是互相影响的话，那么这个不就是响应式数据的特性吗？<ul>\n<li>响应式数据的特性是单向的：响应式数据变化时，视图立即变化，而视图中的数据如果不是响应式的那么就不会影响到响应式数据，所有就有了v-model，可实现双向绑定</li>\n</ul>\n</li>\n<li>单选和复选不使用checked，怎么在加载页面时默认是选中的？直接在响应式数据中写死吗？点击单选和复选时v-model获取的是value还是id?<ul>\n<li>把input的value直接写在响应式数据中，v-model获取的是value</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"02-vue\"><a href=\"#02-vue\" class=\"headerlink\" title=\"02-vue\"></a>02-vue</h1><h2 id=\"高频进阶指令\"><a href=\"#高频进阶指令\" class=\"headerlink\" title=\"高频进阶指令\"></a>高频进阶指令</h2><p>###响应式绑定的类名</p>\n<ul>\n<li>vue响应式绑定的class不会影响dom元素自身就有的class</li>\n</ul>\n<pre><code class=\"js\">1.绑定多个类名\n&lt;div :class=&quot;[curclass,fooclass]&quot;&gt; &lt;/div&gt; //这里可以直接放一个数组或者字符串\n\ndata:&#123;\n    strclass:&#39;class1 class2&#39;\n    arrclass:[&#39;class1&#39;，&#39;class2&#39;]\n    curclass:&#39;abc&#39;,\n       fooclass:&#39;cla&#39;\n&#125;\n\n\n2.控制渲染类名的显示隐藏\n&lt;div :class=&quot;&#123;curclass:flag，curclasstow:flag&#125;&quot;&gt; &lt;/div&gt; //这里可以直接放对象\ndata:&#123;\n    arrclass:&#123;curclass:&#39;true&#39;，curclasstow:&#39;true&#39;&#125;\n    curclass:fooclass,\n    flag:true //如果是true就显示类名，false不显示\n&#125;\n</code></pre>\n<h3 id=\"响应式控制元素的内联样式\"><a href=\"#响应式控制元素的内联样式\" class=\"headerlink\" title=\"响应式控制元素的内联样式\"></a>响应式控制元素的内联样式</h3><ul>\n<li>在:style中，所有属性名必须是驼峰形式，不能使用-</li>\n</ul>\n<pre><code class=\"js\">1.对象语法(推荐语法)\n&lt;div :style=&quot;&#123;color:curColor&#125;&quot;&gt; &lt;/div&gt;\ndata:&#123;\n    curColor:&#39;red&#39;\n&#125;\n\n2.字符串拼接语法\n&lt;div :style=&quot;`backgroundColor:rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`&gt; &lt;/div&gt;\ndata:&#123;\n    r:100,\n    g:200,\n    b:100\n&#125;\n</code></pre>\n<h2 id=\"双向绑定directive\"><a href=\"#双向绑定directive\" class=\"headerlink\" title=\"双向绑定directive\"></a>双向绑定directive</h2><blockquote>\n<p>当视图或者数据变化时，它们的数据会互相同步</p>\n<p>为表单元素提供数据的双向绑定</p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<ol>\n<li>单个复选框绑定的数据类型是  Boolean</li>\n<li>多个复选框绑定的数据类型是  同一个响应式数据数组，选中后会添加到数组中，如果这个数据是字符串的形式，那么只有true和false，全选和全不选。</li>\n<li>多个单选框绑定的数据类型是字符串，选谁就是谁</li>\n</ol>\n<pre><code class=\"html\">&lt;input type=&quot;text&quot; v-model=&quot;data中响应式属性&quot; /&gt;\n\n将字符串装换为数字：v-model.number\n鼠标离开后改变提升性能：v-model.lazy\n自动删除首尾空白去掉：v-model.trim\n</code></pre>\n</li>\n</ul>\n<h2 id=\"自定义directive\"><a href=\"#自定义directive\" class=\"headerlink\" title=\"自定义directive\"></a>自定义directive</h2><blockquote>\n<p>当内置的指令不满足我们的需求时，可是使用自定义directive</p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<ol>\n<li>定义指令的位置要定义在实例化之前</li>\n<li>定义指令名称不需要加v-，使用时添加.</li>\n<li>全局的自定义指令可以在任何vue实例化对象中使用</li>\n</ol>\n<ul>\n<li><p>全局自定义指令</p>\n<pre><code class=\"js\">Vue.directive(&#39;指令名称&#39;,&#123;\n    inserted(el)&#123;\n       \n    &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>局部自定义指令</p>\n<pre><code class=\"js\">new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n        \n    &#125;,\n    directives:&#123;\n        指令名称:&#123;\n                inserted(el)&#123;\n                \n            &#125;\n        &#125;\n    &#125;  \n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><blockquote>\n<p>fiter作用是把原数据经过一系列处理后返回</p>\n</blockquote>\n<p>###语法</p>\n<ol>\n<li><p>filter应该是一个纯函数，不应该有副作用，不应该去改变其它域的东西</p>\n</li>\n<li><p>保证每一个filter都应该只完成一个功能</p>\n</li>\n<li><p>在vue3.0中，已将过滤器移除</p>\n</li>\n</ol>\n<ul>\n<li><p>全局filter</p>\n<pre><code class=\"js\">&#123;&#123;meages|filter名称&#125;&#125;\nVue.filter(&#39;名称&#39;,function(value)&#123;\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n&#125;)\n</code></pre>\n</li>\n<li><p>局部filter</p>\n<pre><code class=\"js\">new Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n    &#125;,\n    filters:&#123;\n        名称:function(val)&#123;\n            return 处理过的数据\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"传参\"><a href=\"#传参\" class=\"headerlink\" title=\"传参\"></a>传参</h3><pre><code class=\"js\">&#123;&#123;meages|过滤器名称('自定义参数')&#125;&#125;\nVue.filter(&#39;名称&#39;,function(value,参1)&#123;\n    value表示传入的数据\n    return 处理过的数据 //如果不return就会什么都不显示\n&#125;)\n</code></pre>\n<h3 id=\"串联使用\"><a href=\"#串联使用\" class=\"headerlink\" title=\"串联使用\"></a>串联使用</h3><pre><code class=\"js\">&#123;&#123;meages|名称1|名称2&#125;&#125; // 后一个filter的数据来自上一个filter处理过的数据\nnew Vue(&#123;\n    el:&quot;&quot;,\n    data:&#123;\n    &#125;,\n    filters:&#123;\n        名称:function(val)&#123;\n            return 处理过的数据\n        &#125;,\n        名称2:function(val)&#123;\n            return 处理过的数据\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"低频进阶指令\"><a href=\"#低频进阶指令\" class=\"headerlink\" title=\"低频进阶指令\"></a>低频进阶指令</h2><ol>\n<li><p>当网络不佳时可能会出现 ，这种加载不出来的情况，使用__v-cloak__将其隐藏，然后加载完毕后在显示</p>\n<pre><code class=\"js\">[v-cloak]&#123;\n     display:none;   \n&#125;\n\n&lt;div v-cloak&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;\n</code></pre>\n</li>\n<li><p>添加了v-once会把响应式数据转为静态数据</p>\n<pre><code class=\"js\">&lt;div&gt;v-once&#123;&#123;响应式数据&#125;&#125;&lt;/div&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"dayjs\"><a href=\"#dayjs\" class=\"headerlink\" title=\"dayjs\"></a>dayjs</h2><blockquote>\n<p>用来处理时间日期的插件</p>\n</blockquote>\n<h2 id=\"？\"><a href=\"#？\" class=\"headerlink\" title=\"？\"></a>？</h2><ol>\n<li>如果是互相影响的话，那么这个不就是响应式数据的特性吗？<ul>\n<li>响应式数据的特性是单向的：响应式数据变化时，视图立即变化，而视图中的数据如果不是响应式的那么就不会影响到响应式数据，所有就有了v-model，可实现双向绑定</li>\n</ul>\n</li>\n<li>单选和复选不使用checked，怎么在加载页面时默认是选中的？直接在响应式数据中写死吗？点击单选和复选时v-model获取的是value还是id?<ul>\n<li>把input的value直接写在响应式数据中，v-model获取的是value</li>\n</ul>\n</li>\n</ol>\n"},{"title":"vue基础-vuex","date":"2020-08-20T13:34:23.000Z","_content":"## 概念\n\n> Vuex 是vue官方为 Vue 应用程序开发的一种状态管理模式，采用集中式存储管理应用的所有组件的状态。\n\n+ **特点**\n  \n  1. 响应式。\n  \n+ **作用**\n\n  解决了组件之间同一状态的共享问题。\n\n## 使用\n\n+ **安装**\n\n  ```js\n  1.npm install vuex \n  2.创建一个store文件夹下index.js\n  3.导入 import Vuex from 'vuex'(需要先导入vue)\n  4.挂载到vue中.\n  \tVue.use(Vuex)\n  5.创建实例\n   const store = new Vuex.Store({\n  \tstate:{ //组件中的data\n          msg:'共享数据'\n      }\n   })\n   6.导出\n    export default store\n  \n  7.引入到main入口文件\n   new Vue({\n       store\n   })\n  ```\n\n+ **获取**\n\n  ```js\n  1.直接使用\n  在代码中：this.$store.state.name\n  在视图中：$store.state.name\n  \n  \n  2.映射使用\n   获取的数据不能修改。\n   import { mapState } from 'vuex'\n   computed:{\n       ...mapState(['name']) //传入的是一个数组。\n   }\n  \n   视图使用：{{name}}\n   代码使用：this.name\n  ```\n\n+ **修改**\n\n  ```js\n  1.\n  mutations :{\n  \t函数名(value，x){\n          value  当前state\n          x 额外传入的参数\n      }\n  }\n  \n  \n  调用：\n  this.$store.commit('name','修改的新值')\n  this.$store.commit('name:newName','修改的新值')\n  \n  2.映射修改\n  import { mapMutations } from 'vuex'\n  \n  methods:{\n      this.name('数据')\n      ...mapMutations(['name'])\n  }\n  ```\n\n  ","source":"_posts/笔记/ocean/12-Vue总结/06-vuex/01-note.md","raw":"---\ntitle: vue基础-vuex\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n## 概念\n\n> Vuex 是vue官方为 Vue 应用程序开发的一种状态管理模式，采用集中式存储管理应用的所有组件的状态。\n\n+ **特点**\n  \n  1. 响应式。\n  \n+ **作用**\n\n  解决了组件之间同一状态的共享问题。\n\n## 使用\n\n+ **安装**\n\n  ```js\n  1.npm install vuex \n  2.创建一个store文件夹下index.js\n  3.导入 import Vuex from 'vuex'(需要先导入vue)\n  4.挂载到vue中.\n  \tVue.use(Vuex)\n  5.创建实例\n   const store = new Vuex.Store({\n  \tstate:{ //组件中的data\n          msg:'共享数据'\n      }\n   })\n   6.导出\n    export default store\n  \n  7.引入到main入口文件\n   new Vue({\n       store\n   })\n  ```\n\n+ **获取**\n\n  ```js\n  1.直接使用\n  在代码中：this.$store.state.name\n  在视图中：$store.state.name\n  \n  \n  2.映射使用\n   获取的数据不能修改。\n   import { mapState } from 'vuex'\n   computed:{\n       ...mapState(['name']) //传入的是一个数组。\n   }\n  \n   视图使用：{{name}}\n   代码使用：this.name\n  ```\n\n+ **修改**\n\n  ```js\n  1.\n  mutations :{\n  \t函数名(value，x){\n          value  当前state\n          x 额外传入的参数\n      }\n  }\n  \n  \n  调用：\n  this.$store.commit('name','修改的新值')\n  this.$store.commit('name:newName','修改的新值')\n  \n  2.映射修改\n  import { mapMutations } from 'vuex'\n  \n  methods:{\n      this.name('数据')\n      ...mapMutations(['name'])\n  }\n  ```\n\n  ","slug":"笔记/ocean/12-Vue总结/06-vuex/01-note","published":1,"updated":"2023-03-01T07:28:42.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qe900axawaf9jwtglow","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>Vuex 是vue官方为 Vue 应用程序开发的一种状态管理模式，采用集中式存储管理应用的所有组件的状态。</p>\n</blockquote>\n<ul>\n<li><p><strong>特点</strong></p>\n<ol>\n<li>响应式。</li>\n</ol>\n</li>\n<li><p><strong>作用</strong></p>\n<p>解决了组件之间同一状态的共享问题。</p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li><p><strong>安装</strong></p>\n<pre><code class=\"js\">1.npm install vuex \n2.创建一个store文件夹下index.js\n3.导入 import Vuex from &#39;vuex&#39;(需要先导入vue)\n4.挂载到vue中.\n    Vue.use(Vuex)\n5.创建实例\n const store = new Vuex.Store(&#123;\n    state:&#123; //组件中的data\n        msg:&#39;共享数据&#39;\n    &#125;\n &#125;)\n 6.导出\n  export default store\n\n7.引入到main入口文件\n new Vue(&#123;\n     store\n &#125;)\n</code></pre>\n</li>\n<li><p><strong>获取</strong></p>\n<pre><code class=\"js\">1.直接使用\n在代码中：this.$store.state.name\n在视图中：$store.state.name\n\n\n2.映射使用\n 获取的数据不能修改。\n import &#123; mapState &#125; from &#39;vuex&#39;\n computed:&#123;\n     ...mapState([&#39;name&#39;]) //传入的是一个数组。\n &#125;\n\n 视图使用：&#123;&#123;name&#125;&#125;\n 代码使用：this.name\n</code></pre>\n</li>\n<li><p><strong>修改</strong></p>\n<pre><code class=\"js\">1.\nmutations :&#123;\n    函数名(value，x)&#123;\n        value  当前state\n        x 额外传入的参数\n    &#125;\n&#125;\n\n\n调用：\nthis.$store.commit(&#39;name&#39;,&#39;修改的新值&#39;)\nthis.$store.commit(&#39;name:newName&#39;,&#39;修改的新值&#39;)\n\n2.映射修改\nimport &#123; mapMutations &#125; from &#39;vuex&#39;\n\nmethods:&#123;\n    this.name(&#39;数据&#39;)\n    ...mapMutations([&#39;name&#39;])\n&#125;\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>Vuex 是vue官方为 Vue 应用程序开发的一种状态管理模式，采用集中式存储管理应用的所有组件的状态。</p>\n</blockquote>\n<ul>\n<li><p><strong>特点</strong></p>\n<ol>\n<li>响应式。</li>\n</ol>\n</li>\n<li><p><strong>作用</strong></p>\n<p>解决了组件之间同一状态的共享问题。</p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li><p><strong>安装</strong></p>\n<pre><code class=\"js\">1.npm install vuex \n2.创建一个store文件夹下index.js\n3.导入 import Vuex from &#39;vuex&#39;(需要先导入vue)\n4.挂载到vue中.\n    Vue.use(Vuex)\n5.创建实例\n const store = new Vuex.Store(&#123;\n    state:&#123; //组件中的data\n        msg:&#39;共享数据&#39;\n    &#125;\n &#125;)\n 6.导出\n  export default store\n\n7.引入到main入口文件\n new Vue(&#123;\n     store\n &#125;)\n</code></pre>\n</li>\n<li><p><strong>获取</strong></p>\n<pre><code class=\"js\">1.直接使用\n在代码中：this.$store.state.name\n在视图中：$store.state.name\n\n\n2.映射使用\n 获取的数据不能修改。\n import &#123; mapState &#125; from &#39;vuex&#39;\n computed:&#123;\n     ...mapState([&#39;name&#39;]) //传入的是一个数组。\n &#125;\n\n 视图使用：&#123;&#123;name&#125;&#125;\n 代码使用：this.name\n</code></pre>\n</li>\n<li><p><strong>修改</strong></p>\n<pre><code class=\"js\">1.\nmutations :&#123;\n    函数名(value，x)&#123;\n        value  当前state\n        x 额外传入的参数\n    &#125;\n&#125;\n\n\n调用：\nthis.$store.commit(&#39;name&#39;,&#39;修改的新值&#39;)\nthis.$store.commit(&#39;name:newName&#39;,&#39;修改的新值&#39;)\n\n2.映射修改\nimport &#123; mapMutations &#125; from &#39;vuex&#39;\n\nmethods:&#123;\n    this.name(&#39;数据&#39;)\n    ...mapMutations([&#39;name&#39;])\n&#125;\n</code></pre>\n</li>\n</ul>\n"},{"title":"vue基础-组件通信","date":"2020-08-20T13:34:23.000Z","_content":"# 04-vue\n\n\n\n## father Son Component通信\n\n\n\n### father pass son\n\n1. 父组件中的模板使用子组件的地方，在子组件身上添加自定义属性，然后绑定要传递的数据\n2. 子组件在props中接受父组件的值，组件名使用驼峰\n3. 在模板中使用传递过来的数据,，不加this\n\n#### static grammar\n\n+ 不加冒号，只能传字符串\n\n```js\nVue.component('father-component',{\n    template:`<son-component title=\"send value\"></son-component>`,\n})\n\n\nVue.component('son-component',{\n    props:{\n        title:{\n\t    type:String,\n            required: true //true为必须传\n        }\n    },//如果son本身有属性名呢，会报错\n    template:`<div>{{title}}</div>\">`\n})\n```\n\n#### dynamic grammar\n\n1. 传递一般 dynamicData 时，需要加冒号\n2.  绑定字符串会被当成属性识别\n3. number,Array,Object,function\n\n```js\nVue.component('father-component',{\n    template:`<son-component :age=18></son-component>`,\n})\n\n\nVue.component('son-component',{\n    props:{\n        age:{\n\t\t \ttype:Number\n        }\n    },//如果son本身有属性名呢\n    template:`<div>{{age}}</div>\">`\n})\n```\n\n\n\n### son pass father\n\n>  在子组件中调取父组件中的方法，并且传入要传递的数据\n\n1. 在父组件使用子组件的身上绑定一个自定义事件，触发时调用父组件中的函数\n\n2. 在子组件需要传值的地方，使用$emit()调用父组件的自定义函数，并传入要传的数据\n\n   \n\n#### grammar\n\n```js\nVue.component('father-component',{\n    template:`<div :style={color:fcolor}>\n\t\t\t\t\t<son-component @自定义事件='changeColor'></son-component>\n\t\t\t\t</div>`,//不需要传递实参吗\n    data(){\n        return{\n             fcolor:'red'\n            }\n\t},\n    methods:{\n        changeColor(color){\n            this.fcolor = color\n        }\n    }\n})\n\n\nVue.component('son-component',{\n    data(){\n        return{\n            color:'blue'\n        }\n    },\n    methods:{\n        changeFatherColor(){\n            this.$emit('要触发的自定义事件',要传递的数据)\n        }\n    }\n})\n```\n\n##component抽离复用\n\n1. component抽离后，提高了component中的模板复用性\n2. 抽离组件后，只负责视图模板渲染，可以拥有自己的数据，可随意修改数据\n\n\n\n## **总结通信方式**\n\n1. Props + $emit()\n\n3. $parent + $children\n\n   ```js\n   在子组件中通过 this.$parent.message 访问到父组件的至\n   在父组件中使用 this.$children[0].number = 50; 访问第0项，因为一个父组件可能会有多个子组件\n   ```\n\n4. provide + inject\n\n   ```js\n   fatherComponent\n   {\n   \tprovide:{\n   +\t\tmessage:\"123\"\n   \t}\t\n   }\n   \n   sonComponent\n   inject:['message']\n   ```\n\n5. $attrs + $listeners\n\n   ```js\n   父传子传孙子\n   father\n   <son :name>\n   \n   changeName(){\n       this.name = 'df'\n   }\n   \n   son\n   <button @click=\"$listeners.changeName\">按钮</button> //触发父元素的函数\n   <sonS v-bind=\"$attrs\" > //$attrs属性中包括了father传过来的值\n   \n   sonS\n   <div>{{$attrs.name}}</div>\n   ```\n\n6. ref\n\n   ```js\n   father\n   <Son ref='child' />\n   <button @click=\"changeName\"></button>\n   \n   methods:{\n       changeName(){\n           this.$refs.child.属性名 //获取子组件属性\n           this.$refs.child.方法名() //调用子组件中的方法\n       }\n   }\n   \n   \n   son\n   data{\n   \treturn{\n           属性名\n       }\n   }\n   方法名(){\n   \tthis.age = 50\n   }\n   ```\n\n   \n\n\n\n\n\n## vue-单页应用开发\n\n> 对url进行改变和监听location.hash，让某个dom节点显示对应的视图\n\n### 原生 router\n\n1. 对url进行改变\n2. 使用hashchange事件监听hash\n3. 准备一个存放内容的dom节点\n4. 描述url标识的内容对应关系\n5. 将当前hash对应的内容渲染到dom节点\n6. 页面加载时根据hash渲染dom节点\n\n### vue-router\n\n1. 准备路由和视图的对应关系\n2. 使用申明好的对应关系，实例化一个router实例\n3. 将router实例挂载到vue中\n\n#### grammar\n\n```js\n\n<router-link to='/foo'></router-link>\n<router-link to='/bar'></router-link>\n\n<router-view></router-view> //渲染对应的组件\n\n1.准备路由和视图的对应关系\nconst foo = {\n    template:`<div>foo</div>`\n}\nconst bar = {\n    template:`<div>bar</div>`\n}\n\n2.使用申明好的对应关系，实例化一个router实例\nconst routes = [\n    {\n        name:'foo'\n        path:'/foo',\n        component:foo\n    },\n    {\n        path:'/bar',\n        component:bar \n    }\n]\nconst router = new VueRouter({\n    routes:routes\n})\n\n\n3.将router实例挂载到vue中\nconst vm = new Vue({\n    el:'#app',\n    route:routes\n})\n```\n\n### router 跳转案例\n\n+ query传参\n\n  ```js\n  1.实现路由跳转\n  this.$router.push({\n    path:'/跳转路径' ,\n    query:{ //跳转时通过传参数\n    \t参数:xx\n    }\n  })\n  \n  2.获取参数\n  {{$route.query.参数名}} //获取query传过来的参数\n  ```\n\n+ param+name传参\n\n  ```js\n  1.实现路由跳转\n  this.$router.push({\n    name:'routerName', //必须添加一个name属性\n    params:{ //跳转时通过传参数\n  \tid:id\n    }\n  })\n  \n  2.添加路径占位符\n  \n  \n  3.获取参数\n  {{$route.params.id}}\n  ```\n\n  \n\n###从一个路径跳转到另一个路径\n\n```js\n1.重定向\n{\n    path:'地址',\n    redirect:'重定向的地址'\n}\n\n2.别名\n{\n    path:'路径',\n    alias:'路径的别名也是路径'\n}\n```\n\n\n\n###导航守卫\n\n> 经常用来判断登录\n\n#### grammar\n\n```js\nrouter.beforeEach((to,from,next)=>{\n  to //前往的目标路由对象\n  from //来源路由对象\n  next() //可调用的函数，必须调用才能完成正常跳转\n})\n```\n\n\n\n### 路由嵌套\n\n> 在已经存在的路由器中再套一层路由器\n\n#### 网易云路由嵌套案例\n\n```js\n{\n    children:[\n        path:'路径',\n        component:组件名\n    ]\n}\n```\n\n","source":"_posts/笔记/ocean/12-Vue总结/04-component通信/04-note.md","raw":"---\ntitle: vue基础-组件通信\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- vue\n---\n# 04-vue\n\n\n\n## father Son Component通信\n\n\n\n### father pass son\n\n1. 父组件中的模板使用子组件的地方，在子组件身上添加自定义属性，然后绑定要传递的数据\n2. 子组件在props中接受父组件的值，组件名使用驼峰\n3. 在模板中使用传递过来的数据,，不加this\n\n#### static grammar\n\n+ 不加冒号，只能传字符串\n\n```js\nVue.component('father-component',{\n    template:`<son-component title=\"send value\"></son-component>`,\n})\n\n\nVue.component('son-component',{\n    props:{\n        title:{\n\t    type:String,\n            required: true //true为必须传\n        }\n    },//如果son本身有属性名呢，会报错\n    template:`<div>{{title}}</div>\">`\n})\n```\n\n#### dynamic grammar\n\n1. 传递一般 dynamicData 时，需要加冒号\n2.  绑定字符串会被当成属性识别\n3. number,Array,Object,function\n\n```js\nVue.component('father-component',{\n    template:`<son-component :age=18></son-component>`,\n})\n\n\nVue.component('son-component',{\n    props:{\n        age:{\n\t\t \ttype:Number\n        }\n    },//如果son本身有属性名呢\n    template:`<div>{{age}}</div>\">`\n})\n```\n\n\n\n### son pass father\n\n>  在子组件中调取父组件中的方法，并且传入要传递的数据\n\n1. 在父组件使用子组件的身上绑定一个自定义事件，触发时调用父组件中的函数\n\n2. 在子组件需要传值的地方，使用$emit()调用父组件的自定义函数，并传入要传的数据\n\n   \n\n#### grammar\n\n```js\nVue.component('father-component',{\n    template:`<div :style={color:fcolor}>\n\t\t\t\t\t<son-component @自定义事件='changeColor'></son-component>\n\t\t\t\t</div>`,//不需要传递实参吗\n    data(){\n        return{\n             fcolor:'red'\n            }\n\t},\n    methods:{\n        changeColor(color){\n            this.fcolor = color\n        }\n    }\n})\n\n\nVue.component('son-component',{\n    data(){\n        return{\n            color:'blue'\n        }\n    },\n    methods:{\n        changeFatherColor(){\n            this.$emit('要触发的自定义事件',要传递的数据)\n        }\n    }\n})\n```\n\n##component抽离复用\n\n1. component抽离后，提高了component中的模板复用性\n2. 抽离组件后，只负责视图模板渲染，可以拥有自己的数据，可随意修改数据\n\n\n\n## **总结通信方式**\n\n1. Props + $emit()\n\n3. $parent + $children\n\n   ```js\n   在子组件中通过 this.$parent.message 访问到父组件的至\n   在父组件中使用 this.$children[0].number = 50; 访问第0项，因为一个父组件可能会有多个子组件\n   ```\n\n4. provide + inject\n\n   ```js\n   fatherComponent\n   {\n   \tprovide:{\n   +\t\tmessage:\"123\"\n   \t}\t\n   }\n   \n   sonComponent\n   inject:['message']\n   ```\n\n5. $attrs + $listeners\n\n   ```js\n   父传子传孙子\n   father\n   <son :name>\n   \n   changeName(){\n       this.name = 'df'\n   }\n   \n   son\n   <button @click=\"$listeners.changeName\">按钮</button> //触发父元素的函数\n   <sonS v-bind=\"$attrs\" > //$attrs属性中包括了father传过来的值\n   \n   sonS\n   <div>{{$attrs.name}}</div>\n   ```\n\n6. ref\n\n   ```js\n   father\n   <Son ref='child' />\n   <button @click=\"changeName\"></button>\n   \n   methods:{\n       changeName(){\n           this.$refs.child.属性名 //获取子组件属性\n           this.$refs.child.方法名() //调用子组件中的方法\n       }\n   }\n   \n   \n   son\n   data{\n   \treturn{\n           属性名\n       }\n   }\n   方法名(){\n   \tthis.age = 50\n   }\n   ```\n\n   \n\n\n\n\n\n## vue-单页应用开发\n\n> 对url进行改变和监听location.hash，让某个dom节点显示对应的视图\n\n### 原生 router\n\n1. 对url进行改变\n2. 使用hashchange事件监听hash\n3. 准备一个存放内容的dom节点\n4. 描述url标识的内容对应关系\n5. 将当前hash对应的内容渲染到dom节点\n6. 页面加载时根据hash渲染dom节点\n\n### vue-router\n\n1. 准备路由和视图的对应关系\n2. 使用申明好的对应关系，实例化一个router实例\n3. 将router实例挂载到vue中\n\n#### grammar\n\n```js\n\n<router-link to='/foo'></router-link>\n<router-link to='/bar'></router-link>\n\n<router-view></router-view> //渲染对应的组件\n\n1.准备路由和视图的对应关系\nconst foo = {\n    template:`<div>foo</div>`\n}\nconst bar = {\n    template:`<div>bar</div>`\n}\n\n2.使用申明好的对应关系，实例化一个router实例\nconst routes = [\n    {\n        name:'foo'\n        path:'/foo',\n        component:foo\n    },\n    {\n        path:'/bar',\n        component:bar \n    }\n]\nconst router = new VueRouter({\n    routes:routes\n})\n\n\n3.将router实例挂载到vue中\nconst vm = new Vue({\n    el:'#app',\n    route:routes\n})\n```\n\n### router 跳转案例\n\n+ query传参\n\n  ```js\n  1.实现路由跳转\n  this.$router.push({\n    path:'/跳转路径' ,\n    query:{ //跳转时通过传参数\n    \t参数:xx\n    }\n  })\n  \n  2.获取参数\n  {{$route.query.参数名}} //获取query传过来的参数\n  ```\n\n+ param+name传参\n\n  ```js\n  1.实现路由跳转\n  this.$router.push({\n    name:'routerName', //必须添加一个name属性\n    params:{ //跳转时通过传参数\n  \tid:id\n    }\n  })\n  \n  2.添加路径占位符\n  \n  \n  3.获取参数\n  {{$route.params.id}}\n  ```\n\n  \n\n###从一个路径跳转到另一个路径\n\n```js\n1.重定向\n{\n    path:'地址',\n    redirect:'重定向的地址'\n}\n\n2.别名\n{\n    path:'路径',\n    alias:'路径的别名也是路径'\n}\n```\n\n\n\n###导航守卫\n\n> 经常用来判断登录\n\n#### grammar\n\n```js\nrouter.beforeEach((to,from,next)=>{\n  to //前往的目标路由对象\n  from //来源路由对象\n  next() //可调用的函数，必须调用才能完成正常跳转\n})\n```\n\n\n\n### 路由嵌套\n\n> 在已经存在的路由器中再套一层路由器\n\n#### 网易云路由嵌套案例\n\n```js\n{\n    children:[\n        path:'路径',\n        component:组件名\n    ]\n}\n```\n\n","slug":"笔记/ocean/12-Vue总结/04-component通信/04-note","published":1,"updated":"2023-03-01T07:28:21.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qea00b0awafdhiq154p","content":"<h1 id=\"04-vue\"><a href=\"#04-vue\" class=\"headerlink\" title=\"04-vue\"></a>04-vue</h1><h2 id=\"father-Son-Component通信\"><a href=\"#father-Son-Component通信\" class=\"headerlink\" title=\"father Son Component通信\"></a>father Son Component通信</h2><h3 id=\"father-pass-son\"><a href=\"#father-pass-son\" class=\"headerlink\" title=\"father pass son\"></a>father pass son</h3><ol>\n<li>父组件中的模板使用子组件的地方，在子组件身上添加自定义属性，然后绑定要传递的数据</li>\n<li>子组件在props中接受父组件的值，组件名使用驼峰</li>\n<li>在模板中使用传递过来的数据,，不加this</li>\n</ol>\n<h4 id=\"static-grammar\"><a href=\"#static-grammar\" class=\"headerlink\" title=\"static grammar\"></a>static grammar</h4><ul>\n<li>不加冒号，只能传字符串</li>\n</ul>\n<pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;son-component title=&quot;send value&quot;&gt;&lt;/son-component&gt;`,\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    props:&#123;\n        title:&#123;\n        type:String,\n            required: true //true为必须传\n        &#125;\n    &#125;,//如果son本身有属性名呢，会报错\n    template:`&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&quot;&gt;`\n&#125;)\n</code></pre>\n<h4 id=\"dynamic-grammar\"><a href=\"#dynamic-grammar\" class=\"headerlink\" title=\"dynamic grammar\"></a>dynamic grammar</h4><ol>\n<li>传递一般 dynamicData 时，需要加冒号</li>\n<li> 绑定字符串会被当成属性识别</li>\n<li>number,Array,Object,function</li>\n</ol>\n<pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;son-component :age=18&gt;&lt;/son-component&gt;`,\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    props:&#123;\n        age:&#123;\n             type:Number\n        &#125;\n    &#125;,//如果son本身有属性名呢\n    template:`&lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;&quot;&gt;`\n&#125;)\n</code></pre>\n<h3 id=\"son-pass-father\"><a href=\"#son-pass-father\" class=\"headerlink\" title=\"son pass father\"></a>son pass father</h3><blockquote>\n<p> 在子组件中调取父组件中的方法，并且传入要传递的数据</p>\n</blockquote>\n<ol>\n<li><p>在父组件使用子组件的身上绑定一个自定义事件，触发时调用父组件中的函数</p>\n</li>\n<li><p>在子组件需要传值的地方，使用$emit()调用父组件的自定义函数，并传入要传的数据</p>\n</li>\n</ol>\n<h4 id=\"grammar\"><a href=\"#grammar\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;div :style=&#123;color:fcolor&#125;&gt;\n                    &lt;son-component @自定义事件=&#39;changeColor&#39;&gt;&lt;/son-component&gt;\n                &lt;/div&gt;`,//不需要传递实参吗\n    data()&#123;\n        return&#123;\n             fcolor:&#39;red&#39;\n            &#125;\n    &#125;,\n    methods:&#123;\n        changeColor(color)&#123;\n            this.fcolor = color\n        &#125;\n    &#125;\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    data()&#123;\n        return&#123;\n            color:&#39;blue&#39;\n        &#125;\n    &#125;,\n    methods:&#123;\n        changeFatherColor()&#123;\n            this.$emit(&#39;要触发的自定义事件&#39;,要传递的数据)\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<p>##component抽离复用</p>\n<ol>\n<li>component抽离后，提高了component中的模板复用性</li>\n<li>抽离组件后，只负责视图模板渲染，可以拥有自己的数据，可随意修改数据</li>\n</ol>\n<h2 id=\"总结通信方式\"><a href=\"#总结通信方式\" class=\"headerlink\" title=\"总结通信方式\"></a><strong>总结通信方式</strong></h2><ol>\n<li><p>Props + $emit()</p>\n</li>\n<li><p>$parent + $children</p>\n<pre><code class=\"js\">在子组件中通过 this.$parent.message 访问到父组件的至\n在父组件中使用 this.$children[0].number = 50; 访问第0项，因为一个父组件可能会有多个子组件\n</code></pre>\n</li>\n<li><p>provide + inject</p>\n<pre><code class=\"js\">fatherComponent\n&#123;\n    provide:&#123;\n+        message:&quot;123&quot;\n    &#125;    \n&#125;\n\nsonComponent\ninject:[&#39;message&#39;]\n</code></pre>\n</li>\n<li><p>$attrs + $listeners</p>\n<pre><code class=\"js\">父传子传孙子\nfather\n&lt;son :name&gt;\n\nchangeName()&#123;\n    this.name = &#39;df&#39;\n&#125;\n\nson\n&lt;button @click=&quot;$listeners.changeName&quot;&gt;按钮&lt;/button&gt; //触发父元素的函数\n&lt;sonS v-bind=&quot;$attrs&quot; &gt; //$attrs属性中包括了father传过来的值\n\nsonS\n&lt;div&gt;&#123;&#123;$attrs.name&#125;&#125;&lt;/div&gt;\n</code></pre>\n</li>\n<li><p>ref</p>\n<pre><code class=\"js\">father\n&lt;Son ref=&#39;child&#39; /&gt;\n&lt;button @click=&quot;changeName&quot;&gt;&lt;/button&gt;\n\nmethods:&#123;\n    changeName()&#123;\n        this.$refs.child.属性名 //获取子组件属性\n        this.$refs.child.方法名() //调用子组件中的方法\n    &#125;\n&#125;\n\n\nson\ndata&#123;\n    return&#123;\n        属性名\n    &#125;\n&#125;\n方法名()&#123;\n    this.age = 50\n&#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"vue-单页应用开发\"><a href=\"#vue-单页应用开发\" class=\"headerlink\" title=\"vue-单页应用开发\"></a>vue-单页应用开发</h2><blockquote>\n<p>对url进行改变和监听location.hash，让某个dom节点显示对应的视图</p>\n</blockquote>\n<h3 id=\"原生-router\"><a href=\"#原生-router\" class=\"headerlink\" title=\"原生 router\"></a>原生 router</h3><ol>\n<li>对url进行改变</li>\n<li>使用hashchange事件监听hash</li>\n<li>准备一个存放内容的dom节点</li>\n<li>描述url标识的内容对应关系</li>\n<li>将当前hash对应的内容渲染到dom节点</li>\n<li>页面加载时根据hash渲染dom节点</li>\n</ol>\n<h3 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h3><ol>\n<li>准备路由和视图的对应关系</li>\n<li>使用申明好的对应关系，实例化一个router实例</li>\n<li>将router实例挂载到vue中</li>\n</ol>\n<h4 id=\"grammar-1\"><a href=\"#grammar-1\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">\n&lt;router-link to=&#39;/foo&#39;&gt;&lt;/router-link&gt;\n&lt;router-link to=&#39;/bar&#39;&gt;&lt;/router-link&gt;\n\n&lt;router-view&gt;&lt;/router-view&gt; //渲染对应的组件\n\n1.准备路由和视图的对应关系\nconst foo = &#123;\n    template:`&lt;div&gt;foo&lt;/div&gt;`\n&#125;\nconst bar = &#123;\n    template:`&lt;div&gt;bar&lt;/div&gt;`\n&#125;\n\n2.使用申明好的对应关系，实例化一个router实例\nconst routes = [\n    &#123;\n        name:&#39;foo&#39;\n        path:&#39;/foo&#39;,\n        component:foo\n    &#125;,\n    &#123;\n        path:&#39;/bar&#39;,\n        component:bar \n    &#125;\n]\nconst router = new VueRouter(&#123;\n    routes:routes\n&#125;)\n\n\n3.将router实例挂载到vue中\nconst vm = new Vue(&#123;\n    el:&#39;#app&#39;,\n    route:routes\n&#125;)\n</code></pre>\n<h3 id=\"router-跳转案例\"><a href=\"#router-跳转案例\" class=\"headerlink\" title=\"router 跳转案例\"></a>router 跳转案例</h3><ul>\n<li><p>query传参</p>\n<pre><code class=\"js\">1.实现路由跳转\nthis.$router.push(&#123;\n  path:&#39;/跳转路径&#39; ,\n  query:&#123; //跳转时通过传参数\n      参数:xx\n  &#125;\n&#125;)\n\n2.获取参数\n&#123;&#123;$route.query.参数名&#125;&#125; //获取query传过来的参数\n</code></pre>\n</li>\n<li><p>param+name传参</p>\n<pre><code class=\"js\">1.实现路由跳转\nthis.$router.push(&#123;\n  name:&#39;routerName&#39;, //必须添加一个name属性\n  params:&#123; //跳转时通过传参数\n    id:id\n  &#125;\n&#125;)\n\n2.添加路径占位符\n\n\n3.获取参数\n&#123;&#123;$route.params.id&#125;&#125;\n</code></pre>\n</li>\n</ul>\n<p>###从一个路径跳转到另一个路径</p>\n<pre><code class=\"js\">1.重定向\n&#123;\n    path:&#39;地址&#39;,\n    redirect:&#39;重定向的地址&#39;\n&#125;\n\n2.别名\n&#123;\n    path:&#39;路径&#39;,\n    alias:&#39;路径的别名也是路径&#39;\n&#125;\n</code></pre>\n<p>###导航守卫</p>\n<blockquote>\n<p>经常用来判断登录</p>\n</blockquote>\n<h4 id=\"grammar-2\"><a href=\"#grammar-2\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">router.beforeEach((to,from,next)=&gt;&#123;\n  to //前往的目标路由对象\n  from //来源路由对象\n  next() //可调用的函数，必须调用才能完成正常跳转\n&#125;)\n</code></pre>\n<h3 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h3><blockquote>\n<p>在已经存在的路由器中再套一层路由器</p>\n</blockquote>\n<h4 id=\"网易云路由嵌套案例\"><a href=\"#网易云路由嵌套案例\" class=\"headerlink\" title=\"网易云路由嵌套案例\"></a>网易云路由嵌套案例</h4><pre><code class=\"js\">&#123;\n    children:[\n        path:&#39;路径&#39;,\n        component:组件名\n    ]\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"04-vue\"><a href=\"#04-vue\" class=\"headerlink\" title=\"04-vue\"></a>04-vue</h1><h2 id=\"father-Son-Component通信\"><a href=\"#father-Son-Component通信\" class=\"headerlink\" title=\"father Son Component通信\"></a>father Son Component通信</h2><h3 id=\"father-pass-son\"><a href=\"#father-pass-son\" class=\"headerlink\" title=\"father pass son\"></a>father pass son</h3><ol>\n<li>父组件中的模板使用子组件的地方，在子组件身上添加自定义属性，然后绑定要传递的数据</li>\n<li>子组件在props中接受父组件的值，组件名使用驼峰</li>\n<li>在模板中使用传递过来的数据,，不加this</li>\n</ol>\n<h4 id=\"static-grammar\"><a href=\"#static-grammar\" class=\"headerlink\" title=\"static grammar\"></a>static grammar</h4><ul>\n<li>不加冒号，只能传字符串</li>\n</ul>\n<pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;son-component title=&quot;send value&quot;&gt;&lt;/son-component&gt;`,\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    props:&#123;\n        title:&#123;\n        type:String,\n            required: true //true为必须传\n        &#125;\n    &#125;,//如果son本身有属性名呢，会报错\n    template:`&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&quot;&gt;`\n&#125;)\n</code></pre>\n<h4 id=\"dynamic-grammar\"><a href=\"#dynamic-grammar\" class=\"headerlink\" title=\"dynamic grammar\"></a>dynamic grammar</h4><ol>\n<li>传递一般 dynamicData 时，需要加冒号</li>\n<li> 绑定字符串会被当成属性识别</li>\n<li>number,Array,Object,function</li>\n</ol>\n<pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;son-component :age=18&gt;&lt;/son-component&gt;`,\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    props:&#123;\n        age:&#123;\n             type:Number\n        &#125;\n    &#125;,//如果son本身有属性名呢\n    template:`&lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;&quot;&gt;`\n&#125;)\n</code></pre>\n<h3 id=\"son-pass-father\"><a href=\"#son-pass-father\" class=\"headerlink\" title=\"son pass father\"></a>son pass father</h3><blockquote>\n<p> 在子组件中调取父组件中的方法，并且传入要传递的数据</p>\n</blockquote>\n<ol>\n<li><p>在父组件使用子组件的身上绑定一个自定义事件，触发时调用父组件中的函数</p>\n</li>\n<li><p>在子组件需要传值的地方，使用$emit()调用父组件的自定义函数，并传入要传的数据</p>\n</li>\n</ol>\n<h4 id=\"grammar\"><a href=\"#grammar\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">Vue.component(&#39;father-component&#39;,&#123;\n    template:`&lt;div :style=&#123;color:fcolor&#125;&gt;\n                    &lt;son-component @自定义事件=&#39;changeColor&#39;&gt;&lt;/son-component&gt;\n                &lt;/div&gt;`,//不需要传递实参吗\n    data()&#123;\n        return&#123;\n             fcolor:&#39;red&#39;\n            &#125;\n    &#125;,\n    methods:&#123;\n        changeColor(color)&#123;\n            this.fcolor = color\n        &#125;\n    &#125;\n&#125;)\n\n\nVue.component(&#39;son-component&#39;,&#123;\n    data()&#123;\n        return&#123;\n            color:&#39;blue&#39;\n        &#125;\n    &#125;,\n    methods:&#123;\n        changeFatherColor()&#123;\n            this.$emit(&#39;要触发的自定义事件&#39;,要传递的数据)\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<p>##component抽离复用</p>\n<ol>\n<li>component抽离后，提高了component中的模板复用性</li>\n<li>抽离组件后，只负责视图模板渲染，可以拥有自己的数据，可随意修改数据</li>\n</ol>\n<h2 id=\"总结通信方式\"><a href=\"#总结通信方式\" class=\"headerlink\" title=\"总结通信方式\"></a><strong>总结通信方式</strong></h2><ol>\n<li><p>Props + $emit()</p>\n</li>\n<li><p>$parent + $children</p>\n<pre><code class=\"js\">在子组件中通过 this.$parent.message 访问到父组件的至\n在父组件中使用 this.$children[0].number = 50; 访问第0项，因为一个父组件可能会有多个子组件\n</code></pre>\n</li>\n<li><p>provide + inject</p>\n<pre><code class=\"js\">fatherComponent\n&#123;\n    provide:&#123;\n+        message:&quot;123&quot;\n    &#125;    \n&#125;\n\nsonComponent\ninject:[&#39;message&#39;]\n</code></pre>\n</li>\n<li><p>$attrs + $listeners</p>\n<pre><code class=\"js\">父传子传孙子\nfather\n&lt;son :name&gt;\n\nchangeName()&#123;\n    this.name = &#39;df&#39;\n&#125;\n\nson\n&lt;button @click=&quot;$listeners.changeName&quot;&gt;按钮&lt;/button&gt; //触发父元素的函数\n&lt;sonS v-bind=&quot;$attrs&quot; &gt; //$attrs属性中包括了father传过来的值\n\nsonS\n&lt;div&gt;&#123;&#123;$attrs.name&#125;&#125;&lt;/div&gt;\n</code></pre>\n</li>\n<li><p>ref</p>\n<pre><code class=\"js\">father\n&lt;Son ref=&#39;child&#39; /&gt;\n&lt;button @click=&quot;changeName&quot;&gt;&lt;/button&gt;\n\nmethods:&#123;\n    changeName()&#123;\n        this.$refs.child.属性名 //获取子组件属性\n        this.$refs.child.方法名() //调用子组件中的方法\n    &#125;\n&#125;\n\n\nson\ndata&#123;\n    return&#123;\n        属性名\n    &#125;\n&#125;\n方法名()&#123;\n    this.age = 50\n&#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"vue-单页应用开发\"><a href=\"#vue-单页应用开发\" class=\"headerlink\" title=\"vue-单页应用开发\"></a>vue-单页应用开发</h2><blockquote>\n<p>对url进行改变和监听location.hash，让某个dom节点显示对应的视图</p>\n</blockquote>\n<h3 id=\"原生-router\"><a href=\"#原生-router\" class=\"headerlink\" title=\"原生 router\"></a>原生 router</h3><ol>\n<li>对url进行改变</li>\n<li>使用hashchange事件监听hash</li>\n<li>准备一个存放内容的dom节点</li>\n<li>描述url标识的内容对应关系</li>\n<li>将当前hash对应的内容渲染到dom节点</li>\n<li>页面加载时根据hash渲染dom节点</li>\n</ol>\n<h3 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h3><ol>\n<li>准备路由和视图的对应关系</li>\n<li>使用申明好的对应关系，实例化一个router实例</li>\n<li>将router实例挂载到vue中</li>\n</ol>\n<h4 id=\"grammar-1\"><a href=\"#grammar-1\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">\n&lt;router-link to=&#39;/foo&#39;&gt;&lt;/router-link&gt;\n&lt;router-link to=&#39;/bar&#39;&gt;&lt;/router-link&gt;\n\n&lt;router-view&gt;&lt;/router-view&gt; //渲染对应的组件\n\n1.准备路由和视图的对应关系\nconst foo = &#123;\n    template:`&lt;div&gt;foo&lt;/div&gt;`\n&#125;\nconst bar = &#123;\n    template:`&lt;div&gt;bar&lt;/div&gt;`\n&#125;\n\n2.使用申明好的对应关系，实例化一个router实例\nconst routes = [\n    &#123;\n        name:&#39;foo&#39;\n        path:&#39;/foo&#39;,\n        component:foo\n    &#125;,\n    &#123;\n        path:&#39;/bar&#39;,\n        component:bar \n    &#125;\n]\nconst router = new VueRouter(&#123;\n    routes:routes\n&#125;)\n\n\n3.将router实例挂载到vue中\nconst vm = new Vue(&#123;\n    el:&#39;#app&#39;,\n    route:routes\n&#125;)\n</code></pre>\n<h3 id=\"router-跳转案例\"><a href=\"#router-跳转案例\" class=\"headerlink\" title=\"router 跳转案例\"></a>router 跳转案例</h3><ul>\n<li><p>query传参</p>\n<pre><code class=\"js\">1.实现路由跳转\nthis.$router.push(&#123;\n  path:&#39;/跳转路径&#39; ,\n  query:&#123; //跳转时通过传参数\n      参数:xx\n  &#125;\n&#125;)\n\n2.获取参数\n&#123;&#123;$route.query.参数名&#125;&#125; //获取query传过来的参数\n</code></pre>\n</li>\n<li><p>param+name传参</p>\n<pre><code class=\"js\">1.实现路由跳转\nthis.$router.push(&#123;\n  name:&#39;routerName&#39;, //必须添加一个name属性\n  params:&#123; //跳转时通过传参数\n    id:id\n  &#125;\n&#125;)\n\n2.添加路径占位符\n\n\n3.获取参数\n&#123;&#123;$route.params.id&#125;&#125;\n</code></pre>\n</li>\n</ul>\n<p>###从一个路径跳转到另一个路径</p>\n<pre><code class=\"js\">1.重定向\n&#123;\n    path:&#39;地址&#39;,\n    redirect:&#39;重定向的地址&#39;\n&#125;\n\n2.别名\n&#123;\n    path:&#39;路径&#39;,\n    alias:&#39;路径的别名也是路径&#39;\n&#125;\n</code></pre>\n<p>###导航守卫</p>\n<blockquote>\n<p>经常用来判断登录</p>\n</blockquote>\n<h4 id=\"grammar-2\"><a href=\"#grammar-2\" class=\"headerlink\" title=\"grammar\"></a>grammar</h4><pre><code class=\"js\">router.beforeEach((to,from,next)=&gt;&#123;\n  to //前往的目标路由对象\n  from //来源路由对象\n  next() //可调用的函数，必须调用才能完成正常跳转\n&#125;)\n</code></pre>\n<h3 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h3><blockquote>\n<p>在已经存在的路由器中再套一层路由器</p>\n</blockquote>\n<h4 id=\"网易云路由嵌套案例\"><a href=\"#网易云路由嵌套案例\" class=\"headerlink\" title=\"网易云路由嵌套案例\"></a>网易云路由嵌套案例</h4><pre><code class=\"js\">&#123;\n    children:[\n        path:&#39;路径&#39;,\n        component:组件名\n    ]\n&#125;\n</code></pre>\n"},{"title":"react基础02","date":"2020-08-20T13:34:23.000Z","_content":"\n# React基础02\n\n## 脚手架-项目创建\n\n```js\n1.创建命令 \nnpx create-react-app 项目名 \n// npx 如果本地有这个模块就使用，如果没用就下载\n```\n\n### 文件介绍\n\n```js\nsrc下的文件都可删除,只保留核心\n可以看脚手架官方文档\ncomponents // 组件目录 \n  创建函数组件或类组件可以导入到App\n  \nreact中的逻辑业务和样式是分开写的\n全局样式放在 style 目录下，叫index.css\n组件样式和组件同名同级，需要导入 \n\n```\n\n## 循环\n\n```js\n在jsx中使用map\n{\n    arr.map((v,i)=>(\n    \t<li key={i} onClick={()=>{ this.fun() }}> {v} </li>\n    ))\n}\n```\n\n## react通讯\n\n\n\n> 不像vue，必须提前声明，而react不需要提前声明,和vue一样是单向数据流，可读不可修改\n\n### 父传子\n\n```js\n\n1.函数组件传参数\n<Fun msg=\"参数\" ... />\nfunction Fun(props){\n    \n}\n2.class组件传参\nclass className extends React.Component{\n    \n    constructor(porps){\n        super(porps)\n        this.porps 可以拿到\n    }\n    render(){\n        let {参数1，...} = this.props\n    }\n}\nexport default className\n```\n\n#### 传递函数\n\n```js\n直接传递\nfun(){\n    \n}\n\n<ProFun hanlder={this.fun}/>\n    \n    \n获取：\nclass className extends React.component{\n    render () {\n        \n        return (\n        \tthis.props.hanlder() 直接调用\n        )\n    }\n}\n```\n\n### 子传父\n\n```js\n通过调用父组件函数传递参数\n\nfather:\nfaterFun = (newInfo) => {\n    this.setState({\n        info: newInfo\n    })\n}\n\nreder(){\n    return ( \n    \t<Profun info={info} changeInfo={this.faterFun} />\n    )\n}\n\n\nson:\n\nclass ProFun extends React.component {\n    render(){\n        let { info } = this.props\n        let { changeInfo } = this.props\n        return (\n        \t<div>\n            \t<input onClick={changInfo('传递的参数')}\n            </div>\n        )\n    }\n}\n\n提示：\n如果不需要有自己的数据状态，那么用函数组件较好\n需要保存自己的状态就用类组件\n和vue一样，数据源更新，子组件数据也会改变\n```\n\n### 数据传递限制\n\n+ __PropTypes__ :类型校验即默认值\n\n  ```js\n  1.下载导入包\n    npm i prop-types\n    import PropTypes from 'prop-types'\n  2.校验\n  function sonFun(){\n      let { info } = this.props\n  }\n  \n  PropsCheck.propTypes = {\n      info: PropTypes.string  // 必须为字符串\n  }\n  \n  PropsCheck.defaultProps = {\n      info: '默认值'  // 默认值\n  }\n  \n  ```\n\n## 插件\n\n```\nReact tools // 浏览器插件\n\n```\n\n\n\n","source":"_posts/笔记/ocean/15-react/02/00-note.md","raw":"---\ntitle: react基础02\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- react\n---\n\n# React基础02\n\n## 脚手架-项目创建\n\n```js\n1.创建命令 \nnpx create-react-app 项目名 \n// npx 如果本地有这个模块就使用，如果没用就下载\n```\n\n### 文件介绍\n\n```js\nsrc下的文件都可删除,只保留核心\n可以看脚手架官方文档\ncomponents // 组件目录 \n  创建函数组件或类组件可以导入到App\n  \nreact中的逻辑业务和样式是分开写的\n全局样式放在 style 目录下，叫index.css\n组件样式和组件同名同级，需要导入 \n\n```\n\n## 循环\n\n```js\n在jsx中使用map\n{\n    arr.map((v,i)=>(\n    \t<li key={i} onClick={()=>{ this.fun() }}> {v} </li>\n    ))\n}\n```\n\n## react通讯\n\n\n\n> 不像vue，必须提前声明，而react不需要提前声明,和vue一样是单向数据流，可读不可修改\n\n### 父传子\n\n```js\n\n1.函数组件传参数\n<Fun msg=\"参数\" ... />\nfunction Fun(props){\n    \n}\n2.class组件传参\nclass className extends React.Component{\n    \n    constructor(porps){\n        super(porps)\n        this.porps 可以拿到\n    }\n    render(){\n        let {参数1，...} = this.props\n    }\n}\nexport default className\n```\n\n#### 传递函数\n\n```js\n直接传递\nfun(){\n    \n}\n\n<ProFun hanlder={this.fun}/>\n    \n    \n获取：\nclass className extends React.component{\n    render () {\n        \n        return (\n        \tthis.props.hanlder() 直接调用\n        )\n    }\n}\n```\n\n### 子传父\n\n```js\n通过调用父组件函数传递参数\n\nfather:\nfaterFun = (newInfo) => {\n    this.setState({\n        info: newInfo\n    })\n}\n\nreder(){\n    return ( \n    \t<Profun info={info} changeInfo={this.faterFun} />\n    )\n}\n\n\nson:\n\nclass ProFun extends React.component {\n    render(){\n        let { info } = this.props\n        let { changeInfo } = this.props\n        return (\n        \t<div>\n            \t<input onClick={changInfo('传递的参数')}\n            </div>\n        )\n    }\n}\n\n提示：\n如果不需要有自己的数据状态，那么用函数组件较好\n需要保存自己的状态就用类组件\n和vue一样，数据源更新，子组件数据也会改变\n```\n\n### 数据传递限制\n\n+ __PropTypes__ :类型校验即默认值\n\n  ```js\n  1.下载导入包\n    npm i prop-types\n    import PropTypes from 'prop-types'\n  2.校验\n  function sonFun(){\n      let { info } = this.props\n  }\n  \n  PropsCheck.propTypes = {\n      info: PropTypes.string  // 必须为字符串\n  }\n  \n  PropsCheck.defaultProps = {\n      info: '默认值'  // 默认值\n  }\n  \n  ```\n\n## 插件\n\n```\nReact tools // 浏览器插件\n\n```\n\n\n\n","slug":"笔记/ocean/15-react/02/00-note","published":1,"updated":"2023-03-01T07:30:23.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qeb00b3awaf55lw5p5c","content":"<h1 id=\"React基础02\"><a href=\"#React基础02\" class=\"headerlink\" title=\"React基础02\"></a>React基础02</h1><h2 id=\"脚手架-项目创建\"><a href=\"#脚手架-项目创建\" class=\"headerlink\" title=\"脚手架-项目创建\"></a>脚手架-项目创建</h2><pre><code class=\"js\">1.创建命令 \nnpx create-react-app 项目名 \n// npx 如果本地有这个模块就使用，如果没用就下载\n</code></pre>\n<h3 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h3><pre><code class=\"js\">src下的文件都可删除,只保留核心\n可以看脚手架官方文档\ncomponents // 组件目录 \n  创建函数组件或类组件可以导入到App\n  \nreact中的逻辑业务和样式是分开写的\n全局样式放在 style 目录下，叫index.css\n组件样式和组件同名同级，需要导入 \n</code></pre>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><pre><code class=\"js\">在jsx中使用map\n&#123;\n    arr.map((v,i)=&gt;(\n        &lt;li key=&#123;i&#125; onClick=&#123;()=&gt;&#123; this.fun() &#125;&#125;&gt; &#123;v&#125; &lt;/li&gt;\n    ))\n&#125;\n</code></pre>\n<h2 id=\"react通讯\"><a href=\"#react通讯\" class=\"headerlink\" title=\"react通讯\"></a>react通讯</h2><blockquote>\n<p>不像vue，必须提前声明，而react不需要提前声明,和vue一样是单向数据流，可读不可修改</p>\n</blockquote>\n<h3 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h3><pre><code class=\"js\">\n1.函数组件传参数\n&lt;Fun msg=&quot;参数&quot; ... /&gt;\nfunction Fun(props)&#123;\n    \n&#125;\n2.class组件传参\nclass className extends React.Component&#123;\n    \n    constructor(porps)&#123;\n        super(porps)\n        this.porps 可以拿到\n    &#125;\n    render()&#123;\n        let &#123;参数1，...&#125; = this.props\n    &#125;\n&#125;\nexport default className\n</code></pre>\n<h4 id=\"传递函数\"><a href=\"#传递函数\" class=\"headerlink\" title=\"传递函数\"></a>传递函数</h4><pre><code class=\"js\">直接传递\nfun()&#123;\n    \n&#125;\n\n&lt;ProFun hanlder=&#123;this.fun&#125;/&gt;\n    \n    \n获取：\nclass className extends React.component&#123;\n    render () &#123;\n        \n        return (\n            this.props.hanlder() 直接调用\n        )\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h3><pre><code class=\"js\">通过调用父组件函数传递参数\n\nfather:\nfaterFun = (newInfo) =&gt; &#123;\n    this.setState(&#123;\n        info: newInfo\n    &#125;)\n&#125;\n\nreder()&#123;\n    return ( \n        &lt;Profun info=&#123;info&#125; changeInfo=&#123;this.faterFun&#125; /&gt;\n    )\n&#125;\n\n\nson:\n\nclass ProFun extends React.component &#123;\n    render()&#123;\n        let &#123; info &#125; = this.props\n        let &#123; changeInfo &#125; = this.props\n        return (\n            &lt;div&gt;\n                &lt;input onClick=&#123;changInfo(&#39;传递的参数&#39;)&#125;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;\n\n提示：\n如果不需要有自己的数据状态，那么用函数组件较好\n需要保存自己的状态就用类组件\n和vue一样，数据源更新，子组件数据也会改变\n</code></pre>\n<h3 id=\"数据传递限制\"><a href=\"#数据传递限制\" class=\"headerlink\" title=\"数据传递限制\"></a>数据传递限制</h3><ul>\n<li><p><strong>PropTypes</strong> :类型校验即默认值</p>\n<pre><code class=\"js\">1.下载导入包\n  npm i prop-types\n  import PropTypes from &#39;prop-types&#39;\n2.校验\nfunction sonFun()&#123;\n    let &#123; info &#125; = this.props\n&#125;\n\nPropsCheck.propTypes = &#123;\n    info: PropTypes.string  // 必须为字符串\n&#125;\n\nPropsCheck.defaultProps = &#123;\n    info: &#39;默认值&#39;  // 默认值\n&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><pre><code>React tools // 浏览器插件\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React基础02\"><a href=\"#React基础02\" class=\"headerlink\" title=\"React基础02\"></a>React基础02</h1><h2 id=\"脚手架-项目创建\"><a href=\"#脚手架-项目创建\" class=\"headerlink\" title=\"脚手架-项目创建\"></a>脚手架-项目创建</h2><pre><code class=\"js\">1.创建命令 \nnpx create-react-app 项目名 \n// npx 如果本地有这个模块就使用，如果没用就下载\n</code></pre>\n<h3 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h3><pre><code class=\"js\">src下的文件都可删除,只保留核心\n可以看脚手架官方文档\ncomponents // 组件目录 \n  创建函数组件或类组件可以导入到App\n  \nreact中的逻辑业务和样式是分开写的\n全局样式放在 style 目录下，叫index.css\n组件样式和组件同名同级，需要导入 \n</code></pre>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><pre><code class=\"js\">在jsx中使用map\n&#123;\n    arr.map((v,i)=&gt;(\n        &lt;li key=&#123;i&#125; onClick=&#123;()=&gt;&#123; this.fun() &#125;&#125;&gt; &#123;v&#125; &lt;/li&gt;\n    ))\n&#125;\n</code></pre>\n<h2 id=\"react通讯\"><a href=\"#react通讯\" class=\"headerlink\" title=\"react通讯\"></a>react通讯</h2><blockquote>\n<p>不像vue，必须提前声明，而react不需要提前声明,和vue一样是单向数据流，可读不可修改</p>\n</blockquote>\n<h3 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h3><pre><code class=\"js\">\n1.函数组件传参数\n&lt;Fun msg=&quot;参数&quot; ... /&gt;\nfunction Fun(props)&#123;\n    \n&#125;\n2.class组件传参\nclass className extends React.Component&#123;\n    \n    constructor(porps)&#123;\n        super(porps)\n        this.porps 可以拿到\n    &#125;\n    render()&#123;\n        let &#123;参数1，...&#125; = this.props\n    &#125;\n&#125;\nexport default className\n</code></pre>\n<h4 id=\"传递函数\"><a href=\"#传递函数\" class=\"headerlink\" title=\"传递函数\"></a>传递函数</h4><pre><code class=\"js\">直接传递\nfun()&#123;\n    \n&#125;\n\n&lt;ProFun hanlder=&#123;this.fun&#125;/&gt;\n    \n    \n获取：\nclass className extends React.component&#123;\n    render () &#123;\n        \n        return (\n            this.props.hanlder() 直接调用\n        )\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h3><pre><code class=\"js\">通过调用父组件函数传递参数\n\nfather:\nfaterFun = (newInfo) =&gt; &#123;\n    this.setState(&#123;\n        info: newInfo\n    &#125;)\n&#125;\n\nreder()&#123;\n    return ( \n        &lt;Profun info=&#123;info&#125; changeInfo=&#123;this.faterFun&#125; /&gt;\n    )\n&#125;\n\n\nson:\n\nclass ProFun extends React.component &#123;\n    render()&#123;\n        let &#123; info &#125; = this.props\n        let &#123; changeInfo &#125; = this.props\n        return (\n            &lt;div&gt;\n                &lt;input onClick=&#123;changInfo(&#39;传递的参数&#39;)&#125;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;\n\n提示：\n如果不需要有自己的数据状态，那么用函数组件较好\n需要保存自己的状态就用类组件\n和vue一样，数据源更新，子组件数据也会改变\n</code></pre>\n<h3 id=\"数据传递限制\"><a href=\"#数据传递限制\" class=\"headerlink\" title=\"数据传递限制\"></a>数据传递限制</h3><ul>\n<li><p><strong>PropTypes</strong> :类型校验即默认值</p>\n<pre><code class=\"js\">1.下载导入包\n  npm i prop-types\n  import PropTypes from &#39;prop-types&#39;\n2.校验\nfunction sonFun()&#123;\n    let &#123; info &#125; = this.props\n&#125;\n\nPropsCheck.propTypes = &#123;\n    info: PropTypes.string  // 必须为字符串\n&#125;\n\nPropsCheck.defaultProps = &#123;\n    info: &#39;默认值&#39;  // 默认值\n&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><pre><code>React tools // 浏览器插件\n</code></pre>\n"},{"title":"react基础","date":"2020-08-20T13:34:23.000Z","_content":"# React基础\n\n## 基础\n\n### 基本步骤\n\n```js\n1.下载并导入react\nimport React from 'react' // 创建虚拟dom\nimport ReactDom from 'react-dom' // 将虚拟dom渲染到页面中的\n\n2.创建虚拟dom\nconst div = react.createElement('div',{ id:'xx' },'内容')\n\n3.调用render函数渲染\nReactDom.render(div,document.getElementById('app'))\n```\n\n### JSX语法\n\n> 在js中，混合写入类似于html的语法，叫做JSX语法，严格遵守XML规范的js，它的html语法最后都会被转换为react.createElement的。\n\n#### 使用\n\n```js\n1.安装\ncnpm i babel-core babel-loader babel-plugin-transform-runtime -D\ncnpm i babel-preset-env babel-preset-stage-0 babel-preset-react -D\n\n2.配置webpack配置\n    module: {\n        rules: [\n            { test: /\\.js|jsx$/, use: 'babel-loader', exclude:'/node_modules/' }\n        ]\n    }\n3.添加.babelrc配置文件\n{\n    \"presets\": [\n        \"env\",\n        \"stage-0\",\n        \"react\"\n    ],\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n}\n```\n\n#### 语法\n\n```js\n1.渲染\n<div>{ a }<div> // 在jsx中使用变量\n<div>{ a + 2 }<div> // 可以在花括号内放插值表达式或者计算\n<div>{ arr }<div> // 渲染数组\n2.类名\nclassName=\"class\"\n<label htmlFor='o'></label>\n```\n\n### 组件\n\n#### 语法\n\n```js\n1.构造函数形式\nfunction Component(props){ // 以形参的形式接受name\n    props.name // 接收到了属性\n    return <div>hello</div> \n   // 必须要加return,必须return一个合法的虚拟dom,null表示什么都不渲染\n}\n\n// 组件名称首字母必须大写\n<Hello name='小白'></Hello>\n```\n\n#### 抽离组件\n\n+ **第一种(构造函数)**\n\n  ```js\n  1.在src下面创建components文件\n  \n  2.使用export default Hello // 把组件暴露出去\n  \n  3.导入\n   import Hello from './from/Hello.jsx' // 不配置的话必须加.jsx后缀\n  ```\n\n+ **第二种(class)**\n\n  ```js\n  1.创建一个类\n  class ClassName extends React.Component\n      // 组件继承了 React.Component 这个父类。\n      constructor(){\n          super()\n          this.state = { // 相当于vue中组件的data\n              msg: '大家好' // class创建的私有数据\n          }\n      }\n  \n      render(){\n          this.state.msg = 'hh' // 创建的私有数据是可读可写的\n          \n          return <div>\n              { this.props.name }  // 直接使用传递的props参数  \n            </div>\n          \n      }\n  }\n  \n  user = {\n      name:'zs'\n  }\n  \n  // 传参\n  <ClassName ...user></ClassName>\n  ```\n\n  + 注意\n    1. 无论是那种方式他们的props都只是可读的，使用class创建的组件是有状态的，有自己的私有数据和生命周期函数。\n    \n    2. React官网说，无状态组件，由于没有私有属性和生命周期，所以运行效率比有状态组件稍微高。\n    \n\n### 样式\n\n```js\n1.下载css-loder和style-loder两个包\n2.在webpack配置中配置\n\t{ test: /\\.css$/,use: ['style-loder','css-loder']}\n3.在组件中导入\n  import css from '/css'\n\n4.使用\n  className={ css.xx } // css模块化了\n```\n\n\n\n### 事件\n\n```js\n1.绑定\nhh =(a) => {\ta }\nonClick={ ()=>{ this.hh(1) } }\n\n```\n\n### 受控组件\n\n```js\n1.value绑定上state中的值后，通过onchange事件获取state中最新的值\n\n注意：React中的 onchange事件在内部是做了处理的，和原生事件不同不是失去焦点触发\n\nstate = {\n    inputValue: '文字'\n}\nchangeHandler = (e) =>{\n    e\n    this.setState = ({\n        inputValue: e.target.value\n    })\n}\nrender() {\n    let { inputValue } = this.state\n    return (\n    \t<div>\n        \t<h2>受控组件</h2>\n        \t<input type=\"text\" value={ inputValue } onChange={ this.changeHandler } />\n        </div>\n    )\n}\n\n\n多个值受控,相当于多个双向绑定\n1.利用name动态更新值\n\nchangeHandler = (e) =>{\n    this.setState({\n        [e.target.name]:e.target.value  // 属性表达式写法，[]中可以写表达式\n    })\n}\n\n<input type=\"text\" name={inputValue} value={ inputValue } onChange={ this.changeHandler } />\n<input type=\"text\" name={inputValue2} value={ inputValue2 } onChange={ this.changeHandler } />\n```\n\n\n\n### 修改state中的值\n\n```js\nthis.setState({ msg: '123' },function(){ })\n* setState是异步代码，如果调用之后想立即使用改变的值那么需要在回调中操作\n```\n\n\n\n ## 生命周期\n\n> 基本上每个框架都会有生命周期，是框架提供给开发者，让开发者在特定的时间注册自定义逻辑，本质上是回调函数\n\n```js\n* 挂载阶段\n\t1. 初始化 state 数据 constructor\n    2. 初次渲染视图执行 render\n    3. 加载完成后执行的钩子函数 componentDidMount()\n* 更新阶段\n\t1. 重新渲染视图 render\n    2. 更新渲染完毕后执行的钩子函数 componentDidUpdate() \n* 卸载阶段\n\t1. 卸载完成之前执行的钩子函数 componentWillUnmount()\n```\n\n\n\n\n\n## 插件\n\n```\n极简插件\n```\n\n","source":"_posts/笔记/ocean/15-react/01/00-note.md","raw":"---\ntitle: react基础\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- react\n---\n# React基础\n\n## 基础\n\n### 基本步骤\n\n```js\n1.下载并导入react\nimport React from 'react' // 创建虚拟dom\nimport ReactDom from 'react-dom' // 将虚拟dom渲染到页面中的\n\n2.创建虚拟dom\nconst div = react.createElement('div',{ id:'xx' },'内容')\n\n3.调用render函数渲染\nReactDom.render(div,document.getElementById('app'))\n```\n\n### JSX语法\n\n> 在js中，混合写入类似于html的语法，叫做JSX语法，严格遵守XML规范的js，它的html语法最后都会被转换为react.createElement的。\n\n#### 使用\n\n```js\n1.安装\ncnpm i babel-core babel-loader babel-plugin-transform-runtime -D\ncnpm i babel-preset-env babel-preset-stage-0 babel-preset-react -D\n\n2.配置webpack配置\n    module: {\n        rules: [\n            { test: /\\.js|jsx$/, use: 'babel-loader', exclude:'/node_modules/' }\n        ]\n    }\n3.添加.babelrc配置文件\n{\n    \"presets\": [\n        \"env\",\n        \"stage-0\",\n        \"react\"\n    ],\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n}\n```\n\n#### 语法\n\n```js\n1.渲染\n<div>{ a }<div> // 在jsx中使用变量\n<div>{ a + 2 }<div> // 可以在花括号内放插值表达式或者计算\n<div>{ arr }<div> // 渲染数组\n2.类名\nclassName=\"class\"\n<label htmlFor='o'></label>\n```\n\n### 组件\n\n#### 语法\n\n```js\n1.构造函数形式\nfunction Component(props){ // 以形参的形式接受name\n    props.name // 接收到了属性\n    return <div>hello</div> \n   // 必须要加return,必须return一个合法的虚拟dom,null表示什么都不渲染\n}\n\n// 组件名称首字母必须大写\n<Hello name='小白'></Hello>\n```\n\n#### 抽离组件\n\n+ **第一种(构造函数)**\n\n  ```js\n  1.在src下面创建components文件\n  \n  2.使用export default Hello // 把组件暴露出去\n  \n  3.导入\n   import Hello from './from/Hello.jsx' // 不配置的话必须加.jsx后缀\n  ```\n\n+ **第二种(class)**\n\n  ```js\n  1.创建一个类\n  class ClassName extends React.Component\n      // 组件继承了 React.Component 这个父类。\n      constructor(){\n          super()\n          this.state = { // 相当于vue中组件的data\n              msg: '大家好' // class创建的私有数据\n          }\n      }\n  \n      render(){\n          this.state.msg = 'hh' // 创建的私有数据是可读可写的\n          \n          return <div>\n              { this.props.name }  // 直接使用传递的props参数  \n            </div>\n          \n      }\n  }\n  \n  user = {\n      name:'zs'\n  }\n  \n  // 传参\n  <ClassName ...user></ClassName>\n  ```\n\n  + 注意\n    1. 无论是那种方式他们的props都只是可读的，使用class创建的组件是有状态的，有自己的私有数据和生命周期函数。\n    \n    2. React官网说，无状态组件，由于没有私有属性和生命周期，所以运行效率比有状态组件稍微高。\n    \n\n### 样式\n\n```js\n1.下载css-loder和style-loder两个包\n2.在webpack配置中配置\n\t{ test: /\\.css$/,use: ['style-loder','css-loder']}\n3.在组件中导入\n  import css from '/css'\n\n4.使用\n  className={ css.xx } // css模块化了\n```\n\n\n\n### 事件\n\n```js\n1.绑定\nhh =(a) => {\ta }\nonClick={ ()=>{ this.hh(1) } }\n\n```\n\n### 受控组件\n\n```js\n1.value绑定上state中的值后，通过onchange事件获取state中最新的值\n\n注意：React中的 onchange事件在内部是做了处理的，和原生事件不同不是失去焦点触发\n\nstate = {\n    inputValue: '文字'\n}\nchangeHandler = (e) =>{\n    e\n    this.setState = ({\n        inputValue: e.target.value\n    })\n}\nrender() {\n    let { inputValue } = this.state\n    return (\n    \t<div>\n        \t<h2>受控组件</h2>\n        \t<input type=\"text\" value={ inputValue } onChange={ this.changeHandler } />\n        </div>\n    )\n}\n\n\n多个值受控,相当于多个双向绑定\n1.利用name动态更新值\n\nchangeHandler = (e) =>{\n    this.setState({\n        [e.target.name]:e.target.value  // 属性表达式写法，[]中可以写表达式\n    })\n}\n\n<input type=\"text\" name={inputValue} value={ inputValue } onChange={ this.changeHandler } />\n<input type=\"text\" name={inputValue2} value={ inputValue2 } onChange={ this.changeHandler } />\n```\n\n\n\n### 修改state中的值\n\n```js\nthis.setState({ msg: '123' },function(){ })\n* setState是异步代码，如果调用之后想立即使用改变的值那么需要在回调中操作\n```\n\n\n\n ## 生命周期\n\n> 基本上每个框架都会有生命周期，是框架提供给开发者，让开发者在特定的时间注册自定义逻辑，本质上是回调函数\n\n```js\n* 挂载阶段\n\t1. 初始化 state 数据 constructor\n    2. 初次渲染视图执行 render\n    3. 加载完成后执行的钩子函数 componentDidMount()\n* 更新阶段\n\t1. 重新渲染视图 render\n    2. 更新渲染完毕后执行的钩子函数 componentDidUpdate() \n* 卸载阶段\n\t1. 卸载完成之前执行的钩子函数 componentWillUnmount()\n```\n\n\n\n\n\n## 插件\n\n```\n极简插件\n```\n\n","slug":"笔记/ocean/15-react/01/00-note","published":1,"updated":"2023-03-01T07:30:13.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qeb00b6awaf2kgr1ie7","content":"<h1 id=\"React基础\"><a href=\"#React基础\" class=\"headerlink\" title=\"React基础\"></a>React基础</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h3><pre><code class=\"js\">1.下载并导入react\nimport React from &#39;react&#39; // 创建虚拟dom\nimport ReactDom from &#39;react-dom&#39; // 将虚拟dom渲染到页面中的\n\n2.创建虚拟dom\nconst div = react.createElement(&#39;div&#39;,&#123; id:&#39;xx&#39; &#125;,&#39;内容&#39;)\n\n3.调用render函数渲染\nReactDom.render(div,document.getElementById(&#39;app&#39;))\n</code></pre>\n<h3 id=\"JSX语法\"><a href=\"#JSX语法\" class=\"headerlink\" title=\"JSX语法\"></a>JSX语法</h3><blockquote>\n<p>在js中，混合写入类似于html的语法，叫做JSX语法，严格遵守XML规范的js，它的html语法最后都会被转换为react.createElement的。</p>\n</blockquote>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"js\">1.安装\ncnpm i babel-core babel-loader babel-plugin-transform-runtime -D\ncnpm i babel-preset-env babel-preset-stage-0 babel-preset-react -D\n\n2.配置webpack配置\n    module: &#123;\n        rules: [\n            &#123; test: /\\.js|jsx$/, use: &#39;babel-loader&#39;, exclude:&#39;/node_modules/&#39; &#125;\n        ]\n    &#125;\n3.添加.babelrc配置文件\n&#123;\n    &quot;presets&quot;: [\n        &quot;env&quot;,\n        &quot;stage-0&quot;,\n        &quot;react&quot;\n    ],\n    &quot;plugins&quot;: [\n        &quot;transform-runtime&quot;\n    ]\n&#125;\n</code></pre>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"js\">1.渲染\n&lt;div&gt;&#123; a &#125;&lt;div&gt; // 在jsx中使用变量\n&lt;div&gt;&#123; a + 2 &#125;&lt;div&gt; // 可以在花括号内放插值表达式或者计算\n&lt;div&gt;&#123; arr &#125;&lt;div&gt; // 渲染数组\n2.类名\nclassName=&quot;class&quot;\n&lt;label htmlFor=&#39;o&#39;&gt;&lt;/label&gt;\n</code></pre>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"js\">1.构造函数形式\nfunction Component(props)&#123; // 以形参的形式接受name\n    props.name // 接收到了属性\n    return &lt;div&gt;hello&lt;/div&gt; \n   // 必须要加return,必须return一个合法的虚拟dom,null表示什么都不渲染\n&#125;\n\n// 组件名称首字母必须大写\n&lt;Hello name=&#39;小白&#39;&gt;&lt;/Hello&gt;\n</code></pre>\n<h4 id=\"抽离组件\"><a href=\"#抽离组件\" class=\"headerlink\" title=\"抽离组件\"></a>抽离组件</h4><ul>\n<li><p><strong>第一种(构造函数)</strong></p>\n<pre><code class=\"js\">1.在src下面创建components文件\n\n2.使用export default Hello // 把组件暴露出去\n\n3.导入\n import Hello from &#39;./from/Hello.jsx&#39; // 不配置的话必须加.jsx后缀\n</code></pre>\n</li>\n<li><p><strong>第二种(class)</strong></p>\n<pre><code class=\"js\">1.创建一个类\nclass ClassName extends React.Component\n    // 组件继承了 React.Component 这个父类。\n    constructor()&#123;\n        super()\n        this.state = &#123; // 相当于vue中组件的data\n            msg: &#39;大家好&#39; // class创建的私有数据\n        &#125;\n    &#125;\n\n    render()&#123;\n        this.state.msg = &#39;hh&#39; // 创建的私有数据是可读可写的\n        \n        return &lt;div&gt;\n            &#123; this.props.name &#125;  // 直接使用传递的props参数  \n          &lt;/div&gt;\n        \n    &#125;\n&#125;\n\nuser = &#123;\n    name:&#39;zs&#39;\n&#125;\n\n// 传参\n&lt;ClassName ...user&gt;&lt;/ClassName&gt;\n</code></pre>\n<ul>\n<li>注意<ol>\n<li><p>无论是那种方式他们的props都只是可读的，使用class创建的组件是有状态的，有自己的私有数据和生命周期函数。</p>\n</li>\n<li><p>React官网说，无状态组件，由于没有私有属性和生命周期，所以运行效率比有状态组件稍微高。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><pre><code class=\"js\">1.下载css-loder和style-loder两个包\n2.在webpack配置中配置\n    &#123; test: /\\.css$/,use: [&#39;style-loder&#39;,&#39;css-loder&#39;]&#125;\n3.在组件中导入\n  import css from &#39;/css&#39;\n\n4.使用\n  className=&#123; css.xx &#125; // css模块化了\n</code></pre>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><pre><code class=\"js\">1.绑定\nhh =(a) =&gt; &#123;    a &#125;\nonClick=&#123; ()=&gt;&#123; this.hh(1) &#125; &#125;\n</code></pre>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><pre><code class=\"js\">1.value绑定上state中的值后，通过onchange事件获取state中最新的值\n\n注意：React中的 onchange事件在内部是做了处理的，和原生事件不同不是失去焦点触发\n\nstate = &#123;\n    inputValue: &#39;文字&#39;\n&#125;\nchangeHandler = (e) =&gt;&#123;\n    e\n    this.setState = (&#123;\n        inputValue: e.target.value\n    &#125;)\n&#125;\nrender() &#123;\n    let &#123; inputValue &#125; = this.state\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;受控组件&lt;/h2&gt;\n            &lt;input type=&quot;text&quot; value=&#123; inputValue &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n        &lt;/div&gt;\n    )\n&#125;\n\n\n多个值受控,相当于多个双向绑定\n1.利用name动态更新值\n\nchangeHandler = (e) =&gt;&#123;\n    this.setState(&#123;\n        [e.target.name]:e.target.value  // 属性表达式写法，[]中可以写表达式\n    &#125;)\n&#125;\n\n&lt;input type=&quot;text&quot; name=&#123;inputValue&#125; value=&#123; inputValue &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n&lt;input type=&quot;text&quot; name=&#123;inputValue2&#125; value=&#123; inputValue2 &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n</code></pre>\n<h3 id=\"修改state中的值\"><a href=\"#修改state中的值\" class=\"headerlink\" title=\"修改state中的值\"></a>修改state中的值</h3><pre><code class=\"js\">this.setState(&#123; msg: &#39;123&#39; &#125;,function()&#123; &#125;)\n* setState是异步代码，如果调用之后想立即使用改变的值那么需要在回调中操作\n</code></pre>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><blockquote>\n<p>基本上每个框架都会有生命周期，是框架提供给开发者，让开发者在特定的时间注册自定义逻辑，本质上是回调函数</p>\n</blockquote>\n<pre><code class=\"js\">* 挂载阶段\n    1. 初始化 state 数据 constructor\n    2. 初次渲染视图执行 render\n    3. 加载完成后执行的钩子函数 componentDidMount()\n* 更新阶段\n    1. 重新渲染视图 render\n    2. 更新渲染完毕后执行的钩子函数 componentDidUpdate() \n* 卸载阶段\n    1. 卸载完成之前执行的钩子函数 componentWillUnmount()\n</code></pre>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><pre><code>极简插件\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React基础\"><a href=\"#React基础\" class=\"headerlink\" title=\"React基础\"></a>React基础</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h3><pre><code class=\"js\">1.下载并导入react\nimport React from &#39;react&#39; // 创建虚拟dom\nimport ReactDom from &#39;react-dom&#39; // 将虚拟dom渲染到页面中的\n\n2.创建虚拟dom\nconst div = react.createElement(&#39;div&#39;,&#123; id:&#39;xx&#39; &#125;,&#39;内容&#39;)\n\n3.调用render函数渲染\nReactDom.render(div,document.getElementById(&#39;app&#39;))\n</code></pre>\n<h3 id=\"JSX语法\"><a href=\"#JSX语法\" class=\"headerlink\" title=\"JSX语法\"></a>JSX语法</h3><blockquote>\n<p>在js中，混合写入类似于html的语法，叫做JSX语法，严格遵守XML规范的js，它的html语法最后都会被转换为react.createElement的。</p>\n</blockquote>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"js\">1.安装\ncnpm i babel-core babel-loader babel-plugin-transform-runtime -D\ncnpm i babel-preset-env babel-preset-stage-0 babel-preset-react -D\n\n2.配置webpack配置\n    module: &#123;\n        rules: [\n            &#123; test: /\\.js|jsx$/, use: &#39;babel-loader&#39;, exclude:&#39;/node_modules/&#39; &#125;\n        ]\n    &#125;\n3.添加.babelrc配置文件\n&#123;\n    &quot;presets&quot;: [\n        &quot;env&quot;,\n        &quot;stage-0&quot;,\n        &quot;react&quot;\n    ],\n    &quot;plugins&quot;: [\n        &quot;transform-runtime&quot;\n    ]\n&#125;\n</code></pre>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"js\">1.渲染\n&lt;div&gt;&#123; a &#125;&lt;div&gt; // 在jsx中使用变量\n&lt;div&gt;&#123; a + 2 &#125;&lt;div&gt; // 可以在花括号内放插值表达式或者计算\n&lt;div&gt;&#123; arr &#125;&lt;div&gt; // 渲染数组\n2.类名\nclassName=&quot;class&quot;\n&lt;label htmlFor=&#39;o&#39;&gt;&lt;/label&gt;\n</code></pre>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"js\">1.构造函数形式\nfunction Component(props)&#123; // 以形参的形式接受name\n    props.name // 接收到了属性\n    return &lt;div&gt;hello&lt;/div&gt; \n   // 必须要加return,必须return一个合法的虚拟dom,null表示什么都不渲染\n&#125;\n\n// 组件名称首字母必须大写\n&lt;Hello name=&#39;小白&#39;&gt;&lt;/Hello&gt;\n</code></pre>\n<h4 id=\"抽离组件\"><a href=\"#抽离组件\" class=\"headerlink\" title=\"抽离组件\"></a>抽离组件</h4><ul>\n<li><p><strong>第一种(构造函数)</strong></p>\n<pre><code class=\"js\">1.在src下面创建components文件\n\n2.使用export default Hello // 把组件暴露出去\n\n3.导入\n import Hello from &#39;./from/Hello.jsx&#39; // 不配置的话必须加.jsx后缀\n</code></pre>\n</li>\n<li><p><strong>第二种(class)</strong></p>\n<pre><code class=\"js\">1.创建一个类\nclass ClassName extends React.Component\n    // 组件继承了 React.Component 这个父类。\n    constructor()&#123;\n        super()\n        this.state = &#123; // 相当于vue中组件的data\n            msg: &#39;大家好&#39; // class创建的私有数据\n        &#125;\n    &#125;\n\n    render()&#123;\n        this.state.msg = &#39;hh&#39; // 创建的私有数据是可读可写的\n        \n        return &lt;div&gt;\n            &#123; this.props.name &#125;  // 直接使用传递的props参数  \n          &lt;/div&gt;\n        \n    &#125;\n&#125;\n\nuser = &#123;\n    name:&#39;zs&#39;\n&#125;\n\n// 传参\n&lt;ClassName ...user&gt;&lt;/ClassName&gt;\n</code></pre>\n<ul>\n<li>注意<ol>\n<li><p>无论是那种方式他们的props都只是可读的，使用class创建的组件是有状态的，有自己的私有数据和生命周期函数。</p>\n</li>\n<li><p>React官网说，无状态组件，由于没有私有属性和生命周期，所以运行效率比有状态组件稍微高。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><pre><code class=\"js\">1.下载css-loder和style-loder两个包\n2.在webpack配置中配置\n    &#123; test: /\\.css$/,use: [&#39;style-loder&#39;,&#39;css-loder&#39;]&#125;\n3.在组件中导入\n  import css from &#39;/css&#39;\n\n4.使用\n  className=&#123; css.xx &#125; // css模块化了\n</code></pre>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><pre><code class=\"js\">1.绑定\nhh =(a) =&gt; &#123;    a &#125;\nonClick=&#123; ()=&gt;&#123; this.hh(1) &#125; &#125;\n</code></pre>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><pre><code class=\"js\">1.value绑定上state中的值后，通过onchange事件获取state中最新的值\n\n注意：React中的 onchange事件在内部是做了处理的，和原生事件不同不是失去焦点触发\n\nstate = &#123;\n    inputValue: &#39;文字&#39;\n&#125;\nchangeHandler = (e) =&gt;&#123;\n    e\n    this.setState = (&#123;\n        inputValue: e.target.value\n    &#125;)\n&#125;\nrender() &#123;\n    let &#123; inputValue &#125; = this.state\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;受控组件&lt;/h2&gt;\n            &lt;input type=&quot;text&quot; value=&#123; inputValue &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n        &lt;/div&gt;\n    )\n&#125;\n\n\n多个值受控,相当于多个双向绑定\n1.利用name动态更新值\n\nchangeHandler = (e) =&gt;&#123;\n    this.setState(&#123;\n        [e.target.name]:e.target.value  // 属性表达式写法，[]中可以写表达式\n    &#125;)\n&#125;\n\n&lt;input type=&quot;text&quot; name=&#123;inputValue&#125; value=&#123; inputValue &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n&lt;input type=&quot;text&quot; name=&#123;inputValue2&#125; value=&#123; inputValue2 &#125; onChange=&#123; this.changeHandler &#125; /&gt;\n</code></pre>\n<h3 id=\"修改state中的值\"><a href=\"#修改state中的值\" class=\"headerlink\" title=\"修改state中的值\"></a>修改state中的值</h3><pre><code class=\"js\">this.setState(&#123; msg: &#39;123&#39; &#125;,function()&#123; &#125;)\n* setState是异步代码，如果调用之后想立即使用改变的值那么需要在回调中操作\n</code></pre>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><blockquote>\n<p>基本上每个框架都会有生命周期，是框架提供给开发者，让开发者在特定的时间注册自定义逻辑，本质上是回调函数</p>\n</blockquote>\n<pre><code class=\"js\">* 挂载阶段\n    1. 初始化 state 数据 constructor\n    2. 初次渲染视图执行 render\n    3. 加载完成后执行的钩子函数 componentDidMount()\n* 更新阶段\n    1. 重新渲染视图 render\n    2. 更新渲染完毕后执行的钩子函数 componentDidUpdate() \n* 卸载阶段\n    1. 卸载完成之前执行的钩子函数 componentWillUnmount()\n</code></pre>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><pre><code>极简插件\n</code></pre>\n"},{"title":"react基础03-通信","date":"2020-08-20T13:34:23.000Z","_content":"\n# React-03\n\n### this的指向\n\n```js\n1. 在jsx中直接用this \n2. 声明函数时用箭头函数声明\n3. 在事件中使用箭头函数 {()=>{ Fun() }}\n```\n\n### 非受控组件\n\n> 和 vue 中的 ref 类似，可以直接获取 dom \n\n+ 如果不需要双向绑定，但是需要取值使用 __React.creatRef()__\n\n  ```js\n  1. 在constructor里调用 React.creatRef() 方法获取返回值\n  2. 把返回的内容保存到实例属性中\n  3. render 方法中把上一步的属性赋值给ref\n  4. 就可以在方法中通过这个属性获取到dom\n  ```\n\n\n\n## 组件通信\n\n### 兄弟组件通信\n\n> 两个平级组件就称兄弟组件\n\n+ **步骤**\n  1. 提升：把共享的数据提取到他们公共的父组件中\n  2. 共享：谁使用数据就传给谁，谁修改数据通过调用函数修改\n\n```js\n* 父组件\nchangeInfo = (newInfo) =>{ \n    this.setState = {\n        fatherInfo: newInfo // 修改之后，数据会重新向下更新\n    }\n}\n\n\n<chilerA info={this.state.fatherInfo} /> // 传入数据通过 props 接收\n<chilerB changeIninfo={this.state.fatherInfo} /> // 修改数据，子组件调用函数修改\n    \n    \n* B子组件\nthis.props.changeInfo(\"修改值\") // 调用函数修改\n```\n\n\n\n### 单标签和双标签\n\n> 类似于vue的插槽,但是React是可以传递 jsx 格式的数据。\n\n```react\n* 单标签打印为undefeid\n* 双标签可以打印出来值\n\t如果双标签中有jsx标签，那么打印的是一个对象 this.props.chidren\n\n* 可以在属性中传入 jsx 格式，然后在组件中渲染出来\n<SendTems header={ <div>呵呵</div> } />\n<div>{this.props.hader}<div>\n \n* 当然也可以传入组件\n  <SendTems Header={<Arct/>} />\n  <div>{this.props.Header}<div>\n```\n\n### 功能复用\n\n> 外部传入结构到内部组件内，内部可以传递数据到外部结构 \n\n```react\n* 外部结构\n<Render \n    render={\n        (secret) => {\n            return (\n            <div>\n             \t{secret}   \n             </div>\n            )\n        }\n    }\n/>\n\n\n* 内部组件\nstate = {\n    secret: \"呵呵\"\n}\nlet { render } = this.props\nlet { secret } = this.state\n{\n    render(secret)\n}\n```\n\n### 功能复用-RenderProps-children属性 \n\n> 和 render 复用一样，只不过是属性名换为了 children\n\n 英雄联盟接口 :  https://autumnfish.cn/api/lol/search\n\n```react\n* herolist\nrender() {\n        return (\n            <div>\n                <HeroListData render={ (listData) => {\n                    return (\n                        <ul>\n                            {listData.map((v,i)=>{\n                                return <li key={i} >\n                                    <h3>{v.name}</h3>\n                                    <img src={v.icon} alt=\"\"></img>\n                                    <audio src={v.selectAudio} controls></audio>\n                                </li>\n                            })}\n                        </ul>\n                    )\n                }}/>\n            </div>\n        )\n    }\n\n\n* heroListData\n    render() {\n        let { heroListData } = this.state\n        let { render } = this.props\n\n        return (\n            <div>\n                <div onClick={ this.getHeroList }>\n                    <h2>英雄列表</h2>\n                    { render(heroListData) }\n                </div>\n            </div>\n        )\n    }\n```\n\n### HOC-高阶组件\n\n> 相当于用函数把class组件包裹起来，然后在这个函数中将class组件return出去，然后将函数return出去，外部组件声明普通函数，然后传将函数传入进来\n\n```\n1.结构由外部组件函数来定\n2.数据由高阶函数来定\n```\n\n\n\n## 知识点\n\n1. **setState是异步的**\n\n   ```react\n   1. 当调用 this.setState({}) 时，会进行虚拟 dom 的 diff 算法，这个操作是异步的。\n   2. 有第二个参数是一个回调函数，在这个函数中拿到的是最新的值，类似于 vue 中的 nextTick()\n      this.setState({\n          num: num + 1\n      },()=>{ this.state.num })\n   3. 和 vue 一样，在更新虚拟 dom 时，并不会每次调用都会重新渲染真实 dom，它用了 diff 算法，一层一层对比，当虚拟 dom 更新完毕后，才会渲染真实的 dom\n   \n   4.传入函数,可以获取到最新的值，不考虑页面的更新\n   \tthis.setState((state)=>{ return { num:num+1 } })\n   ```\n\n\n\n## 问题\n\n1. 在vscode里单标签和双标签怎么替换生命周期","source":"_posts/笔记/ocean/15-react/03/00-note.md","raw":"---\ntitle: react基础03-通信\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- react\n---\n\n# React-03\n\n### this的指向\n\n```js\n1. 在jsx中直接用this \n2. 声明函数时用箭头函数声明\n3. 在事件中使用箭头函数 {()=>{ Fun() }}\n```\n\n### 非受控组件\n\n> 和 vue 中的 ref 类似，可以直接获取 dom \n\n+ 如果不需要双向绑定，但是需要取值使用 __React.creatRef()__\n\n  ```js\n  1. 在constructor里调用 React.creatRef() 方法获取返回值\n  2. 把返回的内容保存到实例属性中\n  3. render 方法中把上一步的属性赋值给ref\n  4. 就可以在方法中通过这个属性获取到dom\n  ```\n\n\n\n## 组件通信\n\n### 兄弟组件通信\n\n> 两个平级组件就称兄弟组件\n\n+ **步骤**\n  1. 提升：把共享的数据提取到他们公共的父组件中\n  2. 共享：谁使用数据就传给谁，谁修改数据通过调用函数修改\n\n```js\n* 父组件\nchangeInfo = (newInfo) =>{ \n    this.setState = {\n        fatherInfo: newInfo // 修改之后，数据会重新向下更新\n    }\n}\n\n\n<chilerA info={this.state.fatherInfo} /> // 传入数据通过 props 接收\n<chilerB changeIninfo={this.state.fatherInfo} /> // 修改数据，子组件调用函数修改\n    \n    \n* B子组件\nthis.props.changeInfo(\"修改值\") // 调用函数修改\n```\n\n\n\n### 单标签和双标签\n\n> 类似于vue的插槽,但是React是可以传递 jsx 格式的数据。\n\n```react\n* 单标签打印为undefeid\n* 双标签可以打印出来值\n\t如果双标签中有jsx标签，那么打印的是一个对象 this.props.chidren\n\n* 可以在属性中传入 jsx 格式，然后在组件中渲染出来\n<SendTems header={ <div>呵呵</div> } />\n<div>{this.props.hader}<div>\n \n* 当然也可以传入组件\n  <SendTems Header={<Arct/>} />\n  <div>{this.props.Header}<div>\n```\n\n### 功能复用\n\n> 外部传入结构到内部组件内，内部可以传递数据到外部结构 \n\n```react\n* 外部结构\n<Render \n    render={\n        (secret) => {\n            return (\n            <div>\n             \t{secret}   \n             </div>\n            )\n        }\n    }\n/>\n\n\n* 内部组件\nstate = {\n    secret: \"呵呵\"\n}\nlet { render } = this.props\nlet { secret } = this.state\n{\n    render(secret)\n}\n```\n\n### 功能复用-RenderProps-children属性 \n\n> 和 render 复用一样，只不过是属性名换为了 children\n\n 英雄联盟接口 :  https://autumnfish.cn/api/lol/search\n\n```react\n* herolist\nrender() {\n        return (\n            <div>\n                <HeroListData render={ (listData) => {\n                    return (\n                        <ul>\n                            {listData.map((v,i)=>{\n                                return <li key={i} >\n                                    <h3>{v.name}</h3>\n                                    <img src={v.icon} alt=\"\"></img>\n                                    <audio src={v.selectAudio} controls></audio>\n                                </li>\n                            })}\n                        </ul>\n                    )\n                }}/>\n            </div>\n        )\n    }\n\n\n* heroListData\n    render() {\n        let { heroListData } = this.state\n        let { render } = this.props\n\n        return (\n            <div>\n                <div onClick={ this.getHeroList }>\n                    <h2>英雄列表</h2>\n                    { render(heroListData) }\n                </div>\n            </div>\n        )\n    }\n```\n\n### HOC-高阶组件\n\n> 相当于用函数把class组件包裹起来，然后在这个函数中将class组件return出去，然后将函数return出去，外部组件声明普通函数，然后传将函数传入进来\n\n```\n1.结构由外部组件函数来定\n2.数据由高阶函数来定\n```\n\n\n\n## 知识点\n\n1. **setState是异步的**\n\n   ```react\n   1. 当调用 this.setState({}) 时，会进行虚拟 dom 的 diff 算法，这个操作是异步的。\n   2. 有第二个参数是一个回调函数，在这个函数中拿到的是最新的值，类似于 vue 中的 nextTick()\n      this.setState({\n          num: num + 1\n      },()=>{ this.state.num })\n   3. 和 vue 一样，在更新虚拟 dom 时，并不会每次调用都会重新渲染真实 dom，它用了 diff 算法，一层一层对比，当虚拟 dom 更新完毕后，才会渲染真实的 dom\n   \n   4.传入函数,可以获取到最新的值，不考虑页面的更新\n   \tthis.setState((state)=>{ return { num:num+1 } })\n   ```\n\n\n\n## 问题\n\n1. 在vscode里单标签和双标签怎么替换生命周期","slug":"笔记/ocean/15-react/03/00-note","published":1,"updated":"2023-03-01T07:30:41.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qec00baawafe8zh13v4","content":"<h1 id=\"React-03\"><a href=\"#React-03\" class=\"headerlink\" title=\"React-03\"></a>React-03</h1><h3 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h3><pre><code class=\"js\">1. 在jsx中直接用this \n2. 声明函数时用箭头函数声明\n3. 在事件中使用箭头函数 &#123;()=&gt;&#123; Fun() &#125;&#125;\n</code></pre>\n<h3 id=\"非受控组件\"><a href=\"#非受控组件\" class=\"headerlink\" title=\"非受控组件\"></a>非受控组件</h3><blockquote>\n<p>和 vue 中的 ref 类似，可以直接获取 dom </p>\n</blockquote>\n<ul>\n<li><p>如果不需要双向绑定，但是需要取值使用 <strong>React.creatRef()</strong></p>\n<pre><code class=\"js\">1. 在constructor里调用 React.creatRef() 方法获取返回值\n2. 把返回的内容保存到实例属性中\n3. render 方法中把上一步的属性赋值给ref\n4. 就可以在方法中通过这个属性获取到dom\n</code></pre>\n</li>\n</ul>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><h3 id=\"兄弟组件通信\"><a href=\"#兄弟组件通信\" class=\"headerlink\" title=\"兄弟组件通信\"></a>兄弟组件通信</h3><blockquote>\n<p>两个平级组件就称兄弟组件</p>\n</blockquote>\n<ul>\n<li><strong>步骤</strong><ol>\n<li>提升：把共享的数据提取到他们公共的父组件中</li>\n<li>共享：谁使用数据就传给谁，谁修改数据通过调用函数修改</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">* 父组件\nchangeInfo = (newInfo) =&gt;&#123; \n    this.setState = &#123;\n        fatherInfo: newInfo // 修改之后，数据会重新向下更新\n    &#125;\n&#125;\n\n\n&lt;chilerA info=&#123;this.state.fatherInfo&#125; /&gt; // 传入数据通过 props 接收\n&lt;chilerB changeIninfo=&#123;this.state.fatherInfo&#125; /&gt; // 修改数据，子组件调用函数修改\n    \n    \n* B子组件\nthis.props.changeInfo(&quot;修改值&quot;) // 调用函数修改\n</code></pre>\n<h3 id=\"单标签和双标签\"><a href=\"#单标签和双标签\" class=\"headerlink\" title=\"单标签和双标签\"></a>单标签和双标签</h3><blockquote>\n<p>类似于vue的插槽,但是React是可以传递 jsx 格式的数据。</p>\n</blockquote>\n<pre><code class=\"react\">* 单标签打印为undefeid\n* 双标签可以打印出来值\n    如果双标签中有jsx标签，那么打印的是一个对象 this.props.chidren\n\n* 可以在属性中传入 jsx 格式，然后在组件中渲染出来\n&lt;SendTems header=&#123; &lt;div&gt;呵呵&lt;/div&gt; &#125; /&gt;\n&lt;div&gt;&#123;this.props.hader&#125;&lt;div&gt;\n \n* 当然也可以传入组件\n  &lt;SendTems Header=&#123;&lt;Arct/&gt;&#125; /&gt;\n  &lt;div&gt;&#123;this.props.Header&#125;&lt;div&gt;\n</code></pre>\n<h3 id=\"功能复用\"><a href=\"#功能复用\" class=\"headerlink\" title=\"功能复用\"></a>功能复用</h3><blockquote>\n<p>外部传入结构到内部组件内，内部可以传递数据到外部结构 </p>\n</blockquote>\n<pre><code class=\"react\">* 外部结构\n&lt;Render \n    render=&#123;\n        (secret) =&gt; &#123;\n            return (\n            &lt;div&gt;\n                 &#123;secret&#125;   \n             &lt;/div&gt;\n            )\n        &#125;\n    &#125;\n/&gt;\n\n\n* 内部组件\nstate = &#123;\n    secret: &quot;呵呵&quot;\n&#125;\nlet &#123; render &#125; = this.props\nlet &#123; secret &#125; = this.state\n&#123;\n    render(secret)\n&#125;\n</code></pre>\n<h3 id=\"功能复用-RenderProps-children属性\"><a href=\"#功能复用-RenderProps-children属性\" class=\"headerlink\" title=\"功能复用-RenderProps-children属性\"></a>功能复用-RenderProps-children属性</h3><blockquote>\n<p>和 render 复用一样，只不过是属性名换为了 children</p>\n</blockquote>\n<p> 英雄联盟接口 :  <a href=\"https://autumnfish.cn/api/lol/search\">https://autumnfish.cn/api/lol/search</a></p>\n<pre><code class=\"react\">* herolist\nrender() &#123;\n        return (\n            &lt;div&gt;\n                &lt;HeroListData render=&#123; (listData) =&gt; &#123;\n                    return (\n                        &lt;ul&gt;\n                            &#123;listData.map((v,i)=&gt;&#123;\n                                return &lt;li key=&#123;i&#125; &gt;\n                                    &lt;h3&gt;&#123;v.name&#125;&lt;/h3&gt;\n                                    &lt;img src=&#123;v.icon&#125; alt=&quot;&quot;&gt;&lt;/img&gt;\n                                    &lt;audio src=&#123;v.selectAudio&#125; controls&gt;&lt;/audio&gt;\n                                &lt;/li&gt;\n                            &#125;)&#125;\n                        &lt;/ul&gt;\n                    )\n                &#125;&#125;/&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n\n\n* heroListData\n    render() &#123;\n        let &#123; heroListData &#125; = this.state\n        let &#123; render &#125; = this.props\n\n        return (\n            &lt;div&gt;\n                &lt;div onClick=&#123; this.getHeroList &#125;&gt;\n                    &lt;h2&gt;英雄列表&lt;/h2&gt;\n                    &#123; render(heroListData) &#125;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n</code></pre>\n<h3 id=\"HOC-高阶组件\"><a href=\"#HOC-高阶组件\" class=\"headerlink\" title=\"HOC-高阶组件\"></a>HOC-高阶组件</h3><blockquote>\n<p>相当于用函数把class组件包裹起来，然后在这个函数中将class组件return出去，然后将函数return出去，外部组件声明普通函数，然后传将函数传入进来</p>\n</blockquote>\n<pre><code>1.结构由外部组件函数来定\n2.数据由高阶函数来定\n</code></pre>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li><p><strong>setState是异步的</strong></p>\n<pre><code class=\"react\">1. 当调用 this.setState(&#123;&#125;) 时，会进行虚拟 dom 的 diff 算法，这个操作是异步的。\n2. 有第二个参数是一个回调函数，在这个函数中拿到的是最新的值，类似于 vue 中的 nextTick()\n   this.setState(&#123;\n       num: num + 1\n   &#125;,()=&gt;&#123; this.state.num &#125;)\n3. 和 vue 一样，在更新虚拟 dom 时，并不会每次调用都会重新渲染真实 dom，它用了 diff 算法，一层一层对比，当虚拟 dom 更新完毕后，才会渲染真实的 dom\n\n4.传入函数,可以获取到最新的值，不考虑页面的更新\n    this.setState((state)=&gt;&#123; return &#123; num:num+1 &#125; &#125;)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>在vscode里单标签和双标签怎么替换生命周期</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-03\"><a href=\"#React-03\" class=\"headerlink\" title=\"React-03\"></a>React-03</h1><h3 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h3><pre><code class=\"js\">1. 在jsx中直接用this \n2. 声明函数时用箭头函数声明\n3. 在事件中使用箭头函数 &#123;()=&gt;&#123; Fun() &#125;&#125;\n</code></pre>\n<h3 id=\"非受控组件\"><a href=\"#非受控组件\" class=\"headerlink\" title=\"非受控组件\"></a>非受控组件</h3><blockquote>\n<p>和 vue 中的 ref 类似，可以直接获取 dom </p>\n</blockquote>\n<ul>\n<li><p>如果不需要双向绑定，但是需要取值使用 <strong>React.creatRef()</strong></p>\n<pre><code class=\"js\">1. 在constructor里调用 React.creatRef() 方法获取返回值\n2. 把返回的内容保存到实例属性中\n3. render 方法中把上一步的属性赋值给ref\n4. 就可以在方法中通过这个属性获取到dom\n</code></pre>\n</li>\n</ul>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><h3 id=\"兄弟组件通信\"><a href=\"#兄弟组件通信\" class=\"headerlink\" title=\"兄弟组件通信\"></a>兄弟组件通信</h3><blockquote>\n<p>两个平级组件就称兄弟组件</p>\n</blockquote>\n<ul>\n<li><strong>步骤</strong><ol>\n<li>提升：把共享的数据提取到他们公共的父组件中</li>\n<li>共享：谁使用数据就传给谁，谁修改数据通过调用函数修改</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">* 父组件\nchangeInfo = (newInfo) =&gt;&#123; \n    this.setState = &#123;\n        fatherInfo: newInfo // 修改之后，数据会重新向下更新\n    &#125;\n&#125;\n\n\n&lt;chilerA info=&#123;this.state.fatherInfo&#125; /&gt; // 传入数据通过 props 接收\n&lt;chilerB changeIninfo=&#123;this.state.fatherInfo&#125; /&gt; // 修改数据，子组件调用函数修改\n    \n    \n* B子组件\nthis.props.changeInfo(&quot;修改值&quot;) // 调用函数修改\n</code></pre>\n<h3 id=\"单标签和双标签\"><a href=\"#单标签和双标签\" class=\"headerlink\" title=\"单标签和双标签\"></a>单标签和双标签</h3><blockquote>\n<p>类似于vue的插槽,但是React是可以传递 jsx 格式的数据。</p>\n</blockquote>\n<pre><code class=\"react\">* 单标签打印为undefeid\n* 双标签可以打印出来值\n    如果双标签中有jsx标签，那么打印的是一个对象 this.props.chidren\n\n* 可以在属性中传入 jsx 格式，然后在组件中渲染出来\n&lt;SendTems header=&#123; &lt;div&gt;呵呵&lt;/div&gt; &#125; /&gt;\n&lt;div&gt;&#123;this.props.hader&#125;&lt;div&gt;\n \n* 当然也可以传入组件\n  &lt;SendTems Header=&#123;&lt;Arct/&gt;&#125; /&gt;\n  &lt;div&gt;&#123;this.props.Header&#125;&lt;div&gt;\n</code></pre>\n<h3 id=\"功能复用\"><a href=\"#功能复用\" class=\"headerlink\" title=\"功能复用\"></a>功能复用</h3><blockquote>\n<p>外部传入结构到内部组件内，内部可以传递数据到外部结构 </p>\n</blockquote>\n<pre><code class=\"react\">* 外部结构\n&lt;Render \n    render=&#123;\n        (secret) =&gt; &#123;\n            return (\n            &lt;div&gt;\n                 &#123;secret&#125;   \n             &lt;/div&gt;\n            )\n        &#125;\n    &#125;\n/&gt;\n\n\n* 内部组件\nstate = &#123;\n    secret: &quot;呵呵&quot;\n&#125;\nlet &#123; render &#125; = this.props\nlet &#123; secret &#125; = this.state\n&#123;\n    render(secret)\n&#125;\n</code></pre>\n<h3 id=\"功能复用-RenderProps-children属性\"><a href=\"#功能复用-RenderProps-children属性\" class=\"headerlink\" title=\"功能复用-RenderProps-children属性\"></a>功能复用-RenderProps-children属性</h3><blockquote>\n<p>和 render 复用一样，只不过是属性名换为了 children</p>\n</blockquote>\n<p> 英雄联盟接口 :  <a href=\"https://autumnfish.cn/api/lol/search\">https://autumnfish.cn/api/lol/search</a></p>\n<pre><code class=\"react\">* herolist\nrender() &#123;\n        return (\n            &lt;div&gt;\n                &lt;HeroListData render=&#123; (listData) =&gt; &#123;\n                    return (\n                        &lt;ul&gt;\n                            &#123;listData.map((v,i)=&gt;&#123;\n                                return &lt;li key=&#123;i&#125; &gt;\n                                    &lt;h3&gt;&#123;v.name&#125;&lt;/h3&gt;\n                                    &lt;img src=&#123;v.icon&#125; alt=&quot;&quot;&gt;&lt;/img&gt;\n                                    &lt;audio src=&#123;v.selectAudio&#125; controls&gt;&lt;/audio&gt;\n                                &lt;/li&gt;\n                            &#125;)&#125;\n                        &lt;/ul&gt;\n                    )\n                &#125;&#125;/&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n\n\n* heroListData\n    render() &#123;\n        let &#123; heroListData &#125; = this.state\n        let &#123; render &#125; = this.props\n\n        return (\n            &lt;div&gt;\n                &lt;div onClick=&#123; this.getHeroList &#125;&gt;\n                    &lt;h2&gt;英雄列表&lt;/h2&gt;\n                    &#123; render(heroListData) &#125;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n</code></pre>\n<h3 id=\"HOC-高阶组件\"><a href=\"#HOC-高阶组件\" class=\"headerlink\" title=\"HOC-高阶组件\"></a>HOC-高阶组件</h3><blockquote>\n<p>相当于用函数把class组件包裹起来，然后在这个函数中将class组件return出去，然后将函数return出去，外部组件声明普通函数，然后传将函数传入进来</p>\n</blockquote>\n<pre><code>1.结构由外部组件函数来定\n2.数据由高阶函数来定\n</code></pre>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li><p><strong>setState是异步的</strong></p>\n<pre><code class=\"react\">1. 当调用 this.setState(&#123;&#125;) 时，会进行虚拟 dom 的 diff 算法，这个操作是异步的。\n2. 有第二个参数是一个回调函数，在这个函数中拿到的是最新的值，类似于 vue 中的 nextTick()\n   this.setState(&#123;\n       num: num + 1\n   &#125;,()=&gt;&#123; this.state.num &#125;)\n3. 和 vue 一样，在更新虚拟 dom 时，并不会每次调用都会重新渲染真实 dom，它用了 diff 算法，一层一层对比，当虚拟 dom 更新完毕后，才会渲染真实的 dom\n\n4.传入函数,可以获取到最新的值，不考虑页面的更新\n    this.setState((state)=&gt;&#123; return &#123; num:num+1 &#125; &#125;)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>在vscode里单标签和双标签怎么替换生命周期</li>\n</ol>\n"},{"title":"react基础04-路由","date":"2020-08-20T13:34:23.000Z","_content":"\n# React-04\n\n### displayName\n\n```react\n在创建高阶组件的时候会造成重名\n通过 displayName 改变组件名称：\n\t组件变量.displayName = '组件名'\n```\n\n\n\n### React路由\n\n> react中的路由也是一种组件，导入即可使用\n\n```javascript\n1. 安装 npm i react-router-dom\n2. 导入\n  \timport { HashRouter as Router, Route } from 'react-router-dom'\n\tHashRouter: 路由出口\n    Route: 路由路径和对应的组件\n3. 使用\n\tfunction Index(){ //路由组件\n        return {\n            \n        }\n    }\n\t\n\tfunction List(){ //路由组件\n        return {\n            \n        }\n    }\n\n\tfunction Root(){\n        return <div>\n        \t<HashRouter> {/*BrowserRouter  Router */}  \n            \t<Route path=\"/index\" component={Index} />\n            \t<Route path=\"/list\" component={List} />\n            </HashRouter> \n        </div>\n    }\n\t\n\texport default Root\n```\n\n+ __路由模式__\n\n  1. HashRouter ： 带#号\n  2. BrowserRouter : 没有 # 号，利用的是浏览器的 history 属性，推荐\n\n+ __404页面__\n\n  ```javascript\n  需要用 Switch 包裹，只显示一个路由\n   import { HashRouter as Router, Route, Switch } from 'react-router-dom'\n  \n  <HashRouter> {/*BrowserRouter  Router */} \n  \t<Switch>\n          <Route path=\"/index\" component={Index} />\n          <Route path=\"/list\" component={List} />\n          <Route path=\"*\" component={NotFound} /> // 用 * 号\n  \t</Switch>\n  </HashRouter> \n  ```\n\n+ __重定向__\n\n  ```js\n  Redirect\n  \n  import { HashRouter as Router, Route, Redirect } from 'react-router-dom'\n  \n  <HashRouter> {/*BrowserRouter  Router */} \n      <Route path=\"/index\" component={Index} />\n      <Route path=\"/list\" component={List} />\n      <Redirect from=\"/\" to=\"/index\" /> \n  </HashRouter> \n  ```\n\n+ __路由解析过程__\n\n  ```js\n  React 的默认解析模式是模糊匹配，开头相同就匹配，调整为精确匹配即可：exact\n  \n  1. 输入 url 后\n  2. React 解析，获取pathName\n  3. 从上到下解析，只要有一个匹配就进入\n  4. 将重定向改为精确匹配\n  \t<Redirect from=\"/\" to=\"/index\" exact /> \n  ```\n\n\n\n## 导航\n\n### 编程式导航\n\n> 通过 Props 中的 history 对象实现\n\n#### 语法\n\n```react\npush 和 replace\npush：有历史记录\nreplace：无历史记录\n\nprops.history.push()\nprops.history.replace('/index')\n```\n\n### 声明式导航\n\n```js\n1.\nimport { Link } from 'react-route-dom'\n<Link to='/index'>导航</Line> // 选中后不会高亮\n\n2.\nimport { NavLink } from 'react-route-dom'\n<NavLink to='/index' activeClassName=\"actived\">可高亮导航</NavLink> // 可高亮导航\n<NavLink to='/index' activeStyle={{ border:xx }}>自定义样式</NavLink> // 自定义样式\n\n```\n\n## 路由嵌套\n\n> 在官网中没有这个说明，就是在路由中在套一层路由结构，和vue的子组件一样\n\n```js\n*注意： <Router></Router> 要将路由相关的所有组件都包裹起来\n```\n\n### 传递参数\n\n```js\n<Link to=\"/index/11\">跳转带参</Link>\n<Route path='/index:id?' component={ index } /> // 接收,?可选参数\n\nfunction Index(props){\n    props.match.params // 可以拿到传过来的数据\n}\n```\n\n\n\n## 框架\n\n\n\n### antd-mbile \n\n> 和 element-ui类似，它和React绝配生命周期","source":"_posts/笔记/ocean/15-react/04/00-note.md","raw":"---\ntitle: react基础04-路由\ndate: 2020-08-20 21:34:23\ncategories:\n- 笔记\n- 零碎\ntags:\n- 前端\n- react\n---\n\n# React-04\n\n### displayName\n\n```react\n在创建高阶组件的时候会造成重名\n通过 displayName 改变组件名称：\n\t组件变量.displayName = '组件名'\n```\n\n\n\n### React路由\n\n> react中的路由也是一种组件，导入即可使用\n\n```javascript\n1. 安装 npm i react-router-dom\n2. 导入\n  \timport { HashRouter as Router, Route } from 'react-router-dom'\n\tHashRouter: 路由出口\n    Route: 路由路径和对应的组件\n3. 使用\n\tfunction Index(){ //路由组件\n        return {\n            \n        }\n    }\n\t\n\tfunction List(){ //路由组件\n        return {\n            \n        }\n    }\n\n\tfunction Root(){\n        return <div>\n        \t<HashRouter> {/*BrowserRouter  Router */}  \n            \t<Route path=\"/index\" component={Index} />\n            \t<Route path=\"/list\" component={List} />\n            </HashRouter> \n        </div>\n    }\n\t\n\texport default Root\n```\n\n+ __路由模式__\n\n  1. HashRouter ： 带#号\n  2. BrowserRouter : 没有 # 号，利用的是浏览器的 history 属性，推荐\n\n+ __404页面__\n\n  ```javascript\n  需要用 Switch 包裹，只显示一个路由\n   import { HashRouter as Router, Route, Switch } from 'react-router-dom'\n  \n  <HashRouter> {/*BrowserRouter  Router */} \n  \t<Switch>\n          <Route path=\"/index\" component={Index} />\n          <Route path=\"/list\" component={List} />\n          <Route path=\"*\" component={NotFound} /> // 用 * 号\n  \t</Switch>\n  </HashRouter> \n  ```\n\n+ __重定向__\n\n  ```js\n  Redirect\n  \n  import { HashRouter as Router, Route, Redirect } from 'react-router-dom'\n  \n  <HashRouter> {/*BrowserRouter  Router */} \n      <Route path=\"/index\" component={Index} />\n      <Route path=\"/list\" component={List} />\n      <Redirect from=\"/\" to=\"/index\" /> \n  </HashRouter> \n  ```\n\n+ __路由解析过程__\n\n  ```js\n  React 的默认解析模式是模糊匹配，开头相同就匹配，调整为精确匹配即可：exact\n  \n  1. 输入 url 后\n  2. React 解析，获取pathName\n  3. 从上到下解析，只要有一个匹配就进入\n  4. 将重定向改为精确匹配\n  \t<Redirect from=\"/\" to=\"/index\" exact /> \n  ```\n\n\n\n## 导航\n\n### 编程式导航\n\n> 通过 Props 中的 history 对象实现\n\n#### 语法\n\n```react\npush 和 replace\npush：有历史记录\nreplace：无历史记录\n\nprops.history.push()\nprops.history.replace('/index')\n```\n\n### 声明式导航\n\n```js\n1.\nimport { Link } from 'react-route-dom'\n<Link to='/index'>导航</Line> // 选中后不会高亮\n\n2.\nimport { NavLink } from 'react-route-dom'\n<NavLink to='/index' activeClassName=\"actived\">可高亮导航</NavLink> // 可高亮导航\n<NavLink to='/index' activeStyle={{ border:xx }}>自定义样式</NavLink> // 自定义样式\n\n```\n\n## 路由嵌套\n\n> 在官网中没有这个说明，就是在路由中在套一层路由结构，和vue的子组件一样\n\n```js\n*注意： <Router></Router> 要将路由相关的所有组件都包裹起来\n```\n\n### 传递参数\n\n```js\n<Link to=\"/index/11\">跳转带参</Link>\n<Route path='/index:id?' component={ index } /> // 接收,?可选参数\n\nfunction Index(props){\n    props.match.params // 可以拿到传过来的数据\n}\n```\n\n\n\n## 框架\n\n\n\n### antd-mbile \n\n> 和 element-ui类似，它和React绝配生命周期","slug":"笔记/ocean/15-react/04/00-note","published":1,"updated":"2023-03-01T07:31:55.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clepi0qec00bdawafhuptdrm6","content":"<h1 id=\"React-04\"><a href=\"#React-04\" class=\"headerlink\" title=\"React-04\"></a>React-04</h1><h3 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h3><pre><code class=\"react\">在创建高阶组件的时候会造成重名\n通过 displayName 改变组件名称：\n    组件变量.displayName = &#39;组件名&#39;\n</code></pre>\n<h3 id=\"React路由\"><a href=\"#React路由\" class=\"headerlink\" title=\"React路由\"></a>React路由</h3><blockquote>\n<p>react中的路由也是一种组件，导入即可使用</p>\n</blockquote>\n<pre><code class=\"javascript\">1. 安装 npm i react-router-dom\n2. 导入\n      import &#123; HashRouter as Router, Route &#125; from &#39;react-router-dom&#39;\n    HashRouter: 路由出口\n    Route: 路由路径和对应的组件\n3. 使用\n    function Index()&#123; //路由组件\n        return &#123;\n            \n        &#125;\n    &#125;\n    \n    function List()&#123; //路由组件\n        return &#123;\n            \n        &#125;\n    &#125;\n\n    function Root()&#123;\n        return &lt;div&gt;\n            &lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125;  \n                &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n                &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n            &lt;/HashRouter&gt; \n        &lt;/div&gt;\n    &#125;\n    \n    export default Root\n</code></pre>\n<ul>\n<li><p><strong>路由模式</strong></p>\n<ol>\n<li>HashRouter ： 带#号</li>\n<li>BrowserRouter : 没有 # 号，利用的是浏览器的 history 属性，推荐</li>\n</ol>\n</li>\n<li><p><strong>404页面</strong></p>\n<pre><code class=\"javascript\">需要用 Switch 包裹，只显示一个路由\n import &#123; HashRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;\n\n&lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125; \n    &lt;Switch&gt;\n        &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n        &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n        &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; // 用 * 号\n    &lt;/Switch&gt;\n&lt;/HashRouter&gt; \n</code></pre>\n</li>\n<li><p><strong>重定向</strong></p>\n<pre><code class=\"js\">Redirect\n\nimport &#123; HashRouter as Router, Route, Redirect &#125; from &#39;react-router-dom&#39;\n\n&lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125; \n    &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n    &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n    &lt;Redirect from=&quot;/&quot; to=&quot;/index&quot; /&gt; \n&lt;/HashRouter&gt; \n</code></pre>\n</li>\n<li><p><strong>路由解析过程</strong></p>\n<pre><code class=\"js\">React 的默认解析模式是模糊匹配，开头相同就匹配，调整为精确匹配即可：exact\n\n1. 输入 url 后\n2. React 解析，获取pathName\n3. 从上到下解析，只要有一个匹配就进入\n4. 将重定向改为精确匹配\n    &lt;Redirect from=&quot;/&quot; to=&quot;/index&quot; exact /&gt; \n</code></pre>\n</li>\n</ul>\n<h2 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h2><h3 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h3><blockquote>\n<p>通过 Props 中的 history 对象实现</p>\n</blockquote>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"react\">push 和 replace\npush：有历史记录\nreplace：无历史记录\n\nprops.history.push()\nprops.history.replace(&#39;/index&#39;)\n</code></pre>\n<h3 id=\"声明式导航\"><a href=\"#声明式导航\" class=\"headerlink\" title=\"声明式导航\"></a>声明式导航</h3><pre><code class=\"js\">1.\nimport &#123; Link &#125; from &#39;react-route-dom&#39;\n&lt;Link to=&#39;/index&#39;&gt;导航&lt;/Line&gt; // 选中后不会高亮\n\n2.\nimport &#123; NavLink &#125; from &#39;react-route-dom&#39;\n&lt;NavLink to=&#39;/index&#39; activeClassName=&quot;actived&quot;&gt;可高亮导航&lt;/NavLink&gt; // 可高亮导航\n&lt;NavLink to=&#39;/index&#39; activeStyle=&#123;&#123; border:xx &#125;&#125;&gt;自定义样式&lt;/NavLink&gt; // 自定义样式\n</code></pre>\n<h2 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h2><blockquote>\n<p>在官网中没有这个说明，就是在路由中在套一层路由结构，和vue的子组件一样</p>\n</blockquote>\n<pre><code class=\"js\">*注意： &lt;Router&gt;&lt;/Router&gt; 要将路由相关的所有组件都包裹起来\n</code></pre>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><pre><code class=\"js\">&lt;Link to=&quot;/index/11&quot;&gt;跳转带参&lt;/Link&gt;\n&lt;Route path=&#39;/index:id?&#39; component=&#123; index &#125; /&gt; // 接收,?可选参数\n\nfunction Index(props)&#123;\n    props.match.params // 可以拿到传过来的数据\n&#125;\n</code></pre>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><h3 id=\"antd-mbile\"><a href=\"#antd-mbile\" class=\"headerlink\" title=\"antd-mbile\"></a>antd-mbile</h3><blockquote>\n<p>和 element-ui类似，它和React绝配生命周期</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-04\"><a href=\"#React-04\" class=\"headerlink\" title=\"React-04\"></a>React-04</h1><h3 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h3><pre><code class=\"react\">在创建高阶组件的时候会造成重名\n通过 displayName 改变组件名称：\n    组件变量.displayName = &#39;组件名&#39;\n</code></pre>\n<h3 id=\"React路由\"><a href=\"#React路由\" class=\"headerlink\" title=\"React路由\"></a>React路由</h3><blockquote>\n<p>react中的路由也是一种组件，导入即可使用</p>\n</blockquote>\n<pre><code class=\"javascript\">1. 安装 npm i react-router-dom\n2. 导入\n      import &#123; HashRouter as Router, Route &#125; from &#39;react-router-dom&#39;\n    HashRouter: 路由出口\n    Route: 路由路径和对应的组件\n3. 使用\n    function Index()&#123; //路由组件\n        return &#123;\n            \n        &#125;\n    &#125;\n    \n    function List()&#123; //路由组件\n        return &#123;\n            \n        &#125;\n    &#125;\n\n    function Root()&#123;\n        return &lt;div&gt;\n            &lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125;  \n                &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n                &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n            &lt;/HashRouter&gt; \n        &lt;/div&gt;\n    &#125;\n    \n    export default Root\n</code></pre>\n<ul>\n<li><p><strong>路由模式</strong></p>\n<ol>\n<li>HashRouter ： 带#号</li>\n<li>BrowserRouter : 没有 # 号，利用的是浏览器的 history 属性，推荐</li>\n</ol>\n</li>\n<li><p><strong>404页面</strong></p>\n<pre><code class=\"javascript\">需要用 Switch 包裹，只显示一个路由\n import &#123; HashRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;\n\n&lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125; \n    &lt;Switch&gt;\n        &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n        &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n        &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; // 用 * 号\n    &lt;/Switch&gt;\n&lt;/HashRouter&gt; \n</code></pre>\n</li>\n<li><p><strong>重定向</strong></p>\n<pre><code class=\"js\">Redirect\n\nimport &#123; HashRouter as Router, Route, Redirect &#125; from &#39;react-router-dom&#39;\n\n&lt;HashRouter&gt; &#123;/*BrowserRouter  Router */&#125; \n    &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;\n    &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;\n    &lt;Redirect from=&quot;/&quot; to=&quot;/index&quot; /&gt; \n&lt;/HashRouter&gt; \n</code></pre>\n</li>\n<li><p><strong>路由解析过程</strong></p>\n<pre><code class=\"js\">React 的默认解析模式是模糊匹配，开头相同就匹配，调整为精确匹配即可：exact\n\n1. 输入 url 后\n2. React 解析，获取pathName\n3. 从上到下解析，只要有一个匹配就进入\n4. 将重定向改为精确匹配\n    &lt;Redirect from=&quot;/&quot; to=&quot;/index&quot; exact /&gt; \n</code></pre>\n</li>\n</ul>\n<h2 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h2><h3 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h3><blockquote>\n<p>通过 Props 中的 history 对象实现</p>\n</blockquote>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code class=\"react\">push 和 replace\npush：有历史记录\nreplace：无历史记录\n\nprops.history.push()\nprops.history.replace(&#39;/index&#39;)\n</code></pre>\n<h3 id=\"声明式导航\"><a href=\"#声明式导航\" class=\"headerlink\" title=\"声明式导航\"></a>声明式导航</h3><pre><code class=\"js\">1.\nimport &#123; Link &#125; from &#39;react-route-dom&#39;\n&lt;Link to=&#39;/index&#39;&gt;导航&lt;/Line&gt; // 选中后不会高亮\n\n2.\nimport &#123; NavLink &#125; from &#39;react-route-dom&#39;\n&lt;NavLink to=&#39;/index&#39; activeClassName=&quot;actived&quot;&gt;可高亮导航&lt;/NavLink&gt; // 可高亮导航\n&lt;NavLink to=&#39;/index&#39; activeStyle=&#123;&#123; border:xx &#125;&#125;&gt;自定义样式&lt;/NavLink&gt; // 自定义样式\n</code></pre>\n<h2 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h2><blockquote>\n<p>在官网中没有这个说明，就是在路由中在套一层路由结构，和vue的子组件一样</p>\n</blockquote>\n<pre><code class=\"js\">*注意： &lt;Router&gt;&lt;/Router&gt; 要将路由相关的所有组件都包裹起来\n</code></pre>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><pre><code class=\"js\">&lt;Link to=&quot;/index/11&quot;&gt;跳转带参&lt;/Link&gt;\n&lt;Route path=&#39;/index:id?&#39; component=&#123; index &#125; /&gt; // 接收,?可选参数\n\nfunction Index(props)&#123;\n    props.match.params // 可以拿到传过来的数据\n&#125;\n</code></pre>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><h3 id=\"antd-mbile\"><a href=\"#antd-mbile\" class=\"headerlink\" title=\"antd-mbile\"></a>antd-mbile</h3><blockquote>\n<p>和 element-ui类似，它和React绝配生命周期</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clepi0qbl0001awaf7r39568q","category_id":"clepi0qbr0003awaf3itef8cv","_id":"clepi0qc0000dawaf3vwd2duc"},{"post_id":"clepi0qbo0002awaf04uf21qu","category_id":"clepi0qbx0008awaf3olf189k","_id":"clepi0qc3000kawaffeg23vvj"},{"post_id":"clepi0qbt0005awaf5had7jry","category_id":"clepi0qbx0008awaf3olf189k","_id":"clepi0qc4000pawafh8y649u5"},{"post_id":"clepi0qbw0006awaf96f8a9v5","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qc7000uawaf3yyig0bz"},{"post_id":"clepi0qbx0007awafgzqvam21","category_id":"clepi0qc5000qawaf4m7qdl3x","_id":"clepi0qc90012awaf8xpr76as"},{"post_id":"clepi0qc3000mawafehn7266u","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qck001uawafeji57o82"},{"post_id":"clepi0qc3000mawafehn7266u","category_id":"clepi0qcf001hawafdv655ehs","_id":"clepi0qcl001yawaf1308apic"},{"post_id":"clepi0qc4000oawaf3a0h67dv","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qcm0021awaf52uvfz35"},{"post_id":"clepi0qc4000oawaf3a0h67dv","category_id":"clepi0qcf001hawafdv655ehs","_id":"clepi0qcn0024awafcg3z6k1b"},{"post_id":"clepi0qc5000sawaf35km0a5z","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qco0026awaf0etedwax"},{"post_id":"clepi0qc5000sawaf35km0a5z","category_id":"clepi0qcf001hawafdv655ehs","_id":"clepi0qco002aawaf0nlx89ab"},{"post_id":"clepi0qby000bawafazd31ece","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qcw002vawaf4jxdfkio"},{"post_id":"clepi0qby000bawafazd31ece","category_id":"clepi0qcr002jawaf9kida4hy","_id":"clepi0qcx002yawaf0hllfsbo"},{"post_id":"clepi0qbz000cawaf1wl0e3ap","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qcy0039awafdoku5mj3"},{"post_id":"clepi0qbz000cawaf1wl0e3ap","category_id":"clepi0qcr002jawaf9kida4hy","_id":"clepi0qcy003cawafdjsn5bk1"},{"post_id":"clepi0qc1000gawaffg083cy1","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qd0003mawaf12nwgqmr"},{"post_id":"clepi0qc1000gawaffg083cy1","category_id":"clepi0qcr002jawaf9kida4hy","_id":"clepi0qd0003nawaf8lkq0n8i"},{"post_id":"clepi0qc2000iawafh6cpczl4","category_id":"clepi0qc3000jawafdpcl1w3u","_id":"clepi0qd1003wawaf8ejb8f97"},{"post_id":"clepi0qc2000iawafh6cpczl4","category_id":"clepi0qcf001hawafdv655ehs","_id":"clepi0qd1003yawaf3e2pfal1"},{"post_id":"clepi0qcn0023awaf62gxekik","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qd7004pawaf7ah73bpc"},{"post_id":"clepi0qcn0023awaf62gxekik","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qd8004rawaf2m6cdf0h"},{"post_id":"clepi0qc6000tawafbp8sbchg","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qd8004vawafbc4q1x38"},{"post_id":"clepi0qc6000tawafbp8sbchg","category_id":"clepi0qd7004mawafccvued35","_id":"clepi0qd9004yawaf9gbu5jrz"},{"post_id":"clepi0qcn0025awaffa2x9ewz","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qd90051awaff0bug9eu"},{"post_id":"clepi0qcn0025awaffa2x9ewz","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qda0054awafgicygq2e"},{"post_id":"clepi0qco0029awaf3cgu7o10","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qda0056awaf51cwf2v8"},{"post_id":"clepi0qco0029awaf3cgu7o10","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qda0058awaf1h5k6lhm"},{"post_id":"clepi0qc8000xawaf25nq8u87","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdb005bawaf3oi04wgo"},{"post_id":"clepi0qc8000xawaf25nq8u87","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdc005eawafakbtewpv"},{"post_id":"clepi0qcp002cawaf6i7h7c97","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdc005hawaf2cae86c7"},{"post_id":"clepi0qcp002cawaf6i7h7c97","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdc005kawafafz70h2s"},{"post_id":"clepi0qcq002gawafccrod8ht","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdd005mawaf95sd5ywh"},{"post_id":"clepi0qcq002gawafccrod8ht","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdd005oawafam2a535i"},{"post_id":"clepi0qc8000zawaf097ih2rz","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdd005rawaf3ln064rs"},{"post_id":"clepi0qc8000zawaf097ih2rz","category_id":"clepi0qd7004mawafccvued35","_id":"clepi0qdd005uawafdofcbayt"},{"post_id":"clepi0qcq002iawaf8ogg71cz","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qde005xawafg39w0k3k"},{"post_id":"clepi0qcq002iawaf8ogg71cz","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qde0060awafcjn7cqn1"},{"post_id":"clepi0qcr002lawafgayg2gq2","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdf0063awafcyip6dq0"},{"post_id":"clepi0qcr002lawafgayg2gq2","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdf0066awaf8l9w3jnl"},{"post_id":"clepi0qct002nawaf1vpm23ze","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdf0068awafahacfcf2"},{"post_id":"clepi0qct002nawaf1vpm23ze","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdf006aawaf28v324n7"},{"post_id":"clepi0qcu002rawaf1fno1j0y","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdg006dawaf2selao39"},{"post_id":"clepi0qcu002rawaf1fno1j0y","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdg006gawaf28nr4qet"},{"post_id":"clepi0qc90013awaf4ok037ad","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdg006jawafghjv26j9"},{"post_id":"clepi0qc90013awaf4ok037ad","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdi006mawafd98ag56f"},{"post_id":"clepi0qcv002tawaf6cu13umx","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdi006pawafhjmoe3ym"},{"post_id":"clepi0qcv002tawaf6cu13umx","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdi006sawafbyjia7zm"},{"post_id":"clepi0qcb0016awafdsa5e4b6","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdi006uawaf60ul993r"},{"post_id":"clepi0qcb0016awafdsa5e4b6","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdj006wawaf0o5o3nxl"},{"post_id":"clepi0qcc0018awaf797e3avq","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdj006zawaf2gj3946x"},{"post_id":"clepi0qcc0018awaf797e3avq","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdj0072awaf33epa29z"},{"post_id":"clepi0qcd001aawaf0bpj65tt","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdk0075awaf2soq9gla"},{"post_id":"clepi0qcd001aawaf0bpj65tt","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdk0078awafcpo714xm"},{"post_id":"clepi0qce001cawafh3ft4sd2","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdk007bawaf3c11fzhu"},{"post_id":"clepi0qce001cawafh3ft4sd2","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdl007eawaf43nocbwy"},{"post_id":"clepi0qcf001fawaf0d45dtz1","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdl007gawafa8tubyr3"},{"post_id":"clepi0qcf001fawaf0d45dtz1","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdl007iawaf72y65gpm"},{"post_id":"clepi0qcf001iawafdgsh8b4w","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdl007lawaffqyzhkvj"},{"post_id":"clepi0qcf001iawafdgsh8b4w","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdm007oawaf3jqff22s"},{"post_id":"clepi0qcg001lawafh32a7uol","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdm007rawaff1b5cgvb"},{"post_id":"clepi0qcg001lawafh32a7uol","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdm007uawaf9yj8gkku"},{"post_id":"clepi0qch001nawafcntt3vfo","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdm007wawafc9afg85o"},{"post_id":"clepi0qch001nawafcntt3vfo","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdn007yawaf5aqphof9"},{"post_id":"clepi0qci001qawafb5yk4lz1","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdo0081awaf5w7m2dqb"},{"post_id":"clepi0qci001qawafb5yk4lz1","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdo0084awafaz0e2vbw"},{"post_id":"clepi0qcj001sawaf4p8m61sn","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdo0087awafhvpf0c5s"},{"post_id":"clepi0qcj001sawaf4p8m61sn","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdp008aawaf3bqh8s3n"},{"post_id":"clepi0qck001xawaffrve39lh","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qdp008bawaf4opyh16n"},{"post_id":"clepi0qck001xawaffrve39lh","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qdp008dawaf6ttjer7h"},{"post_id":"clepi0qcl001zawaf8q869gjx","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qds008fawafavhf1w5c"},{"post_id":"clepi0qcl001zawaf8q869gjx","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qds008iawaf24x9fnm6"},{"post_id":"clepi0qe2009yawafhe1mg2zc","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qe400a4awaf70awerjt"},{"post_id":"clepi0qe2009yawafhe1mg2zc","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qe400a7awaf419o1q6r"},{"post_id":"clepi0qe2009zawaf60znde3v","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qe500aaawafc99d3s6k"},{"post_id":"clepi0qe2009zawaf60znde3v","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qe700afawafa6q66ama"},{"post_id":"clepi0qe300a1awaf799s3qg8","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qe700aiawaf320n7p8y"},{"post_id":"clepi0qe300a1awaf799s3qg8","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qe800anawaf882zfhkc"},{"post_id":"clepi0qe300a3awafaglt6itp","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qe900aqawaf4n0h3tos"},{"post_id":"clepi0qe300a3awafaglt6itp","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qe900avawaf3aue872x"},{"post_id":"clepi0qe700ahawaf9tsu8jp9","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qea00ayawafdgc28buz"},{"post_id":"clepi0qe700ahawaf9tsu8jp9","category_id":"clepi0qe600aeawafdxwh4ljd","_id":"clepi0qeb00b1awaf16od40eq"},{"post_id":"clepi0qe400a6awaf4c90h732","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qeb00b4awaf95r83xxv"},{"post_id":"clepi0qe400a6awaf4c90h732","category_id":"clepi0qe600aeawafdxwh4ljd","_id":"clepi0qec00b7awafb6fp8cnp"},{"post_id":"clepi0qe700akawaf55r6aeh2","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qec00bbawaf3ndndstv"},{"post_id":"clepi0qe700akawaf55r6aeh2","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qed00beawaf8tzyb96p"},{"post_id":"clepi0qe800apawaf845o7b2d","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qed00bhawaf2kez1u09"},{"post_id":"clepi0qe800apawaf845o7b2d","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qed00bjawaf4mf42n92"},{"post_id":"clepi0qe400a9awafgrio9ymw","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qed00bmawaf9l610dq0"},{"post_id":"clepi0qe400a9awafgrio9ymw","category_id":"clepi0qe600aeawafdxwh4ljd","_id":"clepi0qed00boawaf3svw30f8"},{"post_id":"clepi0qe900asawaf0ihs1tnq","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00bqawaf5bdn6b2k"},{"post_id":"clepi0qe900asawaf0ihs1tnq","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00bsawaf2ouvfr8u"},{"post_id":"clepi0qe900axawaf9jwtglow","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00buawaffu51fjkb"},{"post_id":"clepi0qe900axawaf9jwtglow","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00bwawafajpwga7p"},{"post_id":"clepi0qe600adawaf16ba0gcm","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00byawafeyh6bgqv"},{"post_id":"clepi0qe600adawaf16ba0gcm","category_id":"clepi0qe600aeawafdxwh4ljd","_id":"clepi0qee00c0awafenyy8wzl"},{"post_id":"clepi0qea00b0awafdhiq154p","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00c2awaf9z57hym2"},{"post_id":"clepi0qea00b0awafdhiq154p","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00c4awaf8bpu7v5p"},{"post_id":"clepi0qeb00b3awaf55lw5p5c","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00c6awafbnnr4uwp"},{"post_id":"clepi0qeb00b3awaf55lw5p5c","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00c8awafc3qwel0n"},{"post_id":"clepi0qeb00b6awaf2kgr1ie7","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00caawaf5yrb66tj"},{"post_id":"clepi0qeb00b6awaf2kgr1ie7","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00ccawafh5q8bn8e"},{"post_id":"clepi0qec00baawafe8zh13v4","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qee00ceawaf0rfr5eil"},{"post_id":"clepi0qec00baawafe8zh13v4","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qee00cgawafbs5xbtol"},{"post_id":"clepi0qec00bdawafhuptdrm6","category_id":"clepi0qcm0020awaf5nb15d3p","_id":"clepi0qef00ciawaf1lz8dxj1"},{"post_id":"clepi0qec00bdawafhuptdrm6","category_id":"clepi0qd6004hawaf41tlerki","_id":"clepi0qef00ckawaf2l5t20dv"}],"PostTag":[{"post_id":"clepi0qbl0001awaf7r39568q","tag_id":"clepi0qbs0004awaf4mt2aeix","_id":"clepi0qby000aawafg1ay77mk"},{"post_id":"clepi0qbo0002awaf04uf21qu","tag_id":"clepi0qby0009awaf7igy10aw","_id":"clepi0qc2000hawaf0sy5efgl"},{"post_id":"clepi0qbt0005awaf5had7jry","tag_id":"clepi0qby0009awaf7igy10aw","_id":"clepi0qc4000nawafc78ma51y"},{"post_id":"clepi0qbw0006awaf96f8a9v5","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qc8000yawafgheo7zow"},{"post_id":"clepi0qbw0006awaf96f8a9v5","tag_id":"clepi0qc5000rawaf0q6j0px3","_id":"clepi0qc90010awafb17mdupl"},{"post_id":"clepi0qbx0007awafgzqvam21","tag_id":"clepi0qc8000wawaf8o0dfygc","_id":"clepi0qca0015awafeevr5oq8"},{"post_id":"clepi0qcd001aawaf0bpj65tt","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qce001eawaf90tjehri"},{"post_id":"clepi0qcd001aawaf0bpj65tt","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qcf001gawafe87jhjgr"},{"post_id":"clepi0qby000bawafazd31ece","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcg001kawaff5cx2oqu"},{"post_id":"clepi0qby000bawafazd31ece","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qch001mawafdvw55srf"},{"post_id":"clepi0qbz000cawaf1wl0e3ap","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcj001rawaf5b7sf2ig"},{"post_id":"clepi0qbz000cawaf1wl0e3ap","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qck001vawaf1wtedxzu"},{"post_id":"clepi0qc1000gawaffg083cy1","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcp002bawaf3b4h16ca"},{"post_id":"clepi0qc1000gawaffg083cy1","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qcp002eawaf966w9jpu"},{"post_id":"clepi0qc1000gawaffg083cy1","tag_id":"clepi0qcm0022awafdti666p0","_id":"clepi0qcq002hawaf1svp6ga9"},{"post_id":"clepi0qc2000iawafh6cpczl4","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qct002mawaf0kka1apm"},{"post_id":"clepi0qc2000iawafh6cpczl4","tag_id":"clepi0qcp002fawaf85la3und","_id":"clepi0qcu002pawaf10ja40je"},{"post_id":"clepi0qc3000mawafehn7266u","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcv002sawaf75uq5i4i"},{"post_id":"clepi0qc3000mawafehn7266u","tag_id":"clepi0qcp002fawaf85la3und","_id":"clepi0qcw002wawaf1ebhb9ep"},{"post_id":"clepi0qc4000oawaf3a0h67dv","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcx002zawaf6lc0hhd3"},{"post_id":"clepi0qc4000oawaf3a0h67dv","tag_id":"clepi0qcp002fawaf85la3und","_id":"clepi0qcx0031awaf35k83wr6"},{"post_id":"clepi0qc5000sawaf35km0a5z","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcx0033awaf6fuj7o1g"},{"post_id":"clepi0qc5000sawaf35km0a5z","tag_id":"clepi0qcp002fawaf85la3und","_id":"clepi0qcy0035awafftsh7k42"},{"post_id":"clepi0qc6000tawafbp8sbchg","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcy0037awafdi5u8288"},{"post_id":"clepi0qc6000tawafbp8sbchg","tag_id":"clepi0qcx0032awafhjne33mg","_id":"clepi0qcy003aawaf7kf05ijg"},{"post_id":"clepi0qc8000xawaf25nq8u87","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcz003dawafhocpfeiv"},{"post_id":"clepi0qc8000xawaf25nq8u87","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qcz003fawaf6iqces25"},{"post_id":"clepi0qc8000zawaf097ih2rz","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qcz003hawaf7mi35ryt"},{"post_id":"clepi0qc8000zawaf097ih2rz","tag_id":"clepi0qcx0032awafhjne33mg","_id":"clepi0qcz003jawafaw3fgtlv"},{"post_id":"clepi0qc90013awaf4ok037ad","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qd1003sawafakb26ev8"},{"post_id":"clepi0qc90013awaf4ok037ad","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qd1003tawafg38sh7yw"},{"post_id":"clepi0qc90013awaf4ok037ad","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qd1003xawafb3vacuo1"},{"post_id":"clepi0qc90013awaf4ok037ad","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qd2003zawafce8rgyiv"},{"post_id":"clepi0qcb0016awafdsa5e4b6","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qd30042awafgzfo7p91"},{"post_id":"clepi0qcb0016awafdsa5e4b6","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qd30043awaf20jw4w9m"},{"post_id":"clepi0qcc0018awaf797e3avq","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qd50048awaf7vjr61kf"},{"post_id":"clepi0qcc0018awaf797e3avq","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qd50049awafajmtbo6z"},{"post_id":"clepi0qcc0018awaf797e3avq","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qd6004cawafe40g10ox"},{"post_id":"clepi0qcc0018awaf797e3avq","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qd6004dawaf2m4jhmof"},{"post_id":"clepi0qce001cawafh3ft4sd2","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qd7004iawaf0yg8gwd6"},{"post_id":"clepi0qce001cawafh3ft4sd2","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qd7004jawaf35xjcdyp"},{"post_id":"clepi0qce001cawafh3ft4sd2","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qd7004lawaf302shxgz"},{"post_id":"clepi0qce001cawafh3ft4sd2","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qd7004nawaf250xcmpz"},{"post_id":"clepi0qcf001fawaf0d45dtz1","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qd8004tawaf1qz90ifq"},{"post_id":"clepi0qcf001fawaf0d45dtz1","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qd9004wawaf589rfn55"},{"post_id":"clepi0qcf001fawaf0d45dtz1","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qd9004zawafea4d9fih"},{"post_id":"clepi0qcf001fawaf0d45dtz1","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qd90052awaffvhw7ijo"},{"post_id":"clepi0qcf001iawafdgsh8b4w","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdb0059awaf69paasa0"},{"post_id":"clepi0qcf001iawafdgsh8b4w","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdb005cawaf9behf3lh"},{"post_id":"clepi0qcf001iawafdgsh8b4w","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdc005fawaf5o7t4kfh"},{"post_id":"clepi0qcf001iawafdgsh8b4w","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdc005iawafd2f68c58"},{"post_id":"clepi0qcg001lawafh32a7uol","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdd005pawaf0zv67d6m"},{"post_id":"clepi0qcg001lawafh32a7uol","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdd005sawaff0byb78y"},{"post_id":"clepi0qcg001lawafh32a7uol","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qde005vawaf55031818"},{"post_id":"clepi0qcg001lawafh32a7uol","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qde005yawafcbm5dh8r"},{"post_id":"clepi0qch001nawafcntt3vfo","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qde0061awafde4vhqou"},{"post_id":"clepi0qch001nawafcntt3vfo","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdf0064awafcv56aety"},{"post_id":"clepi0qci001qawafb5yk4lz1","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdf006bawafg5m6aged"},{"post_id":"clepi0qci001qawafb5yk4lz1","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdg006eawaf7yd7c9ph"},{"post_id":"clepi0qci001qawafb5yk4lz1","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdg006hawaf1g300f3b"},{"post_id":"clepi0qci001qawafb5yk4lz1","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdg006kawafcb5kffag"},{"post_id":"clepi0qcj001sawaf4p8m61sn","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdi006nawafdvpk4hkt"},{"post_id":"clepi0qcj001sawaf4p8m61sn","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdi006qawaf2p369n2n"},{"post_id":"clepi0qck001xawaffrve39lh","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdj006xawaf6v6yhcsj"},{"post_id":"clepi0qck001xawaffrve39lh","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdj0070awafflsffywm"},{"post_id":"clepi0qck001xawaffrve39lh","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdk0073awafazx0dijt"},{"post_id":"clepi0qck001xawaffrve39lh","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdk0076awaf10gm32pl"},{"post_id":"clepi0qcl001zawaf8q869gjx","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdk0079awaf77o46m3a"},{"post_id":"clepi0qcl001zawaf8q869gjx","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdk007cawaf2xzo53wh"},{"post_id":"clepi0qcn0023awaf62gxekik","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdl007jawafgu2wa55n"},{"post_id":"clepi0qcn0023awaf62gxekik","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdl007mawaf78na7g4g"},{"post_id":"clepi0qcn0023awaf62gxekik","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdm007pawafecxn95tr"},{"post_id":"clepi0qcn0023awaf62gxekik","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdm007sawaf14if1wgb"},{"post_id":"clepi0qcn0025awaffa2x9ewz","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdn007zawaf18defdxb"},{"post_id":"clepi0qcn0025awaffa2x9ewz","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdo0082awafaw37820f"},{"post_id":"clepi0qcn0025awaffa2x9ewz","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdo0085awaffd6x2xlu"},{"post_id":"clepi0qcn0025awaffa2x9ewz","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdo0088awaffp1291dw"},{"post_id":"clepi0qco0029awaf3cgu7o10","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qds008eawaf2ivgg9li"},{"post_id":"clepi0qco0029awaf3cgu7o10","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qds008gawaf0eov0hjz"},{"post_id":"clepi0qco0029awaf3cgu7o10","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qds008jawaf5yzvev6p"},{"post_id":"clepi0qco0029awaf3cgu7o10","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qds008kawaf3uou11to"},{"post_id":"clepi0qcp002cawaf6i7h7c97","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdt008nawaf5pnk7xxz"},{"post_id":"clepi0qcp002cawaf6i7h7c97","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdt008oawafcha8av64"},{"post_id":"clepi0qcp002cawaf6i7h7c97","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdt008qawaffbj39zzq"},{"post_id":"clepi0qcp002cawaf6i7h7c97","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdt008rawafc0r6bgdk"},{"post_id":"clepi0qcq002gawafccrod8ht","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdt008uawaf4omk7w89"},{"post_id":"clepi0qcq002gawafccrod8ht","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdt008vawafdou969ne"},{"post_id":"clepi0qcq002gawafccrod8ht","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdu008xawafdb6qg5ts"},{"post_id":"clepi0qcq002gawafccrod8ht","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdu008yawafccrr7v47"},{"post_id":"clepi0qcq002iawaf8ogg71cz","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdu0091awafcg3x5uvb"},{"post_id":"clepi0qcq002iawaf8ogg71cz","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdu0092awafd8x4acib"},{"post_id":"clepi0qcq002iawaf8ogg71cz","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdu0094awaff50377ju"},{"post_id":"clepi0qcq002iawaf8ogg71cz","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdu0095awaf7lv0bpix"},{"post_id":"clepi0qcr002lawafgayg2gq2","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdv0098awafb9s5hkm7"},{"post_id":"clepi0qcr002lawafgayg2gq2","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdv0099awaf8wo2gpf6"},{"post_id":"clepi0qcr002lawafgayg2gq2","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdv009bawafb0e01c7i"},{"post_id":"clepi0qcr002lawafgayg2gq2","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdv009cawaffrchbupu"},{"post_id":"clepi0qct002nawaf1vpm23ze","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdv009fawaf2c7shce5"},{"post_id":"clepi0qct002nawaf1vpm23ze","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdv009gawaf6w0r9hcm"},{"post_id":"clepi0qct002nawaf1vpm23ze","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdv009iawafbmuzdxwp"},{"post_id":"clepi0qct002nawaf1vpm23ze","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdw009jawaf4itc1f0x"},{"post_id":"clepi0qcu002rawaf1fno1j0y","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdw009mawafbwiaflku"},{"post_id":"clepi0qcu002rawaf1fno1j0y","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdw009nawaff7psf0p8"},{"post_id":"clepi0qcu002rawaf1fno1j0y","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdw009pawafes4md0l0"},{"post_id":"clepi0qcu002rawaf1fno1j0y","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdw009qawaffyo0fbyk"},{"post_id":"clepi0qcv002tawaf6cu13umx","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qdx009tawafc6uy7lpe"},{"post_id":"clepi0qcv002tawaf6cu13umx","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qdx009uawaf4ykk9vbz"},{"post_id":"clepi0qcv002tawaf6cu13umx","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qdx009vawaf9f2we4o0"},{"post_id":"clepi0qcv002tawaf6cu13umx","tag_id":"clepi0qdw009rawaf9tko16va","_id":"clepi0qdx009wawafcubxfoqz"},{"post_id":"clepi0qcv002tawaf6cu13umx","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qdx009xawaf3k5wcoxq"},{"post_id":"clepi0qe2009zawaf60znde3v","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qe300a2awaf80lv9afz"},{"post_id":"clepi0qe2009zawaf60znde3v","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qe400a5awaf8pg26165"},{"post_id":"clepi0qe2009zawaf60znde3v","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qe400a8awafb8ff96qh"},{"post_id":"clepi0qe2009zawaf60znde3v","tag_id":"clepi0qdw009rawaf9tko16va","_id":"clepi0qe600acawaf4upveip7"},{"post_id":"clepi0qe2009zawaf60znde3v","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qe700agawaf9lyx63ep"},{"post_id":"clepi0qe300a1awaf799s3qg8","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qe700ajawafddvr5r2o"},{"post_id":"clepi0qe300a1awaf799s3qg8","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qe800aoawaf10cqer22"},{"post_id":"clepi0qe300a1awaf799s3qg8","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qe900arawafbn2u1g4a"},{"post_id":"clepi0qe300a1awaf799s3qg8","tag_id":"clepi0qdw009rawaf9tko16va","_id":"clepi0qe900awawaf76bh3ydu"},{"post_id":"clepi0qe300a1awaf799s3qg8","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qea00azawaf9eswcmg5"},{"post_id":"clepi0qe300a3awafaglt6itp","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qeb00b2awaffl4s9ztq"},{"post_id":"clepi0qe300a3awafaglt6itp","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qeb00b5awafg5n2gewe"},{"post_id":"clepi0qe300a3awafaglt6itp","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qec00b9awaf64ry6uat"},{"post_id":"clepi0qe300a3awafaglt6itp","tag_id":"clepi0qe300a0awaf8aw4do1h","_id":"clepi0qec00bcawaf3cit1cav"},{"post_id":"clepi0qe300a3awafaglt6itp","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qed00bfawaf7hiad095"},{"post_id":"clepi0qe2009yawafhe1mg2zc","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qed00biawaf2qk5fzeu"},{"post_id":"clepi0qe2009yawafhe1mg2zc","tag_id":"clepi0qcy0036awaf9no29ng9","_id":"clepi0qed00bkawaf11d4emqs"},{"post_id":"clepi0qe2009yawafhe1mg2zc","tag_id":"clepi0qcz003kawafa0wob487","_id":"clepi0qed00bnawaf98rz331w"},{"post_id":"clepi0qe2009yawafhe1mg2zc","tag_id":"clepi0qe300a0awaf8aw4do1h","_id":"clepi0qed00bpawaf3ddiabne"},{"post_id":"clepi0qe2009yawafhe1mg2zc","tag_id":"clepi0qd0003oawafh8bqastq","_id":"clepi0qee00brawafdkmfg3l4"},{"post_id":"clepi0qe700ahawaf9tsu8jp9","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00btawaf2zn20c7i"},{"post_id":"clepi0qe700ahawaf9tsu8jp9","tag_id":"clepi0qe600abawaf8oi34u0z","_id":"clepi0qee00bvawaf3fsccnqc"},{"post_id":"clepi0qe400a6awaf4c90h732","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00bxawaf68495109"},{"post_id":"clepi0qe400a6awaf4c90h732","tag_id":"clepi0qe600abawaf8oi34u0z","_id":"clepi0qee00bzawaf38asaw7c"},{"post_id":"clepi0qe700akawaf55r6aeh2","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00c1awaf9clfc7hy"},{"post_id":"clepi0qe700akawaf55r6aeh2","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qee00c3awafgwdy3j80"},{"post_id":"clepi0qe800apawaf845o7b2d","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00c5awaf61zldx4j"},{"post_id":"clepi0qe800apawaf845o7b2d","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qee00c7awaffdidcamt"},{"post_id":"clepi0qe400a9awafgrio9ymw","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00c9awaf1qmchb5u"},{"post_id":"clepi0qe400a9awafgrio9ymw","tag_id":"clepi0qe600abawaf8oi34u0z","_id":"clepi0qee00cbawafgir98lvn"},{"post_id":"clepi0qe900asawaf0ihs1tnq","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00cdawafgty832k1"},{"post_id":"clepi0qe900asawaf0ihs1tnq","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qee00cfawafcjlb6lgf"},{"post_id":"clepi0qe900axawaf9jwtglow","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qee00chawafc9ui6me2"},{"post_id":"clepi0qe900axawaf9jwtglow","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qef00cjawaf2bq52t0w"},{"post_id":"clepi0qe600adawaf16ba0gcm","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00clawaf389l20wl"},{"post_id":"clepi0qe600adawaf16ba0gcm","tag_id":"clepi0qe600abawaf8oi34u0z","_id":"clepi0qef00cmawaf49474hmg"},{"post_id":"clepi0qea00b0awafdhiq154p","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00cnawafawvadp97"},{"post_id":"clepi0qea00b0awafdhiq154p","tag_id":"clepi0qcc0019awaf03gf9ms5","_id":"clepi0qef00coawafhop8a859"},{"post_id":"clepi0qec00bdawafhuptdrm6","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00cpawafaudkb1ds"},{"post_id":"clepi0qec00bdawafhuptdrm6","tag_id":"clepi0qec00b8awaf9li4gmsq","_id":"clepi0qef00cqawaf2ik94xbw"},{"post_id":"clepi0qeb00b3awaf55lw5p5c","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00crawafapbo8cac"},{"post_id":"clepi0qeb00b3awaf55lw5p5c","tag_id":"clepi0qec00b8awaf9li4gmsq","_id":"clepi0qef00csawaf44n24lc6"},{"post_id":"clepi0qeb00b6awaf2kgr1ie7","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00ctawafgu2u4ka8"},{"post_id":"clepi0qeb00b6awaf2kgr1ie7","tag_id":"clepi0qec00b8awaf9li4gmsq","_id":"clepi0qef00cuawafa8sw6dtv"},{"post_id":"clepi0qec00baawafe8zh13v4","tag_id":"clepi0qc3000lawaf1009gyzp","_id":"clepi0qef00cvawaf016ucxer"},{"post_id":"clepi0qec00baawafe8zh13v4","tag_id":"clepi0qec00b8awaf9li4gmsq","_id":"clepi0qef00cwawafa5lmdfa9"}],"Tag":[{"name":"后端","_id":"clepi0qbs0004awaf4mt2aeix"},{"name":"git","_id":"clepi0qby0009awaf7igy10aw"},{"name":"前端","_id":"clepi0qc3000lawaf1009gyzp"},{"name":"优化","_id":"clepi0qc5000rawaf0q6j0px3"},{"name":"运维","_id":"clepi0qc8000wawaf8o0dfygc"},{"name":"vue","_id":"clepi0qcc0019awaf03gf9ms5"},{"name":"vue-admin-element-plus","_id":"clepi0qcm0022awafdti666p0"},{"name":"原生js","_id":"clepi0qcp002fawaf85la3und"},{"name":"正则","_id":"clepi0qcx0032awafhjne33mg"},{"name":"笔记","_id":"clepi0qcy0036awaf9no29ng9"},{"name":"js","_id":"clepi0qcz003kawafa0wob487"},{"name":"javascript","_id":"clepi0qd0003oawafh8bqastq"},{"name":"jquery","_id":"clepi0qdw009rawaf9tko16va"},{"name":"ajax","_id":"clepi0qe300a0awaf8aw4do1h"},{"name":"node","_id":"clepi0qe600abawaf8oi34u0z"},{"name":"react","_id":"clepi0qec00b8awaf9li4gmsq"}]}}